[
    {
        "id": 37017,
        "url": "https://github.com/microsoft/vscode/pull/37017",
        "arquivo_caminho": "src/vs/editor/editor.main.ts",
        "descricao_bug": "For some reason,  I have to compile the monaco-editor by myself.\r\nRecently I update the monaco and found that the editor crash while loading the monaco.\r\nIt seems that we need polyfill the `promise` after we set the `global`.\r\n\r\n<img width=\"540\" alt=\"2017-10-27 11 45 47\" src=\"https://user-images.githubusercontent.com/12891758/32087135-6fa9c114-ba9f-11e7-83ca-030e75b18772.png\">\r\n\r\n",
        "contexto": {
            "codigo_completo_bugado": "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n'use strict';\n\nimport 'vs/editor/editor.all';\nimport 'vs/editor/standalone/browser/accessibilityHelp/accessibilityHelp';\nimport 'vs/editor/standalone/browser/inspectTokens/inspectTokens';\nimport 'vs/editor/standalone/browser/iPadShowKeyboard/iPadShowKeyboard';\nimport 'vs/editor/standalone/browser/quickOpen/quickOutline';\nimport 'vs/editor/standalone/browser/quickOpen/gotoLine';\nimport 'vs/editor/standalone/browser/quickOpen/quickCommand';\nimport 'vs/editor/standalone/browser/toggleHighContrast/toggleHighContrast';\n\nimport { createMonacoBaseAPI } from 'vs/editor/common/standalone/standaloneBase';\nimport { createMonacoEditorAPI } from 'vs/editor/standalone/browser/standaloneEditor';\nimport { createMonacoLanguagesAPI } from 'vs/editor/standalone/browser/standaloneLanguages';\nimport { EDITOR_DEFAULTS, WrappingIndent } from 'vs/editor/common/config/editorOptions';\n\n// When missing, polyfill the native promise\n// with our winjs-based polyfill\nimport { PolyfillPromise } from 'vs/base/common/winjs.polyfill.promise';\nif (typeof global.Promise === 'undefined') {\n\tglobal.Promise = PolyfillPromise;\n}\n\n// Set defaults for standalone editor\n(<any>EDITOR_DEFAULTS).wrappingIndent = WrappingIndent.None;\n(<any>EDITOR_DEFAULTS.contribInfo).folding = false;\n(<any>EDITOR_DEFAULTS.viewInfo).glyphMargin = false;\n(<any>EDITOR_DEFAULTS).autoIndent = false;\n\nlet base = createMonacoBaseAPI();\nfor (let prop in base) {\n\tif (base.hasOwnProperty(prop)) {\n\t\texports[prop] = base[prop];\n\t}\n}\nexports.editor = createMonacoEditorAPI();\nexports.languages = createMonacoLanguagesAPI();\n\nvar global: any = self;\nglobal.monaco = exports;\n\nif (typeof global.require !== 'undefined' && typeof global.require.config === 'function') {\n\tglobal.require.config({\n\t\tignoreDuplicateModules: [\n\t\t\t'vscode-languageserver-types',\n\t\t\t'vscode-languageserver-types/main',\n\t\t\t'vscode-nls',\n\t\t\t'vscode-nls/vscode-nls',\n\t\t\t'jsonc-parser',\n\t\t\t'jsonc-parser/main',\n\t\t\t'vscode-uri',\n\t\t\t'vscode-uri/index'\n\t\t]\n\t});\n}\n",
            "linguagem": "ts",
            "total_linhas": 61
        },
        "solucao_humana": {
            "patch_diff": "@@ -19,6 +19,9 @@ import { createMonacoEditorAPI } from 'vs/editor/standalone/browser/standaloneEd\n import { createMonacoLanguagesAPI } from 'vs/editor/standalone/browser/standaloneLanguages';\n import { EDITOR_DEFAULTS, WrappingIndent } from 'vs/editor/common/config/editorOptions';\n \n+var global: any = self;\n+global.monaco = exports;\n+\n // When missing, polyfill the native promise\n // with our winjs-based polyfill\n import { PolyfillPromise } from 'vs/base/common/winjs.polyfill.promise';\n@@ -41,9 +44,6 @@ for (let prop in base) {\n exports.editor = createMonacoEditorAPI();\n exports.languages = createMonacoLanguagesAPI();\n \n-var global: any = self;\n-global.monaco = exports;\n-\n if (typeof global.require !== 'undefined' && typeof global.require.config === 'function') {\n \tglobal.require.config({\n \t\tignoreDuplicateModules: [",
            "apenas_linhas_adicionadas": [
                "var global: any = self;",
                "global.monaco = exports;",
                ""
            ]
        }
    },
    {
        "id": 47052,
        "url": "https://github.com/microsoft/vscode/pull/47052",
        "arquivo_caminho": "extensions/git/src/commands.ts",
        "descricao_bug": "fixes #46860",
        "contexto": {
            "codigo_completo_bugado": "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n'use strict';\n\nimport { Uri, commands, Disposable, window, workspace, QuickPickItem, OutputChannel, Range, WorkspaceEdit, Position, LineChange, SourceControlResourceState, TextDocumentShowOptions, ViewColumn, ProgressLocation, TextEditor, CancellationTokenSource, StatusBarAlignment, MessageOptions } from 'vscode';\nimport { Ref, RefType, Git, GitErrorCodes, Branch } from './git';\nimport { Repository, Resource, Status, CommitOptions, ResourceGroupType } from './repository';\nimport { Model } from './model';\nimport { toGitUri, fromGitUri } from './uri';\nimport { grep, isDescendant } from './util';\nimport { applyLineChanges, intersectDiffWithRange, toLineRanges, invertLineChange, getModifiedRange } from './staging';\nimport * as path from 'path';\nimport { lstat, Stats } from 'fs';\nimport * as os from 'os';\nimport TelemetryReporter from 'vscode-extension-telemetry';\nimport * as nls from 'vscode-nls';\n\nconst localize = nls.loadMessageBundle();\n\nclass CheckoutItem implements QuickPickItem {\n\n\tprotected get shortCommit(): string { return (this.ref.commit || '').substr(0, 8); }\n\tprotected get treeish(): string | undefined { return this.ref.name; }\n\tget label(): string { return this.ref.name || this.shortCommit; }\n\tget description(): string { return this.shortCommit; }\n\n\tconstructor(protected ref: Ref) { }\n\n\tasync run(repository: Repository): Promise<void> {\n\t\tconst ref = this.treeish;\n\n\t\tif (!ref) {\n\t\t\treturn;\n\t\t}\n\n\t\tawait repository.checkout(ref);\n\t}\n}\n\nclass CheckoutTagItem extends CheckoutItem {\n\n\tget description(): string {\n\t\treturn localize('tag at', \"Tag at {0}\", this.shortCommit);\n\t}\n}\n\nclass CheckoutRemoteHeadItem extends CheckoutItem {\n\n\tget description(): string {\n\t\treturn localize('remote branch at', \"Remote branch at {0}\", this.shortCommit);\n\t}\n\n\tprotected get treeish(): string | undefined {\n\t\tif (!this.ref.name) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst match = /^[^/]+\\/(.*)$/.exec(this.ref.name);\n\t\treturn match ? match[1] : this.ref.name;\n\t}\n}\n\nclass BranchDeleteItem implements QuickPickItem {\n\n\tprivate get shortCommit(): string { return (this.ref.commit || '').substr(0, 8); }\n\tget branchName(): string | undefined { return this.ref.name; }\n\tget label(): string { return this.branchName || ''; }\n\tget description(): string { return this.shortCommit; }\n\n\tconstructor(private ref: Ref) { }\n\n\tasync run(repository: Repository, force?: boolean): Promise<void> {\n\t\tif (!this.branchName) {\n\t\t\treturn;\n\t\t}\n\t\tawait repository.deleteBranch(this.branchName, force);\n\t}\n}\n\nclass MergeItem implements QuickPickItem {\n\n\tget label(): string { return this.ref.name || ''; }\n\tget description(): string { return this.ref.name || ''; }\n\n\tconstructor(protected ref: Ref) { }\n\n\tasync run(repository: Repository): Promise<void> {\n\t\tawait repository.merge(this.ref.name! || this.ref.commit!);\n\t}\n}\n\nclass CreateBranchItem implements QuickPickItem {\n\n\tconstructor(private cc: CommandCenter) { }\n\n\tget label(): string { return localize('create branch', '$(plus) Create new branch'); }\n\tget description(): string { return ''; }\n\n\tasync run(repository: Repository): Promise<void> {\n\t\tawait this.cc.branch(repository);\n\t}\n}\n\ninterface CommandOptions {\n\trepository?: boolean;\n\tdiff?: boolean;\n}\n\ninterface Command {\n\tcommandId: string;\n\tkey: string;\n\tmethod: Function;\n\toptions: CommandOptions;\n}\n\nconst Commands: Command[] = [];\n\nfunction command(commandId: string, options: CommandOptions = {}): Function {\n\treturn (target: any, key: string, descriptor: any) => {\n\t\tif (!(typeof descriptor.value === 'function')) {\n\t\t\tthrow new Error('not supported');\n\t\t}\n\n\t\tCommands.push({ commandId, key, method: descriptor.value, options });\n\t};\n}\n\nconst ImageMimetypes = [\n\t'image/png',\n\t'image/gif',\n\t'image/jpeg',\n\t'image/webp',\n\t'image/tiff',\n\t'image/bmp'\n];\n\nexport class CommandCenter {\n\n\tprivate disposables: Disposable[];\n\n\tconstructor(\n\t\tprivate git: Git,\n\t\tprivate model: Model,\n\t\tprivate outputChannel: OutputChannel,\n\t\tprivate telemetryReporter: TelemetryReporter\n\t) {\n\t\tthis.disposables = Commands.map(({ commandId, key, method, options }) => {\n\t\t\tconst command = this.createCommand(commandId, key, method, options);\n\n\t\t\tif (options.diff) {\n\t\t\t\treturn commands.registerDiffInformationCommand(commandId, command);\n\t\t\t} else {\n\t\t\t\treturn commands.registerCommand(commandId, command);\n\t\t\t}\n\t\t});\n\t}\n\n\t@command('git.refresh', { repository: true })\n\tasync refresh(repository: Repository): Promise<void> {\n\t\tawait repository.status();\n\t}\n\n\t@command('git.openResource')\n\tasync openResource(resource: Resource): Promise<void> {\n\t\tawait this._openResource(resource, undefined, true, false);\n\t}\n\n\tprivate async _openResource(resource: Resource, preview?: boolean, preserveFocus?: boolean, preserveSelection?: boolean): Promise<void> {\n\t\tlet stat: Stats | undefined;\n\n\t\ttry {\n\t\t\tstat = await new Promise<Stats>((c, e) => lstat(resource.resourceUri.fsPath, (err, stat) => err ? e(err) : c(stat)));\n\t\t} catch (err) {\n\t\t\t// noop\n\t\t}\n\n\t\tlet left: Uri | undefined;\n\t\tlet right: Uri | undefined;\n\n\t\tif (stat && stat.isDirectory()) {\n\t\t\tconst repository = this.model.getRepositoryForSubmodule(resource.resourceUri);\n\n\t\t\tif (repository) {\n\t\t\t\tright = toGitUri(resource.resourceUri, resource.resourceGroupType === ResourceGroupType.Index ? 'index' : 'wt', { submoduleOf: repository.root });\n\t\t\t}\n\t\t} else {\n\t\t\tleft = await this.getLeftResource(resource);\n\t\t\tright = await this.getRightResource(resource);\n\t\t}\n\n\t\tconst title = this.getTitle(resource);\n\n\t\tif (!right) {\n\t\t\t// TODO\n\t\t\tconsole.error('oh no');\n\t\t\treturn;\n\t\t}\n\n\t\tconst opts: TextDocumentShowOptions = {\n\t\t\tpreserveFocus,\n\t\t\tpreview,\n\t\t\tviewColumn: ViewColumn.Active\n\t\t};\n\n\t\tconst activeTextEditor = window.activeTextEditor;\n\n\t\t// Check if active text editor has same path as other editor. we cannot compare via\n\t\t// URI.toString() here because the schemas can be different. Instead we just go by path.\n\t\tif (preserveSelection && activeTextEditor && activeTextEditor.document.uri.path === right.path) {\n\t\t\topts.selection = activeTextEditor.selection;\n\t\t}\n\n\t\tif (!left) {\n\t\t\tawait commands.executeCommand<void>('vscode.open', right, opts);\n\t\t} else {\n\t\t\tawait commands.executeCommand<void>('vscode.diff', left, right, title, opts);\n\t\t}\n\t}\n\n\tprivate async getURI(uri: Uri, ref: string): Promise<Uri | undefined> {\n\t\tconst repository = this.model.getRepository(uri);\n\n\t\tif (!repository) {\n\t\t\treturn toGitUri(uri, ref);\n\t\t}\n\n\t\ttry {\n\t\t\tlet gitRef = ref;\n\n\t\t\tif (gitRef === '~') {\n\t\t\t\tconst uriString = uri.toString();\n\t\t\t\tconst [indexStatus] = repository.indexGroup.resourceStates.filter(r => r.resourceUri.toString() === uriString);\n\t\t\t\tgitRef = indexStatus ? '' : 'HEAD';\n\t\t\t}\n\n\t\t\tconst { size, object } = await repository.lstree(gitRef, uri.fsPath);\n\t\t\tconst { mimetype } = await repository.detectObjectType(object);\n\n\t\t\tif (mimetype === 'text/plain') {\n\t\t\t\treturn toGitUri(uri, ref);\n\t\t\t}\n\n\t\t\tif (size > 1000000) { // 1 MB\n\t\t\t\treturn Uri.parse(`data:;label:${path.basename(uri.fsPath)};description:${gitRef},`);\n\t\t\t}\n\n\t\t\tif (ImageMimetypes.indexOf(mimetype) > -1) {\n\t\t\t\tconst contents = await repository.buffer(gitRef, uri.fsPath);\n\t\t\t\treturn Uri.parse(`data:${mimetype};label:${path.basename(uri.fsPath)};description:${gitRef};size:${size};base64,${contents.toString('base64')}`);\n\t\t\t}\n\n\t\t\treturn Uri.parse(`data:;label:${path.basename(uri.fsPath)};description:${gitRef},`);\n\n\t\t} catch (err) {\n\t\t\treturn toGitUri(uri, ref);\n\t\t}\n\t}\n\n\tprivate async getLeftResource(resource: Resource): Promise<Uri | undefined> {\n\t\tswitch (resource.type) {\n\t\t\tcase Status.INDEX_MODIFIED:\n\t\t\tcase Status.INDEX_RENAMED:\n\t\t\t\treturn this.getURI(resource.original, 'HEAD');\n\n\t\t\tcase Status.MODIFIED:\n\t\t\t\treturn this.getURI(resource.resourceUri, '~');\n\n\t\t\tcase Status.DELETED_BY_THEM:\n\t\t\t\treturn this.getURI(resource.resourceUri, '');\n\t\t}\n\t}\n\n\tprivate async getRightResource(resource: Resource): Promise<Uri | undefined> {\n\t\tswitch (resource.type) {\n\t\t\tcase Status.INDEX_MODIFIED:\n\t\t\tcase Status.INDEX_ADDED:\n\t\t\tcase Status.INDEX_COPIED:\n\t\t\tcase Status.INDEX_RENAMED:\n\t\t\t\treturn this.getURI(resource.resourceUri, '');\n\n\t\t\tcase Status.INDEX_DELETED:\n\t\t\tcase Status.DELETED_BY_THEM:\n\t\t\tcase Status.DELETED:\n\t\t\t\treturn this.getURI(resource.resourceUri, 'HEAD');\n\n\t\t\tcase Status.MODIFIED:\n\t\t\tcase Status.UNTRACKED:\n\t\t\tcase Status.IGNORED:\n\t\t\t\tconst repository = this.model.getRepository(resource.resourceUri);\n\n\t\t\t\tif (!repository) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst uriString = resource.resourceUri.toString();\n\t\t\t\tconst [indexStatus] = repository.indexGroup.resourceStates.filter(r => r.resourceUri.toString() === uriString);\n\n\t\t\t\tif (indexStatus && indexStatus.renameResourceUri) {\n\t\t\t\t\treturn indexStatus.renameResourceUri;\n\t\t\t\t}\n\n\t\t\t\treturn resource.resourceUri;\n\n\t\t\tcase Status.BOTH_ADDED:\n\t\t\tcase Status.BOTH_MODIFIED:\n\t\t\t\treturn resource.resourceUri;\n\t\t}\n\t}\n\n\tprivate getTitle(resource: Resource): string {\n\t\tconst basename = path.basename(resource.resourceUri.fsPath);\n\n\t\tswitch (resource.type) {\n\t\t\tcase Status.INDEX_MODIFIED:\n\t\t\tcase Status.INDEX_RENAMED:\n\t\t\tcase Status.DELETED_BY_THEM:\n\t\t\t\treturn `${basename} (Index)`;\n\n\t\t\tcase Status.MODIFIED:\n\t\t\tcase Status.BOTH_ADDED:\n\t\t\tcase Status.BOTH_MODIFIED:\n\t\t\t\treturn `${basename} (Working Tree)`;\n\t\t}\n\n\t\treturn '';\n\t}\n\n\tprivate static cloneId = 0;\n\n\t@command('git.clone')\n\tasync clone(url?: string): Promise<void> {\n\t\tif (!url) {\n\t\t\turl = await window.showInputBox({\n\t\t\t\tprompt: localize('repourl', \"Repository URL\"),\n\t\t\t\tignoreFocusOut: true\n\t\t\t});\n\t\t}\n\n\t\tif (!url) {\n\t\t\t/* __GDPR__\n\t\t\t\t\"clone\" : {\n\t\t\t\t\t\"outcome\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n\t\t\t\t}\n\t\t\t*/\n\t\t\tthis.telemetryReporter.sendTelemetryEvent('clone', { outcome: 'no_URL' });\n\t\t\treturn;\n\t\t}\n\n\t\tconst config = workspace.getConfiguration('git');\n\t\tlet value = config.get<string>('defaultCloneDirectory') || os.homedir();\n\n\t\tconst parentPath = await window.showInputBox({\n\t\t\tprompt: localize('parent', \"Parent Directory\"),\n\t\t\tvalue,\n\t\t\tignoreFocusOut: true\n\t\t});\n\n\t\tif (!parentPath) {\n\t\t\t/* __GDPR__\n\t\t\t\t\"clone\" : {\n\t\t\t\t\t\"outcome\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n\t\t\t\t}\n\t\t\t*/\n\t\t\tthis.telemetryReporter.sendTelemetryEvent('clone', { outcome: 'no_directory' });\n\t\t\treturn;\n\t\t}\n\n\t\tconst tokenSource = new CancellationTokenSource();\n\t\tconst cancelCommandId = `cancelClone${CommandCenter.cloneId++}`;\n\t\tconst commandDisposable = commands.registerCommand(cancelCommandId, () => tokenSource.cancel());\n\n\t\tconst statusBarItem = window.createStatusBarItem(StatusBarAlignment.Left);\n\t\tstatusBarItem.text = localize('cancel', \"$(sync~spin) Cloning repository... Click to cancel\");\n\t\tstatusBarItem.tooltip = localize('cancel tooltip', \"Cancel clone\");\n\t\tstatusBarItem.command = cancelCommandId;\n\t\tstatusBarItem.show();\n\n\t\tconst clonePromise = this.git.clone(url, parentPath.replace(/^~/, os.homedir()), tokenSource.token);\n\n\t\ttry {\n\t\t\twindow.withProgress({ location: ProgressLocation.SourceControl, title: localize('cloning', \"Cloning git repository...\") }, () => clonePromise);\n\n\t\t\tconst repositoryPath = await clonePromise;\n\n\t\t\tconst open = localize('openrepo', \"Open Repository\");\n\t\t\tconst result = await window.showInformationMessage(localize('proposeopen', \"Would you like to open the cloned repository?\"), open);\n\n\t\t\tconst openFolder = result === open;\n\t\t\t/* __GDPR__\n\t\t\t\t\"clone\" : {\n\t\t\t\t\t\"outcome\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n\t\t\t\t\t\"openFolder\": { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true }\n\t\t\t\t}\n\t\t\t*/\n\t\t\tthis.telemetryReporter.sendTelemetryEvent('clone', { outcome: 'success' }, { openFolder: openFolder ? 1 : 0 });\n\t\t\tif (openFolder) {\n\t\t\t\tcommands.executeCommand('vscode.openFolder', Uri.file(repositoryPath));\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tif (/already exists and is not an empty directory/.test(err && err.stderr || '')) {\n\t\t\t\t/* __GDPR__\n\t\t\t\t\t\"clone\" : {\n\t\t\t\t\t\t\"outcome\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n\t\t\t\t\t}\n\t\t\t\t*/\n\t\t\t\tthis.telemetryReporter.sendTelemetryEvent('clone', { outcome: 'directory_not_empty' });\n\t\t\t} else if (/Cancelled/i.test(err && (err.message || err.stderr || ''))) {\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\t/* __GDPR__\n\t\t\t\t\t\"clone\" : {\n\t\t\t\t\t\t\"outcome\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n\t\t\t\t\t}\n\t\t\t\t*/\n\t\t\t\tthis.telemetryReporter.sendTelemetryEvent('clone', { outcome: 'error' });\n\t\t\t}\n\n\t\t\tthrow err;\n\t\t} finally {\n\t\t\tcommandDisposable.dispose();\n\t\t\tstatusBarItem.dispose();\n\t\t}\n\t}\n\n\t@command('git.init')\n\tasync init(): Promise<void> {\n\t\tlet path: string | undefined;\n\n\t\tif (workspace.workspaceFolders && workspace.workspaceFolders.length > 1) {\n\t\t\tconst placeHolder = localize('init', \"Pick workspace folder to initialize git repo in\");\n\t\t\tconst items = workspace.workspaceFolders.map(folder => ({ label: folder.name, description: folder.uri.fsPath, folder }));\n\t\t\tconst item = await window.showQuickPick(items, { placeHolder, ignoreFocusOut: true });\n\n\t\t\tif (!item) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tpath = item.folder.uri.fsPath;\n\t\t}\n\n\t\tif (!path) {\n\t\t\tconst homeUri = Uri.file(os.homedir());\n\t\t\tconst defaultUri = workspace.workspaceFolders && workspace.workspaceFolders.length > 0\n\t\t\t\t? Uri.file(workspace.workspaceFolders[0].uri.fsPath)\n\t\t\t\t: homeUri;\n\n\t\t\tconst result = await window.showOpenDialog({\n\t\t\t\tcanSelectFiles: false,\n\t\t\t\tcanSelectFolders: true,\n\t\t\t\tcanSelectMany: false,\n\t\t\t\tdefaultUri,\n\t\t\t\topenLabel: localize('init repo', \"Initialize Repository\")\n\t\t\t});\n\n\t\t\tif (!result || result.length === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst uri = result[0];\n\n\t\t\tif (homeUri.toString().startsWith(uri.toString())) {\n\t\t\t\tconst yes = localize('create repo', \"Initialize Repository\");\n\t\t\t\tconst answer = await window.showWarningMessage(localize('are you sure', \"This will create a Git repository in '{0}'. Are you sure you want to continue?\", uri.fsPath), yes);\n\n\t\t\t\tif (answer !== yes) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpath = uri.fsPath;\n\t\t}\n\n\t\tawait this.git.init(path);\n\t\tawait this.model.tryOpenRepository(path);\n\t}\n\n\t@command('git.close', { repository: true })\n\tasync close(repository: Repository): Promise<void> {\n\t\tthis.model.close(repository);\n\t}\n\n\t@command('git.openFile')\n\tasync openFile(arg?: Resource | Uri, ...resourceStates: SourceControlResourceState[]): Promise<void> {\n\t\tconst preserveFocus = arg instanceof Resource;\n\n\t\tlet uris: Uri[] | undefined;\n\n\t\tif (arg instanceof Uri) {\n\t\t\tif (arg.scheme === 'git') {\n\t\t\t\turis = [Uri.file(fromGitUri(arg).path)];\n\t\t\t} else if (arg.scheme === 'file') {\n\t\t\t\turis = [arg];\n\t\t\t}\n\t\t} else {\n\t\t\tlet resource = arg;\n\n\t\t\tif (!(resource instanceof Resource)) {\n\t\t\t\t// can happen when called from a keybinding\n\t\t\t\tresource = this.getSCMResource();\n\t\t\t}\n\n\t\t\tif (resource) {\n\t\t\t\tconst resources = ([resource, ...resourceStates] as Resource[])\n\t\t\t\t\t.filter(r => r.type !== Status.DELETED && r.type !== Status.INDEX_DELETED);\n\n\t\t\t\turis = resources.map(r => r.resourceUri);\n\t\t\t}\n\t\t}\n\n\t\tif (!uris) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst preview = uris.length === 1 ? true : false;\n\t\tconst activeTextEditor = window.activeTextEditor;\n\t\tfor (const uri of uris) {\n\t\t\tconst opts: TextDocumentShowOptions = {\n\t\t\t\tpreserveFocus,\n\t\t\t\tpreview,\n\t\t\t\tviewColumn: ViewColumn.Active\n\t\t\t};\n\n\t\t\t// Check if active text editor has same path as other editor. we cannot compare via\n\t\t\t// URI.toString() here because the schemas can be different. Instead we just go by path.\n\t\t\tif (activeTextEditor && activeTextEditor.document.uri.path === uri.path) {\n\t\t\t\topts.selection = activeTextEditor.selection;\n\t\t\t}\n\n\t\t\tawait commands.executeCommand<void>('vscode.open', uri, opts);\n\t\t}\n\t}\n\n\t@command('git.openFile2')\n\tasync openFile2(arg?: Resource | Uri, ...resourceStates: SourceControlResourceState[]): Promise<void> {\n\t\tthis.openFile(arg, ...resourceStates);\n\t}\n\n\t@command('git.openHEADFile')\n\tasync openHEADFile(arg?: Resource | Uri): Promise<void> {\n\t\tlet resource: Resource | undefined = undefined;\n\n\t\tif (arg instanceof Resource) {\n\t\t\tresource = arg;\n\t\t} else if (arg instanceof Uri) {\n\t\t\tresource = this.getSCMResource(arg);\n\t\t} else {\n\t\t\tresource = this.getSCMResource();\n\t\t}\n\n\t\tif (!resource) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst HEAD = await this.getLeftResource(resource);\n\n\t\tif (!HEAD) {\n\t\t\twindow.showWarningMessage(localize('HEAD not available', \"HEAD version of '{0}' is not available.\", path.basename(resource.resourceUri.fsPath)));\n\t\t\treturn;\n\t\t}\n\n\t\treturn await commands.executeCommand<void>('vscode.open', HEAD);\n\t}\n\n\t@command('git.openChange')\n\tasync openChange(arg?: Resource | Uri, ...resourceStates: SourceControlResourceState[]): Promise<void> {\n\t\tconst preserveFocus = arg instanceof Resource;\n\t\tconst preserveSelection = arg instanceof Uri || !arg;\n\t\tlet resources: Resource[] | undefined = undefined;\n\n\t\tif (arg instanceof Uri) {\n\t\t\tconst resource = this.getSCMResource(arg);\n\t\t\tif (resource !== undefined) {\n\t\t\t\tresources = [resource];\n\t\t\t}\n\t\t} else {\n\t\t\tlet resource: Resource | undefined = undefined;\n\n\t\t\tif (arg instanceof Resource) {\n\t\t\t\tresource = arg;\n\t\t\t} else {\n\t\t\t\tresource = this.getSCMResource();\n\t\t\t}\n\n\t\t\tif (resource) {\n\t\t\t\tresources = [...resourceStates as Resource[], resource];\n\t\t\t}\n\t\t}\n\n\t\tif (!resources) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst preview = resources.length === 1 ? undefined : false;\n\t\tfor (const resource of resources) {\n\t\t\tawait this._openResource(resource, preview, preserveFocus, preserveSelection);\n\t\t}\n\t}\n\n\t@command('git.stage')\n\tasync stage(...resourceStates: SourceControlResourceState[]): Promise<void> {\n\t\tif (resourceStates.length === 0 || (resourceStates[0] && !(resourceStates[0].resourceUri instanceof Uri))) {\n\t\t\tconst resource = this.getSCMResource();\n\n\t\t\tif (!resource) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tresourceStates = [resource];\n\t\t}\n\n\t\tconst selection = resourceStates.filter(s => s instanceof Resource) as Resource[];\n\t\tconst merge = selection.filter(s => s.resourceGroupType === ResourceGroupType.Merge);\n\t\tconst bothModified = merge.filter(s => s.type === Status.BOTH_MODIFIED);\n\t\tconst promises = bothModified.map(s => grep(s.resourceUri.fsPath, /^<{7}|^={7}|^>{7}/));\n\t\tconst unresolvedBothModified = await Promise.all<boolean>(promises);\n\t\tconst resolvedConflicts = bothModified.filter((s, i) => !unresolvedBothModified[i]);\n\t\tconst unresolvedConflicts = [\n\t\t\t...merge.filter(s => s.type !== Status.BOTH_MODIFIED),\n\t\t\t...bothModified.filter((s, i) => unresolvedBothModified[i])\n\t\t];\n\n\t\tif (unresolvedConflicts.length > 0) {\n\t\t\tconst message = unresolvedConflicts.length > 1\n\t\t\t\t? localize('confirm stage files with merge conflicts', \"Are you sure you want to stage {0} files with merge conflicts?\", unresolvedConflicts.length)\n\t\t\t\t: localize('confirm stage file with merge conflicts', \"Are you sure you want to stage {0} with merge conflicts?\", path.basename(unresolvedConflicts[0].resourceUri.fsPath));\n\n\t\t\tconst yes = localize('yes', \"Yes\");\n\t\t\tconst pick = await window.showWarningMessage(message, { modal: true }, yes);\n\n\t\t\tif (pick !== yes) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tconst workingTree = selection.filter(s => s.resourceGroupType === ResourceGroupType.WorkingTree);\n\t\tconst scmResources = [...workingTree, ...resolvedConflicts, ...unresolvedConflicts];\n\n\t\tif (!scmResources.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst resources = scmResources.map(r => r.resourceUri);\n\t\tawait this.runByRepository(resources, async (repository, resources) => repository.add(resources));\n\t}\n\n\t@command('git.stageAll', { repository: true })\n\tasync stageAll(repository: Repository): Promise<void> {\n\t\tconst resources = repository.mergeGroup.resourceStates.filter(s => s instanceof Resource) as Resource[];\n\t\tconst mergeConflicts = resources.filter(s => s.resourceGroupType === ResourceGroupType.Merge);\n\n\t\tif (mergeConflicts.length > 0) {\n\t\t\tconst message = mergeConflicts.length > 1\n\t\t\t\t? localize('confirm stage files with merge conflicts', \"Are you sure you want to stage {0} files with merge conflicts?\", mergeConflicts.length)\n\t\t\t\t: localize('confirm stage file with merge conflicts', \"Are you sure you want to stage {0} with merge conflicts?\", path.basename(mergeConflicts[0].resourceUri.fsPath));\n\n\t\t\tconst yes = localize('yes', \"Yes\");\n\t\t\tconst pick = await window.showWarningMessage(message, { modal: true }, yes);\n\n\t\t\tif (pick !== yes) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tawait repository.add([]);\n\t}\n\n\t@command('git.stageChange')\n\tasync stageChange(uri: Uri, changes: LineChange[], index: number): Promise<void> {\n\t\tconst textEditor = window.visibleTextEditors.filter(e => e.document.uri.toString() === uri.toString())[0];\n\n\t\tif (!textEditor) {\n\t\t\treturn;\n\t\t}\n\n\t\tawait this._stageChanges(textEditor, [changes[index]]);\n\t}\n\n\t@command('git.stageSelectedRanges', { diff: true })\n\tasync stageSelectedChanges(changes: LineChange[]): Promise<void> {\n\t\tconst textEditor = window.activeTextEditor;\n\n\t\tif (!textEditor) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst modifiedDocument = textEditor.document;\n\t\tconst selectedLines = toLineRanges(textEditor.selections, modifiedDocument);\n\t\tconst selectedChanges = changes\n\t\t\t.map(diff => selectedLines.reduce<LineChange | null>((result, range) => result || intersectDiffWithRange(modifiedDocument, diff, range), null))\n\t\t\t.filter(d => !!d) as LineChange[];\n\n\t\tif (!selectedChanges.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tawait this._stageChanges(textEditor, selectedChanges);\n\t}\n\n\tprivate async _stageChanges(textEditor: TextEditor, changes: LineChange[]): Promise<void> {\n\t\tconst modifiedDocument = textEditor.document;\n\t\tconst modifiedUri = modifiedDocument.uri;\n\n\t\tif (modifiedUri.scheme !== 'file') {\n\t\t\treturn;\n\t\t}\n\n\t\tconst originalUri = toGitUri(modifiedUri, '~');\n\t\tconst originalDocument = await workspace.openTextDocument(originalUri);\n\t\tconst result = applyLineChanges(originalDocument, modifiedDocument, changes);\n\n\t\tawait this.runByRepository(modifiedUri, async (repository, resource) => await repository.stage(resource, result));\n\t}\n\n\t@command('git.revertChange')\n\tasync revertChange(uri: Uri, changes: LineChange[], index: number): Promise<void> {\n\t\tconst textEditor = window.visibleTextEditors.filter(e => e.document.uri.toString() === uri.toString())[0];\n\n\t\tif (!textEditor) {\n\t\t\treturn;\n\t\t}\n\n\t\tawait this._revertChanges(textEditor, [...changes.slice(0, index), ...changes.slice(index + 1)]);\n\t}\n\n\t@command('git.revertSelectedRanges', { diff: true })\n\tasync revertSelectedRanges(changes: LineChange[]): Promise<void> {\n\t\tconst textEditor = window.activeTextEditor;\n\n\t\tif (!textEditor) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst modifiedDocument = textEditor.document;\n\t\tconst selections = textEditor.selections;\n\t\tconst selectedChanges = changes.filter(change => {\n\t\t\tconst modifiedRange = getModifiedRange(modifiedDocument, change);\n\t\t\treturn selections.every(selection => !selection.intersection(modifiedRange));\n\t\t});\n\n\t\tif (selectedChanges.length === changes.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tawait this._revertChanges(textEditor, selectedChanges);\n\t}\n\n\tprivate async _revertChanges(textEditor: TextEditor, changes: LineChange[]): Promise<void> {\n\t\tconst modifiedDocument = textEditor.document;\n\t\tconst modifiedUri = modifiedDocument.uri;\n\n\t\tif (modifiedUri.scheme !== 'file') {\n\t\t\treturn;\n\t\t}\n\n\t\tconst originalUri = toGitUri(modifiedUri, '~');\n\t\tconst originalDocument = await workspace.openTextDocument(originalUri);\n\t\tconst basename = path.basename(modifiedUri.fsPath);\n\t\tconst message = localize('confirm revert', \"Are you sure you want to revert the selected changes in {0}?\", basename);\n\t\tconst yes = localize('revert', \"Revert Changes\");\n\t\tconst pick = await window.showWarningMessage(message, { modal: true }, yes);\n\n\t\tif (pick !== yes) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst result = applyLineChanges(originalDocument, modifiedDocument, changes);\n\t\tconst edit = new WorkspaceEdit();\n\t\tedit.replace(modifiedUri, new Range(new Position(0, 0), modifiedDocument.lineAt(modifiedDocument.lineCount - 1).range.end), result);\n\t\tworkspace.applyEdit(edit);\n\t\tawait modifiedDocument.save();\n\t}\n\n\t@command('git.unstage')\n\tasync unstage(...resourceStates: SourceControlResourceState[]): Promise<void> {\n\t\tif (resourceStates.length === 0 || (resourceStates[0] && !(resourceStates[0].resourceUri instanceof Uri))) {\n\t\t\tconst resource = this.getSCMResource();\n\n\t\t\tif (!resource) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tresourceStates = [resource];\n\t\t}\n\n\t\tconst scmResources = resourceStates\n\t\t\t.filter(s => s instanceof Resource && s.resourceGroupType === ResourceGroupType.Index) as Resource[];\n\n\t\tif (!scmResources.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst resources = scmResources.map(r => r.resourceUri);\n\t\tawait this.runByRepository(resources, async (repository, resources) => repository.revert(resources));\n\t}\n\n\t@command('git.unstageAll', { repository: true })\n\tasync unstageAll(repository: Repository): Promise<void> {\n\t\tawait repository.revert([]);\n\t}\n\n\t@command('git.unstageSelectedRanges', { diff: true })\n\tasync unstageSelectedRanges(diffs: LineChange[]): Promise<void> {\n\t\tconst textEditor = window.activeTextEditor;\n\n\t\tif (!textEditor) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst modifiedDocument = textEditor.document;\n\t\tconst modifiedUri = modifiedDocument.uri;\n\n\t\tif (modifiedUri.scheme !== 'git') {\n\t\t\treturn;\n\t\t}\n\n\t\tconst { ref } = fromGitUri(modifiedUri);\n\n\t\tif (ref !== '') {\n\t\t\treturn;\n\t\t}\n\n\t\tconst originalUri = toGitUri(modifiedUri, 'HEAD');\n\t\tconst originalDocument = await workspace.openTextDocument(originalUri);\n\t\tconst selectedLines = toLineRanges(textEditor.selections, modifiedDocument);\n\t\tconst selectedDiffs = diffs\n\t\t\t.map(diff => selectedLines.reduce<LineChange | null>((result, range) => result || intersectDiffWithRange(modifiedDocument, diff, range), null))\n\t\t\t.filter(d => !!d) as LineChange[];\n\n\t\tif (!selectedDiffs.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst invertedDiffs = selectedDiffs.map(invertLineChange);\n\t\tconst result = applyLineChanges(modifiedDocument, originalDocument, invertedDiffs);\n\n\t\tawait this.runByRepository(modifiedUri, async (repository, resource) => await repository.stage(resource, result));\n\t}\n\n\t@command('git.clean')\n\tasync clean(...resourceStates: SourceControlResourceState[]): Promise<void> {\n\t\tif (resourceStates.length === 0 || (resourceStates[0] && !(resourceStates[0].resourceUri instanceof Uri))) {\n\t\t\tconst resource = this.getSCMResource();\n\n\t\t\tif (!resource) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tresourceStates = [resource];\n\t\t}\n\n\t\tconst scmResources = resourceStates\n\t\t\t.filter(s => s instanceof Resource && s.resourceGroupType === ResourceGroupType.WorkingTree) as Resource[];\n\n\t\tif (!scmResources.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst untrackedCount = scmResources.reduce((s, r) => s + (r.type === Status.UNTRACKED ? 1 : 0), 0);\n\t\tlet message: string;\n\t\tlet yes = localize('discard', \"Discard Changes\");\n\n\t\tif (scmResources.length === 1) {\n\t\t\tif (untrackedCount > 0) {\n\t\t\t\tmessage = localize('confirm delete', \"Are you sure you want to DELETE {0}?\", path.basename(scmResources[0].resourceUri.fsPath));\n\t\t\t\tyes = localize('delete file', \"Delete file\");\n\t\t\t} else {\n\t\t\t\tmessage = localize('confirm discard', \"Are you sure you want to discard changes in {0}?\", path.basename(scmResources[0].resourceUri.fsPath));\n\t\t\t}\n\t\t} else {\n\t\t\tmessage = localize('confirm discard multiple', \"Are you sure you want to discard changes in {0} files?\", scmResources.length);\n\n\t\t\tif (untrackedCount > 0) {\n\t\t\t\tmessage = `${message}\\n\\n${localize('warn untracked', \"This will DELETE {0} untracked files!\", untrackedCount)}`;\n\t\t\t}\n\t\t}\n\n\t\tconst pick = await window.showWarningMessage(message, { modal: true }, yes);\n\n\t\tif (pick !== yes) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst resources = scmResources.map(r => r.resourceUri);\n\t\tawait this.runByRepository(resources, async (repository, resources) => repository.clean(resources));\n\t}\n\n\t@command('git.cleanAll', { repository: true })\n\tasync cleanAll(repository: Repository): Promise<void> {\n\t\tlet resources = repository.workingTreeGroup.resourceStates;\n\n\t\tif (resources.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst trackedResources = resources.filter(r => r.type !== Status.UNTRACKED && r.type !== Status.IGNORED);\n\t\tconst untrackedResources = resources.filter(r => r.type === Status.UNTRACKED || r.type === Status.IGNORED);\n\n\t\tif (untrackedResources.length === 0) {\n\t\t\tconst message = resources.length === 1\n\t\t\t\t? localize('confirm discard all single', \"Are you sure you want to discard changes in {0}?\", path.basename(resources[0].resourceUri.fsPath))\n\t\t\t\t: localize('confirm discard all', \"Are you sure you want to discard ALL changes in {0} files?\\nThis is IRREVERSIBLE!\\nYour current working set will be FOREVER LOST.\", resources.length);\n\t\t\tconst yes = resources.length === 1\n\t\t\t\t? localize('discardAll multiple', \"Discard 1 File\")\n\t\t\t\t: localize('discardAll', \"Discard All {0} Files\", resources.length);\n\t\t\tconst pick = await window.showWarningMessage(message, { modal: true }, yes);\n\n\t\t\tif (pick !== yes) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tawait repository.clean(resources.map(r => r.resourceUri));\n\t\t\treturn;\n\t\t} else if (resources.length === 1) {\n\t\t\tconst message = localize('confirm delete', \"Are you sure you want to DELETE {0}?\", path.basename(resources[0].resourceUri.fsPath));\n\t\t\tconst yes = localize('delete file', \"Delete file\");\n\t\t\tconst pick = await window.showWarningMessage(message, { modal: true }, yes);\n\n\t\t\tif (pick !== yes) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tawait repository.clean(resources.map(r => r.resourceUri));\n\t\t} else if (trackedResources.length === 0) {\n\t\t\tconst message = localize('confirm delete multiple', \"Are you sure you want to DELETE {0} files?\", resources.length);\n\t\t\tconst yes = localize('delete files', \"Delete Files\");\n\t\t\tconst pick = await window.showWarningMessage(message, { modal: true }, yes);\n\n\t\t\tif (pick !== yes) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tawait repository.clean(resources.map(r => r.resourceUri));\n\n\t\t} else { // resources.length > 1 && untrackedResources.length > 0 && trackedResources.length > 0\n\t\t\tconst untrackedMessage = untrackedResources.length === 1\n\t\t\t\t? localize('there are untracked files single', \"The following untracked file will be DELETED FROM DISK if discarded: {0}.\", path.basename(untrackedResources[0].resourceUri.fsPath))\n\t\t\t\t: localize('there are untracked files', \"There are {0} untracked files which will be DELETED FROM DISK if discarded.\", untrackedResources.length);\n\n\t\t\tconst message = localize('confirm discard all 2', \"{0}\\n\\nThis is IRREVERSIBLE, your current working set will be FOREVER LOST.\", untrackedMessage, resources.length);\n\n\t\t\tconst yesTracked = trackedResources.length === 1\n\t\t\t\t? localize('yes discard tracked', \"Discard 1 Tracked File\", trackedResources.length)\n\t\t\t\t: localize('yes discard tracked multiple', \"Discard {0} Tracked Files\", trackedResources.length);\n\n\t\t\tconst yesAll = localize('discardAll', \"Discard All {0} Files\", resources.length);\n\t\t\tconst pick = await window.showWarningMessage(message, { modal: true }, yesTracked, yesAll);\n\n\t\t\tif (pick === yesTracked) {\n\t\t\t\tresources = trackedResources;\n\t\t\t} else if (pick !== yesAll) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tawait repository.clean(resources.map(r => r.resourceUri));\n\t\t}\n\t}\n\n\tprivate async smartCommit(\n\t\trepository: Repository,\n\t\tgetCommitMessage: () => Promise<string | undefined>,\n\t\topts?: CommitOptions\n\t): Promise<boolean> {\n\t\tconst config = workspace.getConfiguration('git');\n\t\tconst promptToSaveFilesBeforeCommit = config.get<boolean>('promptToSaveFilesBeforeCommit') === true;\n\n\t\tif (promptToSaveFilesBeforeCommit) {\n\t\t\tconst unsavedTextDocuments = workspace.textDocuments\n\t\t\t\t.filter(d => !d.isUntitled && d.isDirty && isDescendant(repository.root, d.uri.fsPath));\n\n\t\t\tif (unsavedTextDocuments.length > 0) {\n\t\t\t\tconst message = unsavedTextDocuments.length === 1\n\t\t\t\t\t? localize('unsaved files single', \"The following file is unsaved: {0}.\\n\\nWould you like to save it before comitting?\", path.basename(unsavedTextDocuments[0].uri.fsPath))\n\t\t\t\t\t: localize('unsaved files', \"There are {0} unsaved files.\\n\\nWould you like to save them before comitting?\", unsavedTextDocuments.length);\n\t\t\t\tconst saveAndCommit = localize('save and commit', \"Save All & Commit\");\n\t\t\t\tconst commit = localize('commit', \"Commit Anyway\");\n\t\t\t\tconst pick = await window.showWarningMessage(message, { modal: true }, saveAndCommit, commit);\n\n\t\t\t\tif (pick === saveAndCommit) {\n\t\t\t\t\tawait Promise.all(unsavedTextDocuments.map(d => d.save()));\n\t\t\t\t\tawait repository.status();\n\t\t\t\t} else if (pick !== commit) {\n\t\t\t\t\treturn false; // do not commit on cancel\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst enableSmartCommit = config.get<boolean>('enableSmartCommit') === true;\n\t\tconst enableCommitSigning = config.get<boolean>('enableCommitSigning') === true;\n\t\tconst noStagedChanges = repository.indexGroup.resourceStates.length === 0;\n\t\tconst noUnstagedChanges = repository.workingTreeGroup.resourceStates.length === 0;\n\n\t\t// no changes, and the user has not configured to commit all in this case\n\t\tif (!noUnstagedChanges && noStagedChanges && !enableSmartCommit) {\n\n\t\t\t// prompt the user if we want to commit all or not\n\t\t\tconst message = localize('no staged changes', \"There are no staged changes to commit.\\n\\nWould you like to automatically stage all your changes and commit them directly?\");\n\t\t\tconst yes = localize('yes', \"Yes\");\n\t\t\tconst always = localize('always', \"Always\");\n\t\t\tconst pick = await window.showWarningMessage(message, { modal: true }, yes, always);\n\n\t\t\tif (pick === always) {\n\t\t\t\tconfig.update('enableSmartCommit', true, true);\n\t\t\t} else if (pick !== yes) {\n\t\t\t\treturn false; // do not commit on cancel\n\t\t\t}\n\t\t}\n\n\t\tif (!opts) {\n\t\t\topts = { all: noStagedChanges };\n\t\t} else if (!opts.all && noStagedChanges) {\n\t\t\topts = { ...opts, all: true };\n\t\t}\n\n\t\t// enable signing of commits if configurated\n\t\topts.signCommit = enableCommitSigning;\n\n\t\tif (\n\t\t\t// no changes\n\t\t\t(noStagedChanges && noUnstagedChanges)\n\t\t\t// or no staged changes and not `all`\n\t\t\t|| (!opts.all && noStagedChanges)\n\t\t) {\n\t\t\twindow.showInformationMessage(localize('no changes', \"There are no changes to commit.\"));\n\t\t\treturn false;\n\t\t}\n\n\t\tconst message = await getCommitMessage();\n\n\t\tif (!message) {\n\t\t\treturn false;\n\t\t}\n\n\t\tawait repository.commit(message, opts);\n\n\t\treturn true;\n\t}\n\n\tprivate async commitWithAnyInput(repository: Repository, opts?: CommitOptions): Promise<void> {\n\t\tconst message = repository.inputBox.value;\n\t\tconst getCommitMessage = async () => {\n\t\t\tif (message) {\n\t\t\t\treturn message;\n\t\t\t}\n\n\t\t\tlet value: string | undefined = undefined;\n\n\t\t\tif (opts && opts.amend && repository.HEAD && repository.HEAD.commit) {\n\t\t\t\tvalue = (await repository.getCommit(repository.HEAD.commit)).message;\n\t\t\t}\n\n\t\t\treturn await window.showInputBox({\n\t\t\t\tvalue,\n\t\t\t\tplaceHolder: localize('commit message', \"Commit message\"),\n\t\t\t\tprompt: localize('provide commit message', \"Please provide a commit message\"),\n\t\t\t\tignoreFocusOut: true\n\t\t\t});\n\t\t};\n\n\t\tconst didCommit = await this.smartCommit(repository, getCommitMessage, opts);\n\n\t\tif (message && didCommit) {\n\t\t\trepository.inputBox.value = await repository.getCommitTemplate();\n\t\t}\n\t}\n\n\t@command('git.commit', { repository: true })\n\tasync commit(repository: Repository): Promise<void> {\n\t\tawait this.commitWithAnyInput(repository);\n\t}\n\n\t@command('git.commitWithInput', { repository: true })\n\tasync commitWithInput(repository: Repository): Promise<void> {\n\t\tif (!repository.inputBox.value) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst didCommit = await this.smartCommit(repository, async () => repository.inputBox.value);\n\n\t\tif (didCommit) {\n\t\t\trepository.inputBox.value = await repository.getCommitTemplate();\n\t\t}\n\t}\n\n\t@command('git.commitStaged', { repository: true })\n\tasync commitStaged(repository: Repository): Promise<void> {\n\t\tawait this.commitWithAnyInput(repository, { all: false });\n\t}\n\n\t@command('git.commitStagedSigned', { repository: true })\n\tasync commitStagedSigned(repository: Repository): Promise<void> {\n\t\tawait this.commitWithAnyInput(repository, { all: false, signoff: true });\n\t}\n\n\t@command('git.commitStagedAmend', { repository: true })\n\tasync commitStagedAmend(repository: Repository): Promise<void> {\n\t\tawait this.commitWithAnyInput(repository, { all: false, amend: true });\n\t}\n\n\t@command('git.commitAll', { repository: true })\n\tasync commitAll(repository: Repository): Promise<void> {\n\t\tawait this.commitWithAnyInput(repository, { all: true });\n\t}\n\n\t@command('git.commitAllSigned', { repository: true })\n\tasync commitAllSigned(repository: Repository): Promise<void> {\n\t\tawait this.commitWithAnyInput(repository, { all: true, signoff: true });\n\t}\n\n\t@command('git.commitAllAmend', { repository: true })\n\tasync commitAllAmend(repository: Repository): Promise<void> {\n\t\tawait this.commitWithAnyInput(repository, { all: true, amend: true });\n\t}\n\n\t@command('git.undoCommit', { repository: true })\n\tasync undoCommit(repository: Repository): Promise<void> {\n\t\tconst HEAD = repository.HEAD;\n\n\t\tif (!HEAD || !HEAD.commit) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst commit = await repository.getCommit('HEAD');\n\t\tawait repository.reset('HEAD~');\n\t\trepository.inputBox.value = commit.message;\n\t}\n\n\t@command('git.checkout', { repository: true })\n\tasync checkout(repository: Repository, treeish: string): Promise<void> {\n\t\tif (typeof treeish === 'string') {\n\t\t\treturn await repository.checkout(treeish);\n\t\t}\n\n\t\tconst config = workspace.getConfiguration('git');\n\t\tconst checkoutType = config.get<string>('checkoutType') || 'all';\n\t\tconst includeTags = checkoutType === 'all' || checkoutType === 'tags';\n\t\tconst includeRemotes = checkoutType === 'all' || checkoutType === 'remote';\n\n\t\tconst createBranch = new CreateBranchItem(this);\n\n\t\tconst heads = repository.refs.filter(ref => ref.type === RefType.Head)\n\t\t\t.map(ref => new CheckoutItem(ref));\n\n\t\tconst tags = (includeTags ? repository.refs.filter(ref => ref.type === RefType.Tag) : [])\n\t\t\t.map(ref => new CheckoutTagItem(ref));\n\n\t\tconst remoteHeads = (includeRemotes ? repository.refs.filter(ref => ref.type === RefType.RemoteHead) : [])\n\t\t\t.map(ref => new CheckoutRemoteHeadItem(ref));\n\n\t\tconst picks = [createBranch, ...heads, ...tags, ...remoteHeads];\n\t\tconst placeHolder = localize('select a ref to checkout', 'Select a ref to checkout');\n\t\tconst choice = await window.showQuickPick(picks, { placeHolder });\n\n\t\tif (!choice) {\n\t\t\treturn;\n\t\t}\n\n\t\tawait choice.run(repository);\n\t}\n\n\t@command('git.branch', { repository: true })\n\tasync branch(repository: Repository): Promise<void> {\n\t\tconst result = await window.showInputBox({\n\t\t\tplaceHolder: localize('branch name', \"Branch name\"),\n\t\t\tprompt: localize('provide branch name', \"Please provide a branch name\"),\n\t\t\tignoreFocusOut: true\n\t\t});\n\n\t\tif (!result) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst name = result.replace(/^\\.|\\/\\.|\\.\\.|~|\\^|:|\\/$|\\.lock$|\\.lock\\/|\\\\|\\*|\\s|^\\s*$|\\.$/g, '-');\n\t\tawait repository.branch(name);\n\t}\n\n\t@command('git.deleteBranch', { repository: true })\n\tasync deleteBranch(repository: Repository, name: string, force?: boolean): Promise<void> {\n\t\tlet run: (force?: boolean) => Promise<void>;\n\t\tif (typeof name === 'string') {\n\t\t\trun = force => repository.deleteBranch(name, force);\n\t\t} else {\n\t\t\tconst currentHead = repository.HEAD && repository.HEAD.name;\n\t\t\tconst heads = repository.refs.filter(ref => ref.type === RefType.Head && ref.name !== currentHead)\n\t\t\t\t.map(ref => new BranchDeleteItem(ref));\n\n\t\t\tconst placeHolder = localize('select branch to delete', 'Select a branch to delete');\n\t\t\tconst choice = await window.showQuickPick<BranchDeleteItem>(heads, { placeHolder });\n\n\t\t\tif (!choice || !choice.branchName) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tname = choice.branchName;\n\t\t\trun = force => choice.run(repository, force);\n\t\t}\n\n\t\ttry {\n\t\t\tawait run(force);\n\t\t} catch (err) {\n\t\t\tif (err.gitErrorCode !== GitErrorCodes.BranchNotFullyMerged) {\n\t\t\t\tthrow err;\n\t\t\t}\n\n\t\t\tconst message = localize('confirm force delete branch', \"The branch '{0}' is not fully merged. Delete anyway?\", name);\n\t\t\tconst yes = localize('delete branch', \"Delete Branch\");\n\t\t\tconst pick = await window.showWarningMessage(message, yes);\n\n\t\t\tif (pick === yes) {\n\t\t\t\tawait run(true);\n\t\t\t}\n\t\t}\n\t}\n\n\t@command('git.renameBranch', { repository: true })\n\tasync renameBranch(repository: Repository): Promise<void> {\n\t\tconst placeHolder = localize('provide branch name', \"Please provide a branch name\");\n\t\tconst name = await window.showInputBox({ placeHolder });\n\n\t\tif (!name || name.trim().length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tawait repository.renameBranch(name);\n\t\t} catch (err) {\n\t\t\tswitch (err.gitErrorCode) {\n\t\t\t\tcase GitErrorCodes.InvalidBranchName:\n\t\t\t\t\twindow.showErrorMessage(localize('invalid branch name', 'Invalid branch name'));\n\t\t\t\t\treturn;\n\t\t\t\tcase GitErrorCodes.BranchAlreadyExists:\n\t\t\t\t\twindow.showErrorMessage(localize('branch already exists', \"A branch named '{0}' already exists\", name));\n\t\t\t\t\treturn;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow err;\n\t\t\t}\n\t\t}\n\t}\n\n\t@command('git.merge', { repository: true })\n\tasync merge(repository: Repository): Promise<void> {\n\t\tconst config = workspace.getConfiguration('git');\n\t\tconst checkoutType = config.get<string>('checkoutType') || 'all';\n\t\tconst includeRemotes = checkoutType === 'all' || checkoutType === 'remote';\n\n\t\tconst heads = repository.refs.filter(ref => ref.type === RefType.Head)\n\t\t\t.filter(ref => ref.name || ref.commit)\n\t\t\t.map(ref => new MergeItem(ref as Branch));\n\n\t\tconst remoteHeads = (includeRemotes ? repository.refs.filter(ref => ref.type === RefType.RemoteHead) : [])\n\t\t\t.filter(ref => ref.name || ref.commit)\n\t\t\t.map(ref => new MergeItem(ref as Branch));\n\n\t\tconst picks = [...heads, ...remoteHeads];\n\t\tconst placeHolder = localize('select a branch to merge from', 'Select a branch to merge from');\n\t\tconst choice = await window.showQuickPick<MergeItem>(picks, { placeHolder });\n\n\t\tif (!choice) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tawait choice.run(repository);\n\t\t} catch (err) {\n\t\t\tif (err.gitErrorCode !== GitErrorCodes.Conflict) {\n\t\t\t\tthrow err;\n\t\t\t}\n\n\t\t\tconst message = localize('merge conflicts', \"There are merge conflicts. Resolve them before committing.\");\n\t\t\tawait window.showWarningMessage(message);\n\t\t}\n\t}\n\n\t@command('git.createTag', { repository: true })\n\tasync createTag(repository: Repository): Promise<void> {\n\t\tconst inputTagName = await window.showInputBox({\n\t\t\tplaceHolder: localize('tag name', \"Tag name\"),\n\t\t\tprompt: localize('provide tag name', \"Please provide a tag name\"),\n\t\t\tignoreFocusOut: true\n\t\t});\n\n\t\tif (!inputTagName) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst inputMessage = await window.showInputBox({\n\t\t\tplaceHolder: localize('tag message', \"Message\"),\n\t\t\tprompt: localize('provide tag message', \"Please provide a message to annotate the tag\"),\n\t\t\tignoreFocusOut: true\n\t\t});\n\n\t\tconst name = inputTagName.replace(/^\\.|\\/\\.|\\.\\.|~|\\^|:|\\/$|\\.lock$|\\.lock\\/|\\\\|\\*|\\s|^\\s*$|\\.$/g, '-');\n\t\tconst message = inputMessage || name;\n\t\tawait repository.tag(name, message);\n\t}\n\n\t@command('git.fetch', { repository: true })\n\tasync fetch(repository: Repository): Promise<void> {\n\t\tif (repository.remotes.length === 0) {\n\t\t\twindow.showWarningMessage(localize('no remotes to fetch', \"This repository has no remotes configured to fetch from.\"));\n\t\t\treturn;\n\t\t}\n\n\t\tawait repository.fetch();\n\t}\n\n\t@command('git.pullFrom', { repository: true })\n\tasync pullFrom(repository: Repository): Promise<void> {\n\t\tconst remotes = repository.remotes;\n\n\t\tif (remotes.length === 0) {\n\t\t\twindow.showWarningMessage(localize('no remotes to pull', \"Your repository has no remotes configured to pull from.\"));\n\t\t\treturn;\n\t\t}\n\n\t\tconst remotePicks = remotes.map(r => ({ label: r.name, description: r.url }));\n\t\tconst placeHolder = localize('pick remote pull repo', \"Pick a remote to pull the branch from\");\n\t\tconst remotePick = await window.showQuickPick(remotePicks, { placeHolder });\n\n\t\tif (!remotePick) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst remoteRefs = repository.refs;\n\t\tconst remoteRefsFiltered = remoteRefs.filter(r => (r.remote === remotePick.label));\n\t\tconst branchPicks = remoteRefsFiltered.map(r => ({ label: r.name })) as { label: string; description: string }[];\n\t\tconst branchPick = await window.showQuickPick(branchPicks, { placeHolder });\n\n\t\tif (!branchPick) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst remoteCharCnt = remotePick.label.length;\n\n\t\trepository.pullFrom(false, remotePick.label, branchPick.label.slice(remoteCharCnt + 1));\n\t}\n\n\t@command('git.pull', { repository: true })\n\tasync pull(repository: Repository): Promise<void> {\n\t\tconst remotes = repository.remotes;\n\n\t\tif (remotes.length === 0) {\n\t\t\twindow.showWarningMessage(localize('no remotes to pull', \"Your repository has no remotes configured to pull from.\"));\n\t\t\treturn;\n\t\t}\n\n\t\tawait repository.pull(repository.HEAD);\n\t}\n\n\t@command('git.pullRebase', { repository: true })\n\tasync pullRebase(repository: Repository): Promise<void> {\n\t\tconst remotes = repository.remotes;\n\n\t\tif (remotes.length === 0) {\n\t\t\twindow.showWarningMessage(localize('no remotes to pull', \"Your repository has no remotes configured to pull from.\"));\n\t\t\treturn;\n\t\t}\n\n\t\tawait repository.pullWithRebase(repository.HEAD);\n\t}\n\n\t@command('git.push', { repository: true })\n\tasync push(repository: Repository): Promise<void> {\n\t\tconst remotes = repository.remotes;\n\n\t\tif (remotes.length === 0) {\n\t\t\twindow.showWarningMessage(localize('no remotes to push', \"Your repository has no remotes configured to push to.\"));\n\t\t\treturn;\n\t\t}\n\n\t\tif (!repository.HEAD || !repository.HEAD.name) {\n\t\t\twindow.showWarningMessage(localize('nobranch', \"Please check out a branch to push to a remote.\"));\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tawait repository.push(repository.HEAD);\n\t\t} catch (err) {\n\t\t\tif (err.gitErrorCode !== GitErrorCodes.NoUpstreamBranch) {\n\t\t\t\tthrow err;\n\t\t\t}\n\n\t\t\tconst branchName = repository.HEAD.name;\n\t\t\tconst message = localize('confirm publish branch', \"The branch '{0}' has no upstream branch. Would you like to publish this branch?\", branchName);\n\t\t\tconst yes = localize('ok', \"OK\");\n\t\t\tconst pick = await window.showWarningMessage(message, { modal: true }, yes);\n\n\t\t\tif (pick === yes) {\n\t\t\t\tawait this.publish(repository);\n\t\t\t}\n\t\t}\n\t}\n\n\t@command('git.pushWithTags', { repository: true })\n\tasync pushWithTags(repository: Repository): Promise<void> {\n\t\tconst remotes = repository.remotes;\n\n\t\tif (remotes.length === 0) {\n\t\t\twindow.showWarningMessage(localize('no remotes to push', \"Your repository has no remotes configured to push to.\"));\n\t\t\treturn;\n\t\t}\n\n\t\tawait repository.pushTags();\n\n\t\twindow.showInformationMessage(localize('push with tags success', \"Successfully pushed with tags.\"));\n\t}\n\n\t@command('git.pushTo', { repository: true })\n\tasync pushTo(repository: Repository): Promise<void> {\n\t\tconst remotes = repository.remotes;\n\n\t\tif (remotes.length === 0) {\n\t\t\twindow.showWarningMessage(localize('no remotes to push', \"Your repository has no remotes configured to push to.\"));\n\t\t\treturn;\n\t\t}\n\n\t\tif (!repository.HEAD || !repository.HEAD.name) {\n\t\t\twindow.showWarningMessage(localize('nobranch', \"Please check out a branch to push to a remote.\"));\n\t\t\treturn;\n\t\t}\n\n\t\tconst branchName = repository.HEAD.name;\n\t\tconst picks = remotes.map(r => ({ label: r.name, description: r.url }));\n\t\tconst placeHolder = localize('pick remote', \"Pick a remote to publish the branch '{0}' to:\", branchName);\n\t\tconst pick = await window.showQuickPick(picks, { placeHolder });\n\n\t\tif (!pick) {\n\t\t\treturn;\n\t\t}\n\n\t\trepository.pushTo(pick.label, branchName);\n\t}\n\n\tprivate async _sync(repository: Repository, rebase: boolean): Promise<void> {\n\t\tconst HEAD = repository.HEAD;\n\n\t\tif (!HEAD || !HEAD.upstream) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst config = workspace.getConfiguration('git');\n\t\tconst shouldPrompt = config.get<boolean>('confirmSync') === true;\n\n\t\tif (shouldPrompt) {\n\t\t\tconst message = localize('sync is unpredictable', \"This action will push and pull commits to and from '{0}/{1}'.\", HEAD.upstream.remote, HEAD.upstream.name);\n\t\t\tconst yes = localize('ok', \"OK\");\n\t\t\tconst neverAgain = localize('never again', \"OK, Don't Show Again\");\n\t\t\tconst pick = await window.showWarningMessage(message, { modal: true }, yes, neverAgain);\n\n\t\t\tif (pick === neverAgain) {\n\t\t\t\tawait config.update('confirmSync', false, true);\n\t\t\t} else if (pick !== yes) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (rebase) {\n\t\t\tawait repository.syncRebase(HEAD);\n\t\t} else {\n\t\t\tawait repository.sync(HEAD);\n\t\t}\n\t}\n\n\t@command('git.sync', { repository: true })\n\tsync(repository: Repository): Promise<void> {\n\t\treturn this._sync(repository, false);\n\t}\n\n\t@command('git._syncAll')\n\tasync syncAll(): Promise<void> {\n\t\tawait Promise.all(this.model.repositories.map(async repository => {\n\t\t\tconst HEAD = repository.HEAD;\n\n\t\t\tif (!HEAD || !HEAD.upstream) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tawait repository.sync(HEAD);\n\t\t}));\n\t}\n\n\t@command('git.syncRebase', { repository: true })\n\tsyncRebase(repository: Repository): Promise<void> {\n\t\treturn this._sync(repository, true);\n\t}\n\n\t@command('git.publish', { repository: true })\n\tasync publish(repository: Repository): Promise<void> {\n\t\tconst remotes = repository.remotes;\n\n\t\tif (remotes.length === 0) {\n\t\t\twindow.showWarningMessage(localize('no remotes to publish', \"Your repository has no remotes configured to publish to.\"));\n\t\t\treturn;\n\t\t}\n\n\t\tconst branchName = repository.HEAD && repository.HEAD.name || '';\n\t\tconst selectRemote = async () => {\n\t\t\tconst picks = repository.remotes.map(r => r.name);\n\t\t\tconst placeHolder = localize('pick remote', \"Pick a remote to publish the branch '{0}' to:\", branchName);\n\t\t\treturn await window.showQuickPick(picks, { placeHolder });\n\t\t};\n\t\tconst choice = remotes.length === 1 ? remotes[0].name : await selectRemote();\n\n\t\tif (!choice) {\n\t\t\treturn;\n\t\t}\n\n\t\tawait repository.pushTo(choice, branchName, true);\n\t}\n\n\t@command('git.ignore')\n\tasync ignore(...resourceStates: SourceControlResourceState[]): Promise<void> {\n\t\tif (resourceStates.length === 0 || (resourceStates[0] && !(resourceStates[0].resourceUri instanceof Uri))) {\n\t\t\tconst resource = this.getSCMResource();\n\n\t\t\tif (!resource) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tresourceStates = [resource];\n\t\t}\n\n\t\tconst resources = resourceStates\n\t\t\t.filter(s => s instanceof Resource)\n\t\t\t.map(r => r.resourceUri);\n\n\t\tif (!resources.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tawait this.runByRepository(resources, async (repository, resources) => repository.ignore(resources));\n\t}\n\n\tprivate async _stash(repository: Repository, includeUntracked = false): Promise<void> {\n\t\tconst noUnstagedChanges = repository.workingTreeGroup.resourceStates.length === 0;\n\t\tconst noStagedChanges = repository.indexGroup.resourceStates.length === 0;\n\n\t\tif (noUnstagedChanges && noStagedChanges) {\n\t\t\twindow.showInformationMessage(localize('no changes stash', \"There are no changes to stash.\"));\n\t\t\treturn;\n\t\t}\n\n\t\tconst message = await this.getStashMessage();\n\n\t\tif (typeof message === 'undefined') {\n\t\t\treturn;\n\t\t}\n\n\t\tawait repository.createStash(message, includeUntracked);\n\t}\n\n\tprivate async getStashMessage(): Promise<string | undefined> {\n\t\treturn await window.showInputBox({\n\t\t\tprompt: localize('provide stash message', \"Optionally provide a stash message\"),\n\t\t\tplaceHolder: localize('stash message', \"Stash message\")\n\t\t});\n\t}\n\n\t@command('git.stash', { repository: true })\n\tstash(repository: Repository): Promise<void> {\n\t\treturn this._stash(repository);\n\t}\n\n\t@command('git.stashIncludeUntracked', { repository: true })\n\tstashIncludeUntracked(repository: Repository): Promise<void> {\n\t\treturn this._stash(repository, true);\n\t}\n\n\t@command('git.stashPop', { repository: true })\n\tasync stashPop(repository: Repository): Promise<void> {\n\t\tconst stashes = await repository.getStashes();\n\n\t\tif (stashes.length === 0) {\n\t\t\twindow.showInformationMessage(localize('no stashes', \"There are no stashes to restore.\"));\n\t\t\treturn;\n\t\t}\n\n\t\tconst picks = stashes.map(r => ({ label: `#${r.index}:  ${r.description}`, description: '', details: '', id: r.index }));\n\t\tconst placeHolder = localize('pick stash to pop', \"Pick a stash to pop\");\n\t\tconst choice = await window.showQuickPick(picks, { placeHolder });\n\n\t\tif (!choice) {\n\t\t\treturn;\n\t\t}\n\n\t\tawait repository.popStash(choice.id);\n\t}\n\n\t@command('git.stashPopLatest', { repository: true })\n\tasync stashPopLatest(repository: Repository): Promise<void> {\n\t\tconst stashes = await repository.getStashes();\n\n\t\tif (stashes.length === 0) {\n\t\t\twindow.showInformationMessage(localize('no stashes', \"There are no stashes to restore.\"));\n\t\t\treturn;\n\t\t}\n\n\t\tawait repository.popStash();\n\t}\n\n\tprivate createCommand(id: string, key: string, method: Function, options: CommandOptions): (...args: any[]) => any {\n\t\tconst result = (...args: any[]) => {\n\t\t\tlet result: Promise<any>;\n\n\t\t\tif (!options.repository) {\n\t\t\t\tresult = Promise.resolve(method.apply(this, args));\n\t\t\t} else {\n\t\t\t\t// try to guess the repository based on the first argument\n\t\t\t\tconst repository = this.model.getRepository(args[0]);\n\t\t\t\tlet repositoryPromise: Promise<Repository | undefined>;\n\n\t\t\t\tif (repository) {\n\t\t\t\t\trepositoryPromise = Promise.resolve(repository);\n\t\t\t\t} else if (this.model.repositories.length === 1) {\n\t\t\t\t\trepositoryPromise = Promise.resolve(this.model.repositories[0]);\n\t\t\t\t} else {\n\t\t\t\t\trepositoryPromise = this.model.pickRepository();\n\t\t\t\t}\n\n\t\t\t\tresult = repositoryPromise.then(repository => {\n\t\t\t\t\tif (!repository) {\n\t\t\t\t\t\treturn Promise.resolve();\n\t\t\t\t\t}\n\n\t\t\t\t\treturn Promise.resolve(method.apply(this, [repository, ...args]));\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t/* __GDPR__\n\t\t\t\t\"git.command\" : {\n\t\t\t\t\t\"command\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n\t\t\t\t}\n\t\t\t*/\n\t\t\tthis.telemetryReporter.sendTelemetryEvent('git.command', { command: id });\n\n\t\t\treturn result.catch(async err => {\n\t\t\t\tconst options: MessageOptions = {\n\t\t\t\t\tmodal: err.gitErrorCode === GitErrorCodes.DirtyWorkTree\n\t\t\t\t};\n\n\t\t\t\tlet message: string;\n\n\t\t\t\tswitch (err.gitErrorCode) {\n\t\t\t\t\tcase GitErrorCodes.DirtyWorkTree:\n\t\t\t\t\t\tmessage = localize('clean repo', \"Please clean your repository working tree before checkout.\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GitErrorCodes.PushRejected:\n\t\t\t\t\t\tmessage = localize('cant push', \"Can't push refs to remote. Try running 'Pull' first to integrate your changes.\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconst hint = (err.stderr || err.message || String(err))\n\t\t\t\t\t\t\t.replace(/^error: /mi, '')\n\t\t\t\t\t\t\t.replace(/^> husky.*$/mi, '')\n\t\t\t\t\t\t\t.split(/[\\r\\n]/)\n\t\t\t\t\t\t\t.filter((line: string) => !!line)\n\t\t\t\t\t\t[0];\n\n\t\t\t\t\t\tmessage = hint\n\t\t\t\t\t\t\t? localize('git error details', \"Git: {0}\", hint)\n\t\t\t\t\t\t\t: localize('git error', \"Git error\");\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (!message) {\n\t\t\t\t\tconsole.error(err);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\toptions.modal = true;\n\n\t\t\t\tconst outputChannel = this.outputChannel as OutputChannel;\n\t\t\t\tconst openOutputChannelChoice = localize('open git log', \"Open Git Log\");\n\t\t\t\tconst choice = await window.showErrorMessage(message, options, openOutputChannelChoice);\n\n\t\t\t\tif (choice === openOutputChannelChoice) {\n\t\t\t\t\toutputChannel.show();\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\n\t\t// patch this object, so people can call methods directly\n\t\t(this as any)[key] = result;\n\n\t\treturn result;\n\t}\n\n\tprivate getSCMResource(uri?: Uri): Resource | undefined {\n\t\turi = uri ? uri : window.activeTextEditor && window.activeTextEditor.document.uri;\n\n\t\tif (!uri) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (uri.scheme === 'git') {\n\t\t\tconst { path } = fromGitUri(uri);\n\t\t\turi = Uri.file(path);\n\t\t}\n\n\t\tif (uri.scheme === 'file') {\n\t\t\tconst uriString = uri.toString();\n\t\t\tconst repository = this.model.getRepository(uri);\n\n\t\t\tif (!repository) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\treturn repository.workingTreeGroup.resourceStates.filter(r => r.resourceUri.toString() === uriString)[0]\n\t\t\t\t|| repository.indexGroup.resourceStates.filter(r => r.resourceUri.toString() === uriString)[0];\n\t\t}\n\t}\n\n\tprivate runByRepository<T>(resource: Uri, fn: (repository: Repository, resource: Uri) => Promise<T>): Promise<T[]>;\n\tprivate runByRepository<T>(resources: Uri[], fn: (repository: Repository, resources: Uri[]) => Promise<T>): Promise<T[]>;\n\tprivate async runByRepository<T>(arg: Uri | Uri[], fn: (repository: Repository, resources: any) => Promise<T>): Promise<T[]> {\n\t\tconst resources = arg instanceof Uri ? [arg] : arg;\n\t\tconst isSingleResource = arg instanceof Uri;\n\n\t\tconst groups = resources.reduce((result, resource) => {\n\t\t\tlet repository = this.model.getRepository(resource);\n\n\t\t\tif (!repository) {\n\t\t\t\tconsole.warn('Could not find git repository for ', resource);\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\t// Could it be a submodule?\n\t\t\tif (resource.fsPath === repository.root) {\n\t\t\t\trepository = this.model.getRepositoryForSubmodule(resource) || repository;\n\t\t\t}\n\n\t\t\tconst tuple = result.filter(p => p.repository === repository)[0];\n\n\t\t\tif (tuple) {\n\t\t\t\ttuple.resources.push(resource);\n\t\t\t} else {\n\t\t\t\tresult.push({ repository, resources: [resource] });\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}, [] as { repository: Repository, resources: Uri[] }[]);\n\n\t\tconst promises = groups\n\t\t\t.map(({ repository, resources }) => fn(repository as Repository, isSingleResource ? resources[0] : resources));\n\n\t\treturn Promise.all(promises);\n\t}\n\n\tdispose(): void {\n\t\tthis.disposables.forEach(d => d.dispose());\n\t}\n}\n",
            "linguagem": "ts",
            "total_linhas": 1754
        },
        "solucao_humana": {
            "patch_diff": "@@ -1205,7 +1205,7 @@ export class CommandCenter {\n \n \t\t\tconst message = localize('confirm force delete branch', \"The branch '{0}' is not fully merged. Delete anyway?\", name);\n \t\t\tconst yes = localize('delete branch', \"Delete Branch\");\n-\t\t\tconst pick = await window.showWarningMessage(message, yes);\n+\t\t\tconst pick = await window.showWarningMessage(message, { modal: true }, yes);\n \n \t\t\tif (pick === yes) {\n \t\t\t\tawait run(true);",
            "apenas_linhas_adicionadas": [
                "\t\t\tconst pick = await window.showWarningMessage(message, { modal: true }, yes);"
            ]
        }
    },
    {
        "id": 49613,
        "url": "https://github.com/microsoft/vscode/pull/49613",
        "arquivo_caminho": "src/vs/workbench/services/themes/electron-browser/fileIconThemeData.ts",
        "descricao_bug": "There is a spell error in src/vs/workbench/services/themes/electron-browser/fileIconThemeData.ts\r\n\r\nfont-weigth => font-weight",
        "contexto": {
            "codigo_completo_bugado": "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport URI from 'vs/base/common/uri';\nimport * as nls from 'vs/nls';\nimport * as Paths from 'path';\nimport * as Json from 'vs/base/common/json';\nimport { ExtensionData, IThemeExtensionPoint, IFileIconTheme } from 'vs/workbench/services/themes/common/workbenchThemeService';\nimport { TPromise } from 'vs/base/common/winjs.base';\nimport * as pfs from 'vs/base/node/pfs';\nimport { WorkbenchThemeService } from 'vs/workbench/services/themes/electron-browser/workbenchThemeService';\nimport { getParseErrorMessage } from 'vs/base/common/jsonErrorMessages';\n\nexport class FileIconThemeData implements IFileIconTheme {\n\tid: string;\n\tlabel: string;\n\tsettingsId: string;\n\tdescription?: string;\n\thasFileIcons?: boolean;\n\thasFolderIcons?: boolean;\n\thidesExplorerArrows?: boolean;\n\tisLoaded: boolean;\n\tpath?: string;\n\textensionData: ExtensionData;\n\n\tstyleSheetContent?: string;\n\n\tprivate constructor() {\n\t}\n\n\tpublic ensureLoaded(themeService: WorkbenchThemeService): TPromise<string> {\n\t\tif (!this.isLoaded) {\n\t\t\tif (this.path) {\n\t\t\t\treturn _loadIconThemeDocument(this.path).then(iconThemeDocument => {\n\t\t\t\t\tlet result = _processIconThemeDocument(this.id, this.path, iconThemeDocument);\n\t\t\t\t\tthis.styleSheetContent = result.content;\n\t\t\t\t\tthis.hasFileIcons = result.hasFileIcons;\n\t\t\t\t\tthis.hasFolderIcons = result.hasFolderIcons;\n\t\t\t\t\tthis.hidesExplorerArrows = result.hidesExplorerArrows;\n\t\t\t\t\tthis.isLoaded = true;\n\t\t\t\t\treturn this.styleSheetContent;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn TPromise.as(this.styleSheetContent);\n\t}\n\n\tstatic fromExtensionTheme(iconTheme: IThemeExtensionPoint, normalizedAbsolutePath: string, extensionData: ExtensionData): FileIconThemeData {\n\t\tlet themeData = new FileIconThemeData();\n\t\tthemeData.id = extensionData.extensionId + '-' + iconTheme.id;\n\t\tthemeData.label = iconTheme.label || Paths.basename(iconTheme.path);\n\t\tthemeData.settingsId = iconTheme.id;\n\t\tthemeData.description = iconTheme.description;\n\t\tthemeData.path = normalizedAbsolutePath;\n\t\tthemeData.extensionData = extensionData;\n\t\tthemeData.isLoaded = false;\n\t\treturn themeData;\n\t}\n\n\tprivate static _noIconTheme: FileIconThemeData = null;\n\n\tstatic noIconTheme(): FileIconThemeData {\n\t\tlet themeData = FileIconThemeData._noIconTheme;\n\t\tif (!themeData) {\n\t\t\tthemeData = FileIconThemeData._noIconTheme = new FileIconThemeData();\n\t\t\tthemeData.id = '';\n\t\t\tthemeData.label = '';\n\t\t\tthemeData.settingsId = null;\n\t\t\tthemeData.hasFileIcons = false;\n\t\t\tthemeData.hasFolderIcons = false;\n\t\t\tthemeData.hidesExplorerArrows = false;\n\t\t\tthemeData.isLoaded = true;\n\t\t\tthemeData.extensionData = null;\n\t\t}\n\t\treturn themeData;\n\t}\n\n\tstatic fromStorageData(input: string): FileIconThemeData {\n\t\ttry {\n\t\t\tlet data = JSON.parse(input);\n\t\t\tlet theme = new FileIconThemeData();\n\t\t\tfor (let key in data) {\n\t\t\t\tswitch (key) {\n\t\t\t\t\tcase 'id':\n\t\t\t\t\tcase 'label':\n\t\t\t\t\tcase 'description':\n\t\t\t\t\tcase 'settingsId':\n\t\t\t\t\tcase 'extensionData':\n\t\t\t\t\tcase 'path':\n\t\t\t\t\tcase 'styleSheetContent':\n\t\t\t\t\tcase 'hasFileIcons':\n\t\t\t\t\tcase 'hidesExplorerArrows':\n\t\t\t\t\tcase 'hasFolderIcons':\n\t\t\t\t\t\ttheme[key] = data[key];\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn theme;\n\t\t} catch (e) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\ttoStorageData() {\n\t\treturn JSON.stringify({\n\t\t\tid: this.id,\n\t\t\tlabel: this.label,\n\t\t\tdescription: this.description,\n\t\t\tsettingsId: this.settingsId,\n\t\t\tpath: this.path,\n\t\t\tstyleSheetContent: this.styleSheetContent,\n\t\t\thasFileIcons: this.hasFileIcons,\n\t\t\thasFolderIcons: this.hasFolderIcons,\n\t\t\thidesExplorerArrows: this.hidesExplorerArrows\n\t\t});\n\t}\n}\n\ninterface IconDefinition {\n\ticonPath: string;\n\tfontColor: string;\n\tfontCharacter: string;\n\tfontSize: string;\n\tfontId: string;\n}\n\ninterface FontDefinition {\n\tid: string;\n\tweight: string;\n\tstyle: string;\n\tsize: string;\n\tsrc: { path: string; format: string; }[];\n}\n\ninterface IconsAssociation {\n\tfolder?: string;\n\tfile?: string;\n\tfolderExpanded?: string;\n\trootFolder?: string;\n\trootFolderExpanded?: string;\n\tfolderNames?: { [folderName: string]: string; };\n\tfolderNamesExpanded?: { [folderName: string]: string; };\n\tfileExtensions?: { [extension: string]: string; };\n\tfileNames?: { [fileName: string]: string; };\n\tlanguageIds?: { [languageId: string]: string; };\n}\n\ninterface IconThemeDocument extends IconsAssociation {\n\ticonDefinitions: { [key: string]: IconDefinition };\n\tfonts: FontDefinition[];\n\tlight?: IconsAssociation;\n\thighContrast?: IconsAssociation;\n\thidesExplorerArrows?: boolean;\n}\n\nfunction _loadIconThemeDocument(fileSetPath: string): TPromise<IconThemeDocument> {\n\treturn pfs.readFile(fileSetPath).then(content => {\n\t\tlet errors: Json.ParseError[] = [];\n\t\tlet contentValue = Json.parse(content.toString(), errors);\n\t\tif (errors.length > 0) {\n\t\t\treturn TPromise.wrapError(new Error(nls.localize('error.cannotparseicontheme', \"Problems parsing file icons file: {0}\", errors.map(e => getParseErrorMessage(e.error)).join(', '))));\n\t\t}\n\t\treturn TPromise.as(contentValue);\n\t});\n}\n\nfunction _processIconThemeDocument(id: string, iconThemeDocumentPath: string, iconThemeDocument: IconThemeDocument): { content: string; hasFileIcons: boolean; hasFolderIcons: boolean; hidesExplorerArrows: boolean; } {\n\n\tlet result = { content: '', hasFileIcons: false, hasFolderIcons: false, hidesExplorerArrows: iconThemeDocument.hidesExplorerArrows };\n\n\tif (!iconThemeDocument.iconDefinitions) {\n\t\treturn result;\n\t}\n\tlet selectorByDefinitionId: { [def: string]: string[] } = {};\n\n\tfunction resolvePath(path: string) {\n\t\tconst uri = URI.file(Paths.join(Paths.dirname(iconThemeDocumentPath), path));\n\t\treturn uri.toString();\n\t}\n\n\tfunction collectSelectors(associations: IconsAssociation, baseThemeClassName?: string) {\n\t\tfunction addSelector(selector: string, defId: string) {\n\t\t\tif (defId) {\n\t\t\t\tlet list = selectorByDefinitionId[defId];\n\t\t\t\tif (!list) {\n\t\t\t\t\tlist = selectorByDefinitionId[defId] = [];\n\t\t\t\t}\n\t\t\t\tlist.push(selector);\n\t\t\t}\n\t\t}\n\t\tif (associations) {\n\t\t\tlet qualifier = '.show-file-icons';\n\t\t\tif (baseThemeClassName) {\n\t\t\t\tqualifier = baseThemeClassName + ' ' + qualifier;\n\t\t\t}\n\n\t\t\tlet expanded = '.monaco-tree-row.expanded'; // workaround for #11453\n\n\t\t\tif (associations.folder) {\n\t\t\t\taddSelector(`${qualifier} .folder-icon::before`, associations.folder);\n\t\t\t\tresult.hasFolderIcons = true;\n\t\t\t}\n\n\t\t\tif (associations.folderExpanded) {\n\t\t\t\taddSelector(`${qualifier} ${expanded} .folder-icon::before`, associations.folderExpanded);\n\t\t\t\tresult.hasFolderIcons = true;\n\t\t\t}\n\n\t\t\tlet rootFolder = associations.rootFolder || associations.folder;\n\t\t\tlet rootFolderExpanded = associations.rootFolderExpanded || associations.folderExpanded;\n\n\t\t\tif (rootFolder) {\n\t\t\t\taddSelector(`${qualifier} .rootfolder-icon::before`, rootFolder);\n\t\t\t\tresult.hasFolderIcons = true;\n\t\t\t}\n\n\t\t\tif (rootFolderExpanded) {\n\t\t\t\taddSelector(`${qualifier} ${expanded} .rootfolder-icon::before`, rootFolderExpanded);\n\t\t\t\tresult.hasFolderIcons = true;\n\t\t\t}\n\n\t\t\tif (associations.file) {\n\t\t\t\taddSelector(`${qualifier} .file-icon::before`, associations.file);\n\t\t\t\tresult.hasFileIcons = true;\n\t\t\t}\n\n\t\t\tlet folderNames = associations.folderNames;\n\t\t\tif (folderNames) {\n\t\t\t\tfor (let folderName in folderNames) {\n\t\t\t\t\taddSelector(`${qualifier} .${escapeCSS(folderName.toLowerCase())}-name-folder-icon.folder-icon::before`, folderNames[folderName]);\n\t\t\t\t\tresult.hasFolderIcons = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet folderNamesExpanded = associations.folderNamesExpanded;\n\t\t\tif (folderNamesExpanded) {\n\t\t\t\tfor (let folderName in folderNamesExpanded) {\n\t\t\t\t\taddSelector(`${qualifier} ${expanded} .${escapeCSS(folderName.toLowerCase())}-name-folder-icon.folder-icon::before`, folderNamesExpanded[folderName]);\n\t\t\t\t\tresult.hasFolderIcons = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet languageIds = associations.languageIds;\n\t\t\tif (languageIds) {\n\t\t\t\tif (!languageIds.jsonc && languageIds.json) {\n\t\t\t\t\tlanguageIds.jsonc = languageIds.json;\n\t\t\t\t}\n\t\t\t\tfor (let languageId in languageIds) {\n\t\t\t\t\taddSelector(`${qualifier} .${escapeCSS(languageId)}-lang-file-icon.file-icon::before`, languageIds[languageId]);\n\t\t\t\t\tresult.hasFileIcons = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet fileExtensions = associations.fileExtensions;\n\t\t\tif (fileExtensions) {\n\t\t\t\tfor (let fileExtension in fileExtensions) {\n\t\t\t\t\tlet selectors: string[] = [];\n\t\t\t\t\tlet segments = fileExtension.toLowerCase().split('.');\n\t\t\t\t\tif (segments.length) {\n\t\t\t\t\t\tfor (let i = 0; i < segments.length; i++) {\n\t\t\t\t\t\t\tselectors.push(`.${escapeCSS(segments.slice(i).join('.'))}-ext-file-icon`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tselectors.push('.ext-file-icon'); // extra segment to increase file-ext score\n\t\t\t\t\t}\n\t\t\t\t\taddSelector(`${qualifier} ${selectors.join('')}.file-icon::before`, fileExtensions[fileExtension]);\n\t\t\t\t\tresult.hasFileIcons = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet fileNames = associations.fileNames;\n\t\t\tif (fileNames) {\n\t\t\t\tfor (let fileName in fileNames) {\n\t\t\t\t\tlet selectors: string[] = [];\n\t\t\t\t\tfileName = fileName.toLowerCase();\n\t\t\t\t\tselectors.push(`.${escapeCSS(fileName)}-name-file-icon`);\n\t\t\t\t\tlet segments = fileName.split('.');\n\t\t\t\t\tif (segments.length) {\n\t\t\t\t\t\tfor (let i = 1; i < segments.length; i++) {\n\t\t\t\t\t\t\tselectors.push(`.${escapeCSS(segments.slice(i).join('.'))}-ext-file-icon`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tselectors.push('.ext-file-icon'); // extra segment to increase file-ext score\n\t\t\t\t\t}\n\t\t\t\t\taddSelector(`${qualifier} ${selectors.join('')}.file-icon::before`, fileNames[fileName]);\n\t\t\t\t\tresult.hasFileIcons = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcollectSelectors(iconThemeDocument);\n\tcollectSelectors(iconThemeDocument.light, '.vs');\n\tcollectSelectors(iconThemeDocument.highContrast, '.hc-black');\n\n\tif (!result.hasFileIcons && !result.hasFolderIcons) {\n\t\treturn result;\n\t}\n\n\tlet cssRules: string[] = [];\n\n\tlet fonts = iconThemeDocument.fonts;\n\tif (Array.isArray(fonts)) {\n\t\tfonts.forEach(font => {\n\t\t\tlet src = font.src.map(l => `url('${resolvePath(l.path)}') format('${l.format}')`).join(', ');\n\t\t\tcssRules.push(`@font-face { src: ${src}; font-family: '${font.id}'; font-weigth: ${font.weight}; font-style: ${font.style}; }`);\n\t\t});\n\t\tcssRules.push(`.show-file-icons .file-icon::before, .show-file-icons .folder-icon::before, .show-file-icons .rootfolder-icon::before { font-family: '${fonts[0].id}'; font-size: ${fonts[0].size || '150%'}}`);\n\t}\n\n\tfor (let defId in selectorByDefinitionId) {\n\t\tlet selectors = selectorByDefinitionId[defId];\n\t\tlet definition = iconThemeDocument.iconDefinitions[defId];\n\t\tif (definition) {\n\t\t\tif (definition.iconPath) {\n\t\t\t\tcssRules.push(`${selectors.join(', ')} { content: ' '; background-image: url(\"${resolvePath(definition.iconPath)}\"); }`);\n\t\t\t}\n\t\t\tif (definition.fontCharacter || definition.fontColor) {\n\t\t\t\tlet body = '';\n\t\t\t\tif (definition.fontColor) {\n\t\t\t\t\tbody += ` color: ${definition.fontColor};`;\n\t\t\t\t}\n\t\t\t\tif (definition.fontCharacter) {\n\t\t\t\t\tbody += ` content: '${definition.fontCharacter}';`;\n\t\t\t\t}\n\t\t\t\tif (definition.fontSize) {\n\t\t\t\t\tbody += ` font-size: ${definition.fontSize};`;\n\t\t\t\t}\n\t\t\t\tif (definition.fontId) {\n\t\t\t\t\tbody += ` font-family: ${definition.fontId};`;\n\t\t\t\t}\n\t\t\t\tcssRules.push(`${selectors.join(', ')} { ${body} }`);\n\t\t\t}\n\t\t}\n\t}\n\tresult.content = cssRules.join('\\n');\n\treturn result;\n}\nfunction escapeCSS(str: string) {\n\treturn window['CSS'].escape(str);\n}",
            "linguagem": "ts",
            "total_linhas": 338
        },
        "solucao_humana": {
            "patch_diff": "@@ -300,7 +300,7 @@ function _processIconThemeDocument(id: string, iconThemeDocumentPath: string, ic\n \tif (Array.isArray(fonts)) {\n \t\tfonts.forEach(font => {\n \t\t\tlet src = font.src.map(l => `url('${resolvePath(l.path)}') format('${l.format}')`).join(', ');\n-\t\t\tcssRules.push(`@font-face { src: ${src}; font-family: '${font.id}'; font-weigth: ${font.weight}; font-style: ${font.style}; }`);\n+\t\t\tcssRules.push(`@font-face { src: ${src}; font-family: '${font.id}'; font-weight: ${font.weight}; font-style: ${font.style}; }`);\n \t\t});\n \t\tcssRules.push(`.show-file-icons .file-icon::before, .show-file-icons .folder-icon::before, .show-file-icons .rootfolder-icon::before { font-family: '${fonts[0].id}'; font-size: ${fonts[0].size || '150%'}}`);\n \t}\n@@ -335,4 +335,4 @@ function _processIconThemeDocument(id: string, iconThemeDocumentPath: string, ic\n }\n function escapeCSS(str: string) {\n \treturn window['CSS'].escape(str);\n-}\n\\ No newline at end of file\n+}",
            "apenas_linhas_adicionadas": [
                "\t\t\tcssRules.push(`@font-face { src: ${src}; font-family: '${font.id}'; font-weight: ${font.weight}; font-style: ${font.style}; }`);",
                "}"
            ]
        }
    },
    {
        "id": 49684,
        "url": "https://github.com/microsoft/vscode/pull/49684",
        "arquivo_caminho": "src/vs/platform/jsonschemas/common/jsonContributionRegistry.ts",
        "descricao_bug": "Change logs:\r\n\r\n**1) /vscode/src/vs/platform/jsonschemas/common/jsonContributionRegistry.tsRemove interface `IJSONContributionRegistryEvent`.**\r\n\r\nWhy?\r\n\r\n**This event was created in 2015, and it's never referred by any other modules, functionsect, when you are looking for its references in Visual Studio Code.**",
        "contexto": {
            "codigo_completo_bugado": "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport { IJSONSchema } from 'vs/base/common/jsonSchema';\nimport * as platform from 'vs/platform/registry/common/platform';\nimport { Event, Emitter } from 'vs/base/common/event';\n\nexport const Extensions = {\n\tJSONContribution: 'base.contributions.json'\n};\n\nexport interface ISchemaContributions {\n\tschemas?: { [id: string]: IJSONSchema };\n}\n\nexport interface IJSONContributionRegistry {\n\n\treadonly onDidChangeSchema: Event<string>;\n\n\t/**\n\t * Register a schema to the registry.\n\t */\n\tregisterSchema(uri: string, unresolvedSchemaContent: IJSONSchema): void;\n\n\n\t/**\n\t * Notifies all listeneres that the content of the given schema has changed.\n\t * @param uri The id of the schema\n\t */\n\tnotifySchemaChanged(uri: string): void;\n\n\t/**\n\t * Get all schemas\n\t */\n\tgetSchemaContributions(): ISchemaContributions;\n}\n\nexport interface IJSONContributionRegistryEvent {\n\n}\n\nfunction normalizeId(id: string) {\n\tif (id.length > 0 && id.charAt(id.length - 1) === '#') {\n\t\treturn id.substring(0, id.length - 1);\n\t}\n\treturn id;\n}\n\n\n\nclass JSONContributionRegistry implements IJSONContributionRegistry {\n\n\tprivate schemasById: { [id: string]: IJSONSchema };\n\n\tprivate readonly _onDidChangeSchema: Emitter<string> = new Emitter<string>();\n\treadonly onDidChangeSchema: Event<string> = this._onDidChangeSchema.event;\n\n\tconstructor() {\n\t\tthis.schemasById = {};\n\t}\n\n\tpublic registerSchema(uri: string, unresolvedSchemaContent: IJSONSchema): void {\n\t\tthis.schemasById[normalizeId(uri)] = unresolvedSchemaContent;\n\t\tthis._onDidChangeSchema.fire(uri);\n\t}\n\n\tpublic notifySchemaChanged(uri: string): void {\n\t\tthis._onDidChangeSchema.fire(uri);\n\t}\n\n\tpublic getSchemaContributions(): ISchemaContributions {\n\t\treturn {\n\t\t\tschemas: this.schemasById,\n\t\t};\n\t}\n\n}\n\nconst jsonContributionRegistry = new JSONContributionRegistry();\nplatform.Registry.add(Extensions.JSONContribution, jsonContributionRegistry);",
            "linguagem": "ts",
            "total_linhas": 83
        },
        "solucao_humana": {
            "patch_diff": "@@ -38,9 +38,7 @@ export interface IJSONContributionRegistry {\n \tgetSchemaContributions(): ISchemaContributions;\n }\n \n-export interface IJSONContributionRegistryEvent {\n \n-}\n \n function normalizeId(id: string) {\n \tif (id.length > 0 && id.charAt(id.length - 1) === '#') {",
            "apenas_linhas_adicionadas": []
        }
    },
    {
        "id": 51224,
        "url": "https://github.com/microsoft/vscode/pull/51224",
        "arquivo_caminho": "src/vs/code/electron-main/app.ts",
        "descricao_bug": "Fixes #40505\r\n\r\n@bpasero @alexandrudima @sandy081 Make sure the changes makes sense.",
        "contexto": {
            "codigo_completo_bugado": "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n'use strict';\n\nimport { app, ipcMain as ipc } from 'electron';\nimport * as platform from 'vs/base/common/platform';\nimport { WindowsManager } from 'vs/code/electron-main/windows';\nimport { IWindowsService, OpenContext, ActiveWindowManager } from 'vs/platform/windows/common/windows';\nimport { WindowsChannel } from 'vs/platform/windows/common/windowsIpc';\nimport { WindowsService } from 'vs/platform/windows/electron-main/windowsService';\nimport { ILifecycleService } from 'vs/platform/lifecycle/electron-main/lifecycleMain';\nimport { CodeMenu } from 'vs/code/electron-main/menus';\nimport { getShellEnvironment } from 'vs/code/node/shellEnv';\nimport { IUpdateService } from 'vs/platform/update/common/update';\nimport { UpdateChannel } from 'vs/platform/update/common/updateIpc';\nimport { Server as ElectronIPCServer } from 'vs/base/parts/ipc/electron-main/ipc.electron-main';\nimport { Server, connect, Client } from 'vs/base/parts/ipc/node/ipc.net';\nimport { SharedProcess } from 'vs/code/electron-main/sharedProcess';\nimport { Mutex } from 'windows-mutex';\nimport { LaunchService, LaunchChannel, ILaunchService } from './launch';\nimport { IInstantiationService, ServicesAccessor } from 'vs/platform/instantiation/common/instantiation';\nimport { ServiceCollection } from 'vs/platform/instantiation/common/serviceCollection';\nimport { SyncDescriptor } from 'vs/platform/instantiation/common/descriptors';\nimport { ILogService } from 'vs/platform/log/common/log';\nimport { IStateService } from 'vs/platform/state/common/state';\nimport { IEnvironmentService } from 'vs/platform/environment/common/environment';\nimport { IConfigurationService } from 'vs/platform/configuration/common/configuration';\nimport { IURLService } from 'vs/platform/url/common/url';\nimport { URLHandlerChannelClient, URLServiceChannel } from 'vs/platform/url/common/urlIpc';\nimport { ITelemetryService } from 'vs/platform/telemetry/common/telemetry';\nimport { NullTelemetryService } from 'vs/platform/telemetry/common/telemetryUtils';\nimport { ITelemetryAppenderChannel, TelemetryAppenderClient } from 'vs/platform/telemetry/common/telemetryIpc';\nimport { TelemetryService, ITelemetryServiceConfig } from 'vs/platform/telemetry/common/telemetryService';\nimport { resolveCommonProperties } from 'vs/platform/telemetry/node/commonProperties';\nimport { getDelayedChannel } from 'vs/base/parts/ipc/common/ipc';\nimport product from 'vs/platform/node/product';\nimport pkg from 'vs/platform/node/package';\nimport { ProxyAuthHandler } from './auth';\nimport { IDisposable, dispose } from 'vs/base/common/lifecycle';\nimport { ConfigurationService } from 'vs/platform/configuration/node/configurationService';\nimport { TPromise } from 'vs/base/common/winjs.base';\nimport { IWindowsMainService } from 'vs/platform/windows/electron-main/windows';\nimport { IHistoryMainService } from 'vs/platform/history/common/history';\nimport { isUndefinedOrNull } from 'vs/base/common/types';\nimport { CodeWindow } from 'vs/code/electron-main/window';\nimport { KeyboardLayoutMonitor } from 'vs/code/electron-main/keyboard';\nimport URI from 'vs/base/common/uri';\nimport { WorkspacesChannel } from 'vs/platform/workspaces/common/workspacesIpc';\nimport { IWorkspacesMainService } from 'vs/platform/workspaces/common/workspaces';\nimport { getMachineId } from 'vs/base/node/id';\nimport { Win32UpdateService } from 'vs/platform/update/electron-main/updateService.win32';\nimport { LinuxUpdateService } from 'vs/platform/update/electron-main/updateService.linux';\nimport { DarwinUpdateService } from 'vs/platform/update/electron-main/updateService.darwin';\nimport { IIssueService } from 'vs/platform/issue/common/issue';\nimport { IssueChannel } from 'vs/platform/issue/common/issueIpc';\nimport { IssueService } from 'vs/platform/issue/electron-main/issueService';\nimport { LogLevelSetterChannel } from 'vs/platform/log/common/logIpc';\nimport { setUnexpectedErrorHandler } from 'vs/base/common/errors';\nimport { ElectronURLListener } from 'vs/platform/url/electron-main/electronUrlListener';\nimport { serve as serveDriver } from 'vs/platform/driver/electron-main/driver';\n\nexport class CodeApplication {\n\n\tprivate static readonly MACHINE_ID_KEY = 'telemetry.machineId';\n\n\tprivate toDispose: IDisposable[];\n\tprivate windowsMainService: IWindowsMainService;\n\n\tprivate electronIpcServer: ElectronIPCServer;\n\n\tprivate sharedProcess: SharedProcess;\n\tprivate sharedProcessClient: TPromise<Client>;\n\n\tconstructor(\n\t\tprivate mainIpcServer: Server,\n\t\tprivate userEnv: platform.IProcessEnvironment,\n\t\t@IInstantiationService private instantiationService: IInstantiationService,\n\t\t@ILogService private logService: ILogService,\n\t\t@IEnvironmentService private environmentService: IEnvironmentService,\n\t\t@ILifecycleService private lifecycleService: ILifecycleService,\n\t\t@IConfigurationService configurationService: ConfigurationService,\n\t\t@IStateService private stateService: IStateService,\n\t\t@IHistoryMainService private historyMainService: IHistoryMainService\n\t) {\n\t\tthis.toDispose = [mainIpcServer, configurationService];\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\n\t\t// We handle uncaught exceptions here to prevent electron from opening a dialog to the user\n\t\tsetUnexpectedErrorHandler(err => this.onUnexpectedError(err));\n\t\tprocess.on('uncaughtException', err => this.onUnexpectedError(err));\n\n\t\tapp.on('will-quit', () => {\n\t\t\tthis.logService.trace('App#will-quit: disposing resources');\n\n\t\t\tthis.dispose();\n\t\t});\n\n\t\tapp.on('accessibility-support-changed', (event: Event, accessibilitySupportEnabled: boolean) => {\n\t\t\tif (this.windowsMainService) {\n\t\t\t\tthis.windowsMainService.sendToAll('vscode:accessibilitySupportChanged', accessibilitySupportEnabled);\n\t\t\t}\n\t\t});\n\n\t\tapp.on('activate', (event: Event, hasVisibleWindows: boolean) => {\n\t\t\tthis.logService.trace('App#activate');\n\n\t\t\t// Mac only event: open new window when we get activated\n\t\t\tif (!hasVisibleWindows && this.windowsMainService) {\n\t\t\t\tthis.windowsMainService.openNewWindow(OpenContext.DOCK);\n\t\t\t}\n\t\t});\n\n\t\tconst isValidWebviewSource = (source: string): boolean => {\n\t\t\tif (!source) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (source === 'data:text/html;charset=utf-8,%3C%21DOCTYPE%20html%3E%0D%0A%3Chtml%20lang%3D%22en%22%20style%3D%22width%3A%20100%25%3B%20height%3A%20100%25%22%3E%0D%0A%3Chead%3E%0D%0A%09%3Ctitle%3EVirtual%20Document%3C%2Ftitle%3E%0D%0A%3C%2Fhead%3E%0D%0A%3Cbody%20style%3D%22margin%3A%200%3B%20overflow%3A%20hidden%3B%20width%3A%20100%25%3B%20height%3A%20100%25%22%3E%0D%0A%3C%2Fbody%3E%0D%0A%3C%2Fhtml%3E') {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tconst srcUri: any = URI.parse(source.toLowerCase()).toString();\n\t\t\treturn srcUri.startsWith(URI.file(this.environmentService.appRoot.toLowerCase()).toString());\n\t\t};\n\n\t\tapp.on('web-contents-created', (event: any, contents) => {\n\t\t\tcontents.on('will-attach-webview', (event: Electron.Event, webPreferences, params) => {\n\t\t\t\tdelete webPreferences.preload;\n\t\t\t\twebPreferences.nodeIntegration = false;\n\n\t\t\t\t// Verify URLs being loaded\n\t\t\t\tif (isValidWebviewSource(params.src) && isValidWebviewSource(webPreferences.preloadURL)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Otherwise prevent loading\n\t\t\t\tthis.logService.error('webContents#web-contents-created: Prevented webview attach');\n\t\t\t\tevent.preventDefault();\n\t\t\t});\n\n\t\t\tcontents.on('will-navigate', event => {\n\t\t\t\tthis.logService.error('webContents#will-navigate: Prevented webcontent navigation');\n\t\t\t\tevent.preventDefault();\n\t\t\t});\n\t\t});\n\n\t\tlet macOpenFiles: string[] = [];\n\t\tlet runningTimeout: number = null;\n\t\tapp.on('open-file', (event: Event, path: string) => {\n\t\t\tthis.logService.trace('App#open-file: ', path);\n\t\t\tevent.preventDefault();\n\n\t\t\t// Keep in array because more might come!\n\t\t\tmacOpenFiles.push(path);\n\n\t\t\t// Clear previous handler if any\n\t\t\tif (runningTimeout !== null) {\n\t\t\t\tclearTimeout(runningTimeout);\n\t\t\t\trunningTimeout = null;\n\t\t\t}\n\n\t\t\t// Handle paths delayed in case more are coming!\n\t\t\trunningTimeout = setTimeout(() => {\n\t\t\t\tif (this.windowsMainService) {\n\t\t\t\t\tthis.windowsMainService.open({\n\t\t\t\t\t\tcontext: OpenContext.DOCK /* can also be opening from finder while app is running */,\n\t\t\t\t\t\tcli: this.environmentService.args,\n\t\t\t\t\t\tpathsToOpen: macOpenFiles,\n\t\t\t\t\t\tpreferNewWindow: true /* dropping on the dock or opening from finder prefers to open in a new window */\n\t\t\t\t\t});\n\t\t\t\t\tmacOpenFiles = [];\n\t\t\t\t\trunningTimeout = null;\n\t\t\t\t}\n\t\t\t}, 100);\n\t\t});\n\n\t\tapp.on('new-window-for-tab', () => {\n\t\t\tthis.windowsMainService.openNewWindow(OpenContext.DESKTOP); //macOS native tab \"+\" button\n\t\t});\n\n\t\tipc.on('vscode:exit', (event: any, code: number) => {\n\t\t\tthis.logService.trace('IPC#vscode:exit', code);\n\n\t\t\tthis.dispose();\n\t\t\tthis.lifecycleService.kill(code);\n\t\t});\n\n\t\tipc.on('vscode:fetchShellEnv', event => {\n\t\t\tconst webContents = event.sender.webContents;\n\t\t\tgetShellEnvironment().then(shellEnv => {\n\t\t\t\tif (!webContents.isDestroyed()) {\n\t\t\t\t\twebContents.send('vscode:acceptShellEnv', shellEnv);\n\t\t\t\t}\n\t\t\t}, err => {\n\t\t\t\tif (!webContents.isDestroyed()) {\n\t\t\t\t\twebContents.send('vscode:acceptShellEnv', {});\n\t\t\t\t}\n\n\t\t\t\tthis.logService.error('Error fetching shell env', err);\n\t\t\t});\n\t\t});\n\n\t\tipc.on('vscode:broadcast', (event: any, windowId: number, broadcast: { channel: string; payload: any; }) => {\n\t\t\tif (this.windowsMainService && broadcast.channel && !isUndefinedOrNull(broadcast.payload)) {\n\t\t\t\tthis.logService.trace('IPC#vscode:broadcast', broadcast.channel, broadcast.payload);\n\n\t\t\t\t// Handle specific events on main side\n\t\t\t\tthis.onBroadcast(broadcast.channel, broadcast.payload);\n\n\t\t\t\t// Send to all windows (except sender window)\n\t\t\t\tthis.windowsMainService.sendToAll('vscode:broadcast', broadcast, [windowId]);\n\t\t\t}\n\t\t});\n\n\t\t// Keyboard layout changes\n\t\tKeyboardLayoutMonitor.INSTANCE.onDidChangeKeyboardLayout(() => {\n\t\t\tif (this.windowsMainService) {\n\t\t\t\tthis.windowsMainService.sendToAll('vscode:keyboardLayoutChanged', false);\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate onUnexpectedError(err: Error): void {\n\t\tif (err) {\n\n\t\t\t// take only the message and stack property\n\t\t\tconst friendlyError = {\n\t\t\t\tmessage: err.message,\n\t\t\t\tstack: err.stack\n\t\t\t};\n\n\t\t\t// handle on client side\n\t\t\tif (this.windowsMainService) {\n\t\t\t\tthis.windowsMainService.sendToFocused('vscode:reportError', JSON.stringify(friendlyError));\n\t\t\t}\n\t\t}\n\n\t\tthis.logService.error(`[uncaught exception in main]: ${err}`);\n\t\tif (err.stack) {\n\t\t\tthis.logService.error(err.stack);\n\t\t}\n\t}\n\n\tprivate onBroadcast(event: string, payload: any): void {\n\n\t\t// Theme changes\n\t\tif (event === 'vscode:changeColorTheme' && typeof payload === 'string') {\n\t\t\tlet data = JSON.parse(payload);\n\n\t\t\tthis.stateService.setItem(CodeWindow.themeStorageKey, data.id);\n\t\t\tthis.stateService.setItem(CodeWindow.themeBackgroundStorageKey, data.background);\n\t\t}\n\t}\n\n\tpublic startup(): TPromise<void> {\n\t\tthis.logService.debug('Starting VS Code');\n\t\tthis.logService.debug(`from: ${this.environmentService.appRoot}`);\n\t\tthis.logService.debug('args:', this.environmentService.args);\n\n\t\t// Make sure we associate the program with the app user model id\n\t\t// This will help Windows to associate the running program with\n\t\t// any shortcut that is pinned to the taskbar and prevent showing\n\t\t// two icons in the taskbar for the same app.\n\t\tif (platform.isWindows && product.win32AppUserModelId) {\n\t\t\tapp.setAppUserModelId(product.win32AppUserModelId);\n\t\t}\n\n\t\t// Create Electron IPC Server\n\t\tthis.electronIpcServer = new ElectronIPCServer();\n\n\t\t// Resolve unique machine ID\n\t\tthis.logService.trace('Resolving machine identifier...');\n\t\treturn this.resolveMachineId().then(machineId => {\n\t\t\tthis.logService.trace(`Resolved machine identifier: ${machineId}`);\n\n\t\t\t// Spawn shared process\n\t\t\tthis.sharedProcess = new SharedProcess(this.environmentService, this.lifecycleService, this.logService, machineId, this.userEnv);\n\t\t\tthis.sharedProcessClient = this.sharedProcess.whenReady().then(() => connect(this.environmentService.sharedIPCHandle, 'main'));\n\n\t\t\t// Services\n\t\t\tconst appInstantiationService = this.initServices(machineId);\n\n\t\t\tlet promise: TPromise<any> = TPromise.as(null);\n\n\t\t\t// Create driver\n\t\t\tif (this.environmentService.driverHandle) {\n\t\t\t\tserveDriver(this.electronIpcServer, this.environmentService.driverHandle, this.environmentService, appInstantiationService).then(server => {\n\t\t\t\t\tthis.logService.info('Driver started at:', this.environmentService.driverHandle);\n\t\t\t\t\tthis.toDispose.push(server);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn promise.then(() => {\n\n\t\t\t\t// Setup Auth Handler\n\t\t\t\tconst authHandler = appInstantiationService.createInstance(ProxyAuthHandler);\n\t\t\t\tthis.toDispose.push(authHandler);\n\n\t\t\t\t// Open Windows\n\t\t\t\tappInstantiationService.invokeFunction(accessor => this.openFirstWindow(accessor));\n\n\t\t\t\t// Post Open Windows Tasks\n\t\t\t\tappInstantiationService.invokeFunction(accessor => this.afterWindowOpen(accessor));\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate resolveMachineId(): TPromise<string> {\n\t\tconst machineId = this.stateService.getItem<string>(CodeApplication.MACHINE_ID_KEY);\n\t\tif (machineId) {\n\t\t\treturn TPromise.wrap(machineId);\n\t\t}\n\n\t\treturn getMachineId().then(machineId => {\n\n\t\t\t// Remember in global storage\n\t\t\tthis.stateService.setItem(CodeApplication.MACHINE_ID_KEY, machineId);\n\n\t\t\treturn machineId;\n\t\t});\n\t}\n\n\tprivate initServices(machineId: string): IInstantiationService {\n\t\tconst services = new ServiceCollection();\n\n\t\tif (process.platform === 'win32') {\n\t\t\tservices.set(IUpdateService, new SyncDescriptor(Win32UpdateService));\n\t\t} else if (process.platform === 'linux') {\n\t\t\tservices.set(IUpdateService, new SyncDescriptor(LinuxUpdateService));\n\t\t} else if (process.platform === 'darwin') {\n\t\t\tservices.set(IUpdateService, new SyncDescriptor(DarwinUpdateService));\n\t\t}\n\n\t\tservices.set(IWindowsMainService, new SyncDescriptor(WindowsManager, machineId));\n\t\tservices.set(IWindowsService, new SyncDescriptor(WindowsService, this.sharedProcess));\n\t\tservices.set(ILaunchService, new SyncDescriptor(LaunchService));\n\t\tservices.set(IIssueService, new SyncDescriptor(IssueService, machineId, this.userEnv));\n\n\t\t// Telemtry\n\t\tif (this.environmentService.isBuilt && !this.environmentService.isExtensionDevelopment && !this.environmentService.args['disable-telemetry'] && !!product.enableTelemetry) {\n\t\t\tconst channel = getDelayedChannel<ITelemetryAppenderChannel>(this.sharedProcessClient.then(c => c.getChannel('telemetryAppender')));\n\t\t\tconst appender = new TelemetryAppenderClient(channel);\n\t\t\tconst commonProperties = resolveCommonProperties(product.commit, pkg.version, machineId, this.environmentService.installSourcePath);\n\t\t\tconst piiPaths = [this.environmentService.appRoot, this.environmentService.extensionsPath];\n\t\t\tconst config: ITelemetryServiceConfig = { appender, commonProperties, piiPaths };\n\n\t\t\tservices.set(ITelemetryService, new SyncDescriptor(TelemetryService, config));\n\t\t} else {\n\t\t\tservices.set(ITelemetryService, NullTelemetryService);\n\t\t}\n\n\t\treturn this.instantiationService.createChild(services);\n\t}\n\n\tprivate openFirstWindow(accessor: ServicesAccessor): void {\n\t\tconst appInstantiationService = accessor.get(IInstantiationService);\n\n\t\t// Register more Main IPC services\n\t\tconst launchService = accessor.get(ILaunchService);\n\t\tconst launchChannel = new LaunchChannel(launchService);\n\t\tthis.mainIpcServer.registerChannel('launch', launchChannel);\n\n\t\t// Register more Electron IPC services\n\t\tconst updateService = accessor.get(IUpdateService);\n\t\tconst updateChannel = new UpdateChannel(updateService);\n\t\tthis.electronIpcServer.registerChannel('update', updateChannel);\n\n\t\tconst issueService = accessor.get(IIssueService);\n\t\tconst issueChannel = new IssueChannel(issueService);\n\t\tthis.electronIpcServer.registerChannel('issue', issueChannel);\n\n\t\tconst workspacesService = accessor.get(IWorkspacesMainService);\n\t\tconst workspacesChannel = appInstantiationService.createInstance(WorkspacesChannel, workspacesService);\n\t\tthis.electronIpcServer.registerChannel('workspaces', workspacesChannel);\n\n\t\tconst windowsService = accessor.get(IWindowsService);\n\t\tconst windowsChannel = new WindowsChannel(windowsService);\n\t\tthis.electronIpcServer.registerChannel('windows', windowsChannel);\n\t\tthis.sharedProcessClient.done(client => client.registerChannel('windows', windowsChannel));\n\n\t\tconst urlService = accessor.get(IURLService);\n\t\tconst urlChannel = new URLServiceChannel(urlService);\n\t\tthis.electronIpcServer.registerChannel('url', urlChannel);\n\n\t\t// Log level management\n\t\tconst logLevelChannel = new LogLevelSetterChannel(accessor.get(ILogService));\n\t\tthis.electronIpcServer.registerChannel('loglevel', logLevelChannel);\n\t\tthis.sharedProcessClient.done(client => client.registerChannel('loglevel', logLevelChannel));\n\n\t\t// Lifecycle\n\t\tthis.lifecycleService.ready();\n\n\t\t// Propagate to clients\n\t\tconst windowsMainService = this.windowsMainService = accessor.get(IWindowsMainService); // TODO@Joao: unfold this\n\n\t\tconst args = this.environmentService.args;\n\n\t\t// Create a URL handler which forwards to the last active window\n\t\tconst activeWindowManager = new ActiveWindowManager(windowsService);\n\t\tconst urlHandlerChannel = this.electronIpcServer.getChannel('urlHandler', { route: () => activeWindowManager.activeClientId });\n\t\tconst multiplexURLHandler = new URLHandlerChannelClient(urlHandlerChannel);\n\n\t\t// On Mac, Code can be running without any open windows, so we must create a window to handle urls,\n\t\t// if there is none\n\t\tif (platform.isMacintosh) {\n\t\t\tconst environmentService = accessor.get(IEnvironmentService);\n\n\t\t\turlService.registerHandler({\n\t\t\t\tasync handleURL(uri: URI): TPromise<boolean> {\n\t\t\t\t\tif (windowsMainService.getWindowCount() === 0) {\n\t\t\t\t\t\tconst cli = { ...environmentService.args, goto: true };\n\t\t\t\t\t\tconst [window] = windowsMainService.open({ context: OpenContext.API, cli, forceEmpty: true });\n\n\t\t\t\t\t\treturn window.ready().then(() => urlService.open(uri));\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// Register the multiple URL handker\n\t\turlService.registerHandler(multiplexURLHandler);\n\n\t\t// Watch Electron URLs and forward them to the UrlService\n\t\tconst urls = args['open-url'] ? args._urls : [];\n\t\tconst urlListener = new ElectronURLListener(urls, urlService, this.windowsMainService);\n\t\tthis.toDispose.push(urlListener);\n\n\t\tthis.windowsMainService.ready(this.userEnv);\n\n\t\t// Open our first window\n\t\tconst macOpenFiles = (<any>global).macOpenFiles as string[];\n\t\tconst context = !!process.env['VSCODE_CLI'] ? OpenContext.CLI : OpenContext.DESKTOP;\n\t\tif (args['new-window'] && args._.length === 0) {\n\t\t\tthis.windowsMainService.open({ context, cli: args, forceNewWindow: true, forceEmpty: true, initialStartup: true }); // new window if \"-n\" was used without paths\n\t\t} else if (macOpenFiles && macOpenFiles.length && (!args._ || !args._.length)) {\n\t\t\tthis.windowsMainService.open({ context: OpenContext.DOCK, cli: args, pathsToOpen: macOpenFiles, initialStartup: true }); // mac: open-file event received on startup\n\t\t} else {\n\t\t\tthis.windowsMainService.open({ context, cli: args, forceNewWindow: args['new-window'] || (!args._.length && args['unity-launch']), diffMode: args.diff, initialStartup: true }); // default: read paths from cli\n\t\t}\n\t}\n\n\tprivate afterWindowOpen(accessor: ServicesAccessor): void {\n\t\tconst appInstantiationService = accessor.get(IInstantiationService);\n\t\tconst windowsMainService = accessor.get(IWindowsMainService);\n\n\t\tlet windowsMutex: Mutex = null;\n\t\tif (platform.isWindows) {\n\n\t\t\t// Setup Windows mutex\n\t\t\ttry {\n\t\t\t\tconst Mutex = (require.__$__nodeRequire('windows-mutex') as any).Mutex;\n\t\t\t\twindowsMutex = new Mutex(product.win32MutexName);\n\t\t\t\tthis.toDispose.push({ dispose: () => windowsMutex.release() });\n\t\t\t} catch (e) {\n\t\t\t\tif (!this.environmentService.isBuilt) {\n\t\t\t\t\twindowsMainService.showMessageBox({\n\t\t\t\t\t\ttitle: product.nameLong,\n\t\t\t\t\t\ttype: 'warning',\n\t\t\t\t\t\tmessage: 'Failed to load windows-mutex!',\n\t\t\t\t\t\tdetail: e.toString(),\n\t\t\t\t\t\tnoLink: true\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Ensure Windows foreground love module\n\t\t\ttry {\n\t\t\t\t// tslint:disable-next-line:no-unused-expression\n\t\t\t\t<any>require.__$__nodeRequire('windows-foreground-love');\n\t\t\t} catch (e) {\n\t\t\t\tif (!this.environmentService.isBuilt) {\n\t\t\t\t\twindowsMainService.showMessageBox({\n\t\t\t\t\t\ttitle: product.nameLong,\n\t\t\t\t\t\ttype: 'warning',\n\t\t\t\t\t\tmessage: 'Failed to load windows-foreground-love!',\n\t\t\t\t\t\tdetail: e.toString(),\n\t\t\t\t\t\tnoLink: true\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Install Menu\n\t\tappInstantiationService.createInstance(CodeMenu);\n\n\t\t// Jump List\n\t\tthis.historyMainService.updateWindowsJumpList();\n\t\tthis.historyMainService.onRecentlyOpenedChange(() => this.historyMainService.updateWindowsJumpList());\n\n\t\t// Start shared process here\n\t\tthis.sharedProcess.spawn();\n\t}\n\n\tprivate dispose(): void {\n\t\tthis.toDispose = dispose(this.toDispose);\n\t}\n}\n",
            "linguagem": "ts",
            "total_linhas": 505
        },
        "solucao_humana": {
            "patch_diff": "@@ -494,8 +494,8 @@ export class CodeApplication {\n \t\tthis.historyMainService.updateWindowsJumpList();\n \t\tthis.historyMainService.onRecentlyOpenedChange(() => this.historyMainService.updateWindowsJumpList());\n \n-\t\t// Start shared process here\n-\t\tthis.sharedProcess.spawn();\n+\t\t// Start shared process after a while\n+\t\tTPromise.timeout(3000).then(() => this.sharedProcess.spawn());\n \t}\n \n \tprivate dispose(): void {",
            "apenas_linhas_adicionadas": [
                "\t\t// Start shared process after a while",
                "\t\tTPromise.timeout(3000).then(() => this.sharedProcess.spawn());"
            ]
        }
    },
    {
        "id": 54320,
        "url": "https://github.com/microsoft/vscode/pull/54320",
        "arquivo_caminho": "src/vs/base/browser/ui/selectBox/selectBoxCustom.ts",
        "descricao_bug": "Fixes: #54292\r\n\r\nCalculation for drop-down needs to use offsetWidth on the parent select to not include\r\nmargins.",
        "contexto": {
            "codigo_completo_bugado": "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport 'vs/css!./selectBoxCustom';\n\nimport * as nls from 'vs/nls';\nimport { IDisposable, dispose } from 'vs/base/common/lifecycle';\nimport { Event, Emitter, chain } from 'vs/base/common/event';\nimport { KeyCode, KeyCodeUtils } from 'vs/base/common/keyCodes';\nimport { StandardKeyboardEvent } from 'vs/base/browser/keyboardEvent';\nimport * as dom from 'vs/base/browser/dom';\nimport * as arrays from 'vs/base/common/arrays';\nimport { IContextViewProvider, AnchorPosition } from 'vs/base/browser/ui/contextview/contextview';\nimport { List } from 'vs/base/browser/ui/list/listWidget';\nimport { IVirtualDelegate, IRenderer } from 'vs/base/browser/ui/list/list';\nimport { domEvent } from 'vs/base/browser/event';\nimport { ScrollbarVisibility } from 'vs/base/common/scrollable';\nimport { ISelectBoxDelegate, ISelectBoxOptions, ISelectBoxStyles, ISelectData } from 'vs/base/browser/ui/selectBox/selectBox';\nimport { isMacintosh } from 'vs/base/common/platform';\n\nconst $ = dom.$;\n\nconst SELECT_OPTION_ENTRY_TEMPLATE_ID = 'selectOption.entry.template';\n\nexport interface ISelectOptionItem {\n\toptionText: string;\n\toptionDisabled: boolean;\n}\n\ninterface ISelectListTemplateData {\n\troot: HTMLElement;\n\toptionText: HTMLElement;\n\tdisposables: IDisposable[];\n}\n\nclass SelectListRenderer implements IRenderer<ISelectOptionItem, ISelectListTemplateData> {\n\n\tget templateId(): string { return SELECT_OPTION_ENTRY_TEMPLATE_ID; }\n\n\tconstructor() { }\n\n\trenderTemplate(container: HTMLElement): any {\n\t\tconst data = <ISelectListTemplateData>Object.create(null);\n\t\tdata.disposables = [];\n\t\tdata.root = container;\n\t\tdata.optionText = dom.append(container, $('.option-text'));\n\n\t\treturn data;\n\t}\n\n\trenderElement(element: ISelectOptionItem, index: number, templateData: ISelectListTemplateData): void {\n\t\tconst data = <ISelectListTemplateData>templateData;\n\t\tconst optionText = (<ISelectOptionItem>element).optionText;\n\t\tconst optionDisabled = (<ISelectOptionItem>element).optionDisabled;\n\n\t\tdata.optionText.textContent = optionText;\n\t\tdata.root.setAttribute('aria-label', nls.localize('selectAriaOption', \"{0}\", optionText));\n\n\t\t// pseudo-select disabled option\n\t\tif (optionDisabled) {\n\t\t\tdom.addClass((<HTMLElement>data.root), 'option-disabled');\n\t\t} else {\n\t\t\t// Make sure we do class removal from prior template rendering\n\t\t\tdom.removeClass((<HTMLElement>data.root), 'option-disabled');\n\t\t}\n\t}\n\n\tdisposeElement(): void {\n\t\t// noop\n\t}\n\n\tdisposeTemplate(templateData: ISelectListTemplateData): void {\n\t\ttemplateData.disposables = dispose(templateData.disposables);\n\t}\n}\n\nexport class SelectBoxList implements ISelectBoxDelegate, IVirtualDelegate<ISelectOptionItem> {\n\n\tprivate static readonly DEFAULT_DROPDOWN_MINIMUM_BOTTOM_MARGIN = 32;\n\tprivate static readonly DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN = 42;\n\tprivate static readonly DEFAULT_MINIMUM_VISIBLE_OPTIONS = 3;\n\n\tprivate _isVisible: boolean;\n\tprivate selectBoxOptions: ISelectBoxOptions;\n\tprivate selectElement: HTMLSelectElement;\n\tprivate options: string[];\n\tprivate selected: number;\n\tprivate disabledOptionIndex: number;\n\tprivate readonly _onDidSelect: Emitter<ISelectData>;\n\tprivate toDispose: IDisposable[];\n\tprivate styles: ISelectBoxStyles;\n\tprivate listRenderer: SelectListRenderer;\n\tprivate contextViewProvider: IContextViewProvider;\n\tprivate selectDropDownContainer: HTMLElement;\n\tprivate styleElement: HTMLStyleElement;\n\tprivate selectList: List<ISelectOptionItem>;\n\tprivate selectDropDownListContainer: HTMLElement;\n\tprivate widthControlElement: HTMLElement;\n\tprivate _currentSelection: number;\n\tprivate _dropDownPosition: AnchorPosition;\n\n\tconstructor(options: string[], selected: number, contextViewProvider: IContextViewProvider, styles: ISelectBoxStyles, selectBoxOptions?: ISelectBoxOptions) {\n\n\t\tthis.toDispose = [];\n\t\tthis._isVisible = false;\n\t\tthis.selectBoxOptions = selectBoxOptions || Object.create(null);\n\n\t\tif (typeof this.selectBoxOptions.minBottomMargin !== 'number') {\n\t\t\tthis.selectBoxOptions.minBottomMargin = SelectBoxList.DEFAULT_DROPDOWN_MINIMUM_BOTTOM_MARGIN;\n\t\t} else if (this.selectBoxOptions.minBottomMargin < 0) {\n\t\t\tthis.selectBoxOptions.minBottomMargin = 0;\n\t\t}\n\n\t\tthis.selectElement = document.createElement('select');\n\t\t// Use custom CSS vars for padding calculation\n\t\tthis.selectElement.className = 'monaco-select-box monaco-select-box-dropdown-padding';\n\n\t\tthis._onDidSelect = new Emitter<ISelectData>();\n\t\tthis.styles = styles;\n\n\t\tthis.registerListeners();\n\t\tthis.constructSelectDropDown(contextViewProvider);\n\n\t\tthis.setOptions(options, selected);\n\t}\n\n\t// IDelegate - List renderer\n\n\tgetHeight(): number {\n\t\treturn 18;\n\t}\n\n\tgetTemplateId(): string {\n\t\treturn SELECT_OPTION_ENTRY_TEMPLATE_ID;\n\t}\n\n\tprivate constructSelectDropDown(contextViewProvider: IContextViewProvider) {\n\n\t\t// SetUp ContextView container to hold select Dropdown\n\t\tthis.contextViewProvider = contextViewProvider;\n\t\tthis.selectDropDownContainer = dom.$('.monaco-select-box-dropdown-container');\n\t\t// Use custom CSS vars for padding calculation (shared with parent select)\n\t\tdom.addClass(this.selectDropDownContainer, 'monaco-select-box-dropdown-padding');\n\t\t// Setup list for drop-down select\n\t\tthis.createSelectList(this.selectDropDownContainer);\n\n\t\t// Create span flex box item/div we can measure and control\n\t\tlet widthControlOuterDiv = dom.append(this.selectDropDownContainer, $('.select-box-dropdown-container-width-control'));\n\t\tlet widthControlInnerDiv = dom.append(widthControlOuterDiv, $('.width-control-div'));\n\t\tthis.widthControlElement = document.createElement('span');\n\t\tthis.widthControlElement.className = 'option-text-width-control';\n\t\tdom.append(widthControlInnerDiv, this.widthControlElement);\n\n\t\t// Always default to below position\n\t\tthis._dropDownPosition = AnchorPosition.BELOW;\n\n\t\t// Inline stylesheet for themes\n\t\tthis.styleElement = dom.createStyleSheet(this.selectDropDownContainer);\n\t}\n\n\tprivate registerListeners() {\n\n\t\t// Parent native select keyboard listeners\n\n\t\tthis.toDispose.push(dom.addStandardDisposableListener(this.selectElement, 'change', (e) => {\n\t\t\tthis.selectElement.title = e.target.value;\n\t\t\tthis._onDidSelect.fire({\n\t\t\t\tindex: e.target.selectedIndex,\n\t\t\t\tselected: e.target.value\n\t\t\t});\n\t\t}));\n\n\t\t// Have to implement both keyboard and mouse controllers to handle disabled options\n\t\t// Intercept mouse events to override normal select actions on parents\n\n\t\tthis.toDispose.push(dom.addDisposableListener(this.selectElement, dom.EventType.CLICK, (e) => {\n\t\t\tdom.EventHelper.stop(e);\n\n\t\t\tif (this._isVisible) {\n\t\t\t\tthis.hideSelectDropDown(true);\n\t\t\t} else {\n\t\t\t\tthis.showSelectDropDown();\n\t\t\t}\n\t\t}));\n\n\t\tthis.toDispose.push(dom.addDisposableListener(this.selectElement, dom.EventType.MOUSE_DOWN, (e) => {\n\t\t\tdom.EventHelper.stop(e);\n\t\t}));\n\n\t\t// Intercept keyboard handling\n\n\t\tthis.toDispose.push(dom.addDisposableListener(this.selectElement, dom.EventType.KEY_DOWN, (e: KeyboardEvent) => {\n\t\t\tconst event = new StandardKeyboardEvent(e);\n\t\t\tlet showDropDown = false;\n\n\t\t\t// Create and drop down select list on keyboard select\n\t\t\tif (isMacintosh) {\n\t\t\t\tif (event.keyCode === KeyCode.DownArrow || event.keyCode === KeyCode.UpArrow || event.keyCode === KeyCode.Space || event.keyCode === KeyCode.Enter) {\n\t\t\t\t\tshowDropDown = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (event.keyCode === KeyCode.DownArrow && event.altKey || event.keyCode === KeyCode.UpArrow && event.altKey || event.keyCode === KeyCode.Space || event.keyCode === KeyCode.Enter) {\n\t\t\t\t\tshowDropDown = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (showDropDown) {\n\t\t\t\tthis.showSelectDropDown();\n\t\t\t\tdom.EventHelper.stop(e);\n\t\t\t}\n\t\t}));\n\t}\n\n\tpublic get onDidSelect(): Event<ISelectData> {\n\t\treturn this._onDidSelect.event;\n\t}\n\n\tpublic setOptions(options: string[], selected?: number, disabled?: number): void {\n\n\t\tif (!this.options || !arrays.equals(this.options, options)) {\n\t\t\tthis.options = options;\n\t\t\tthis.selectElement.options.length = 0;\n\n\t\t\tlet i = 0;\n\t\t\tthis.options.forEach((option) => {\n\t\t\t\tthis.selectElement.add(this.createOption(option, i, disabled === i++));\n\t\t\t});\n\n\t\t\t// Mirror options in drop-down\n\t\t\t// Populate select list for non-native select mode\n\t\t\tif (this.selectList && !!this.options) {\n\t\t\t\tlet listEntries: ISelectOptionItem[];\n\n\t\t\t\tlistEntries = [];\n\t\t\t\tif (disabled !== undefined) {\n\t\t\t\t\tthis.disabledOptionIndex = disabled;\n\t\t\t\t}\n\t\t\t\tfor (let index = 0; index < this.options.length; index++) {\n\t\t\t\t\tconst element = this.options[index];\n\t\t\t\t\tlet optionDisabled: boolean;\n\t\t\t\t\tindex === this.disabledOptionIndex ? optionDisabled = true : optionDisabled = false;\n\t\t\t\t\tlistEntries.push({ optionText: element, optionDisabled: optionDisabled });\n\t\t\t\t}\n\n\t\t\t\tthis.selectList.splice(0, this.selectList.length, listEntries);\n\t\t\t}\n\t\t}\n\n\t\tif (selected !== undefined) {\n\t\t\tthis.select(selected);\n\t\t\t// Set current = selected since this is not necessarily a user exit\n\t\t\tthis._currentSelection = this.selected;\n\t\t}\n\t}\n\n\tpublic select(index: number): void {\n\n\t\tif (index >= 0 && index < this.options.length) {\n\t\t\tthis.selected = index;\n\t\t} else if (index > this.options.length - 1) {\n\t\t\t// Adjust index to end of list\n\t\t\t// This could make client out of sync with the select\n\t\t\tthis.select(this.options.length - 1);\n\t\t} else if (this.selected < 0) {\n\t\t\tthis.selected = 0;\n\t\t}\n\n\t\tthis.selectElement.selectedIndex = this.selected;\n\t\tthis.selectElement.title = this.options[this.selected];\n\t}\n\n\tpublic focus(): void {\n\t\tif (this.selectElement) {\n\t\t\tthis.selectElement.focus();\n\t\t}\n\t}\n\n\tpublic blur(): void {\n\t\tif (this.selectElement) {\n\t\t\tthis.selectElement.blur();\n\t\t}\n\t}\n\n\tpublic render(container: HTMLElement): void {\n\t\tdom.addClass(container, 'select-container');\n\t\tcontainer.appendChild(this.selectElement);\n\t\tthis.setOptions(this.options, this.selected);\n\t\tthis.applyStyles();\n\t}\n\n\tpublic style(styles: ISelectBoxStyles): void {\n\n\t\tconst content: string[] = [];\n\n\t\tthis.styles = styles;\n\n\t\t// Style non-native select mode\n\n\t\tif (this.styles.listFocusBackground) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.focused { background-color: ${this.styles.listFocusBackground} !important; }`);\n\t\t}\n\n\t\tif (this.styles.listFocusForeground) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.focused:not(:hover) { color: ${this.styles.listFocusForeground} !important; }`);\n\t\t}\n\n\t\t// Hover foreground - ignore for disabled options\n\t\tif (this.styles.listHoverForeground) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:hover { color: ${this.styles.listHoverForeground} !important; }`);\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.option-disabled:hover { background-color: ${this.styles.listActiveSelectionForeground} !important; }`);\n\t\t}\n\n\t\t// Hover background - ignore for disabled options\n\t\tif (this.styles.listHoverBackground) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:not(.option-disabled):not(.focused):hover { background-color: ${this.styles.listHoverBackground} !important; }`);\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.option-disabled:hover { background-color: ${this.styles.selectBackground} !important; }`);\n\t\t}\n\n\t\t// Match quickOpen outline styles - ignore for disabled options\n\t\tif (this.styles.listFocusOutline) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.focused { outline: 1.6px dotted ${this.styles.listFocusOutline} !important; outline-offset: -1.6px !important; }`);\n\t\t}\n\n\t\tif (this.styles.listHoverOutline) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:hover:not(.focused) { outline: 1.6px dashed ${this.styles.listHoverOutline} !important; outline-offset: -1.6px !important; }`);\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.option-disabled:hover { outline: none !important; }`);\n\t\t}\n\n\t\tthis.styleElement.innerHTML = content.join('\\n');\n\n\t\tthis.applyStyles();\n\t}\n\n\tpublic applyStyles(): void {\n\n\t\t// Style parent select\n\n\t\tlet background = null;\n\n\t\tif (this.selectElement) {\n\t\t\tbackground = this.styles.selectBackground ? this.styles.selectBackground.toString() : null;\n\t\t\tconst foreground = this.styles.selectForeground ? this.styles.selectForeground.toString() : null;\n\t\t\tconst border = this.styles.selectBorder ? this.styles.selectBorder.toString() : null;\n\n\t\t\tthis.selectElement.style.backgroundColor = background;\n\t\t\tthis.selectElement.style.color = foreground;\n\t\t\tthis.selectElement.style.borderColor = border;\n\t\t}\n\n\t\t// Style drop down select list (non-native mode only)\n\n\t\tif (this.selectList) {\n\t\t\tthis.selectList.style({});\n\n\t\t\tlet listBackground = this.styles.selectListBackground ? this.styles.selectListBackground.toString() : background;\n\t\t\tthis.selectDropDownListContainer.style.backgroundColor = listBackground;\n\t\t\tconst optionsBorder = this.styles.focusBorder ? this.styles.focusBorder.toString() : null;\n\t\t\tthis.selectDropDownContainer.style.outlineColor = optionsBorder;\n\t\t\tthis.selectDropDownContainer.style.outlineOffset = '-1px';\n\t\t}\n\t}\n\n\tprivate createOption(value: string, index: number, disabled?: boolean): HTMLOptionElement {\n\t\tlet option = document.createElement('option');\n\t\toption.value = value;\n\t\toption.text = value;\n\t\toption.disabled = disabled;\n\n\t\treturn option;\n\t}\n\n\t// ContextView dropdown methods\n\n\tprivate showSelectDropDown() {\n\t\tif (!this.contextViewProvider || this._isVisible) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Set drop-down position above/below from required height and margins\n\t\tthis.layoutSelectDropDown(true);\n\n\t\tthis._isVisible = true;\n\t\tthis.cloneElementFont(this.selectElement, this.selectDropDownContainer);\n\n\t\tthis.contextViewProvider.showContextView({\n\t\t\tgetAnchor: () => this.selectElement,\n\t\t\trender: (container: HTMLElement) => this.renderSelectDropDown(container),\n\t\t\tlayout: () => this.layoutSelectDropDown(),\n\t\t\tonHide: () => {\n\t\t\t\tdom.toggleClass(this.selectDropDownContainer, 'visible', false);\n\t\t\t\tdom.toggleClass(this.selectElement, 'synthetic-focus', false);\n\t\t\t},\n\t\t\tanchorPosition: this._dropDownPosition\n\t\t});\n\n\t\t// Track initial selection the case user escape, blur\n\t\tthis._currentSelection = this.selected;\n\t}\n\n\tprivate hideSelectDropDown(focusSelect: boolean) {\n\t\tif (!this.contextViewProvider || !this._isVisible) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._isVisible = false;\n\n\t\tif (focusSelect) {\n\t\t\tthis.selectElement.focus();\n\t\t}\n\t\tthis.contextViewProvider.hideContextView();\n\t}\n\n\tprivate renderSelectDropDown(container: HTMLElement): IDisposable {\n\t\tcontainer.appendChild(this.selectDropDownContainer);\n\n\t\tthis.layoutSelectDropDown();\n\t\treturn {\n\t\t\tdispose: () => container.removeChild(this.selectDropDownContainer) // remove to take out the CSS rules we add\n\t\t};\n\t}\n\n\tprivate layoutSelectDropDown(preLayoutPosition?: boolean) {\n\n\t\t// Layout ContextView drop down select list and container\n\t\t// Have to manage our vertical overflow, sizing, position below or above\n\t\t// Position has to be determined and set prior to contextView instantiation\n\n\t\tif (this.selectList) {\n\n\t\t\tconst selectPosition = dom.getDomNodePagePosition(this.selectElement);\n\t\t\tconst styles = getComputedStyle(this.selectElement);\n\t\t\tconst verticalPadding = parseFloat(styles.getPropertyValue('--dropdown-padding-top')) + parseFloat(styles.getPropertyValue('--dropdown-padding-bottom'));\n\t\t\tlet maxSelectDropDownHeight = 0;\n\t\t\tmaxSelectDropDownHeight = (window.innerHeight - selectPosition.top - selectPosition.height - this.selectBoxOptions.minBottomMargin);\n\n\t\t\tthis.selectList.layout();\n\t\t\tlet listHeight = this.selectList.contentHeight;\n\n\t\t\t// If we are only doing pre-layout check/adjust position only\n\t\t\t// Calculate vertical space available, flip up if insufficient\n\t\t\t// Use reflected padding on parent select, ContextView style properties not available before DOM attachment\n\t\t\tif (preLayoutPosition) {\n\n\t\t\t\t// Always show complete list items - never more than Max available vertical height\n\t\t\t\tif (listHeight + verticalPadding > maxSelectDropDownHeight) {\n\t\t\t\t\tconst maxVisibleOptions = ((Math.floor((maxSelectDropDownHeight - verticalPadding) / this.getHeight())));\n\n\t\t\t\t\t// Check if we can at least show min items otherwise flip above\n\t\t\t\t\tif (maxVisibleOptions < SelectBoxList.DEFAULT_MINIMUM_VISIBLE_OPTIONS) {\n\t\t\t\t\t\tthis._dropDownPosition = AnchorPosition.ABOVE;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._dropDownPosition = AnchorPosition.BELOW;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Do full layout on showSelectDropDown only\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Make visible to enable measurements\n\t\t\tdom.toggleClass(this.selectDropDownContainer, 'visible', true);\n\n\t\t\t// SetUp list dimensions and layout - account for container padding\n\t\t\t// Use position to check above or below available space\n\t\t\tif (this._dropDownPosition === AnchorPosition.BELOW) {\n\t\t\t\t// Set container height to max from select bottom to margin (default/minBottomMargin)\n\t\t\t\tif (listHeight + verticalPadding > maxSelectDropDownHeight) {\n\t\t\t\t\tlistHeight = ((Math.floor((maxSelectDropDownHeight - verticalPadding) / this.getHeight())) * this.getHeight());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Set container height to max from select top to margin (default/minTopMargin)\n\t\t\t\tmaxSelectDropDownHeight = (selectPosition.top - SelectBoxList.DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN);\n\t\t\t\tif (listHeight + verticalPadding > maxSelectDropDownHeight) {\n\t\t\t\t\tlistHeight = ((Math.floor((maxSelectDropDownHeight - SelectBoxList.DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN) / this.getHeight())) * this.getHeight());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set adjusted list height and relayout\n\t\t\tthis.selectList.layout(listHeight);\n\t\t\tthis.selectList.domFocus();\n\n\t\t\t// Finally set focus on selected item\n\t\t\tif (this.selectList.length > 0) {\n\t\t\t\tthis.selectList.setFocus([this.selected || 0]);\n\t\t\t\tthis.selectList.reveal(this.selectList.getFocus()[0] || 0);\n\t\t\t}\n\n\t\t\t// Set final container height after adjustments\n\t\t\tthis.selectDropDownContainer.style.height = (listHeight + verticalPadding) + 'px';\n\n\t\t\t// Determine optimal width - min(longest option), opt(parent select), max(ContextView controlled)\n\t\t\tconst selectWidth = dom.getTotalWidth(this.selectElement);\n\t\t\tconst selectMinWidth = this.setWidthControlElement(this.widthControlElement);\n\t\t\tconst selectOptimalWidth = Math.max(selectMinWidth, Math.round(selectWidth)).toString() + 'px';\n\n\t\t\tthis.selectDropDownContainer.style.width = selectOptimalWidth;\n\n\t\t\t// Maintain focus outline on parent select as well as list container - tabindex for focus\n\t\t\tthis.selectDropDownListContainer.setAttribute('tabindex', '0');\n\t\t\tdom.toggleClass(this.selectElement, 'synthetic-focus', true);\n\t\t\tdom.toggleClass(this.selectDropDownContainer, 'synthetic-focus', true);\n\t\t}\n\t}\n\n\tprivate setWidthControlElement(container: HTMLElement): number {\n\t\tlet elementWidth = 0;\n\n\t\tif (container && !!this.options) {\n\t\t\tlet longest = 0;\n\n\t\t\tfor (let index = 0; index < this.options.length; index++) {\n\t\t\t\tif (this.options[index].length > this.options[longest].length) {\n\t\t\t\t\tlongest = index;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcontainer.innerHTML = this.options[longest];\n\t\t\telementWidth = dom.getTotalWidth(container);\n\t\t}\n\n\t\treturn elementWidth;\n\t}\n\n\tprivate cloneElementFont(source: HTMLElement, target: HTMLElement) {\n\t\tconst fontSize = window.getComputedStyle(source, null).getPropertyValue('font-size');\n\t\tconst fontFamily = window.getComputedStyle(source, null).getPropertyValue('font-family');\n\t\ttarget.style.fontFamily = fontFamily;\n\t\ttarget.style.fontSize = fontSize;\n\t}\n\n\tprivate createSelectList(parent: HTMLElement): void {\n\n\t\t// SetUp container for list\n\t\tthis.selectDropDownListContainer = dom.append(parent, $('.select-box-dropdown-list-container'));\n\n\t\tthis.listRenderer = new SelectListRenderer();\n\n\t\tthis.selectList = new List(this.selectDropDownListContainer, this, [this.listRenderer], {\n\t\t\tuseShadows: false,\n\t\t\tselectOnMouseDown: false,\n\t\t\tverticalScrollMode: ScrollbarVisibility.Visible,\n\t\t\tkeyboardSupport: false,\n\t\t\tmouseSupport: false\n\t\t});\n\n\t\t// SetUp list keyboard controller - control navigation, disabled items, focus\n\t\tconst onSelectDropDownKeyDown = chain(domEvent(this.selectDropDownListContainer, 'keydown'))\n\t\t\t.filter(() => this.selectList.length > 0)\n\t\t\t.map(e => new StandardKeyboardEvent(e));\n\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.Enter).on(e => this.onEnter(e), this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.Escape).on(e => this.onEscape(e), this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.UpArrow).on(this.onUpArrow, this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.DownArrow).on(this.onDownArrow, this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.PageDown).on(this.onPageDown, this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.PageUp).on(this.onPageUp, this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.Home).on(this.onHome, this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.End).on(this.onEnd, this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => (e.keyCode >= KeyCode.KEY_0 && e.keyCode <= KeyCode.KEY_Z) || (e.keyCode >= KeyCode.US_SEMICOLON && e.keyCode <= KeyCode.NUMPAD_DIVIDE)).on(this.onCharacter, this, this.toDispose);\n\n\t\t// SetUp list mouse controller - control navigation, disabled items, focus\n\n\t\tchain(domEvent(this.selectList.getHTMLElement(), 'mouseup'))\n\t\t\t.filter(() => this.selectList.length > 0)\n\t\t\t.on(e => this.onMouseUp(e), this, this.toDispose);\n\n\t\tthis.toDispose.push(this.selectList.onDidBlur(e => this.onListBlur()));\n\t}\n\n\t// List methods\n\n\t// List mouse controller - active exit, select option, fire onDidSelect if change, return focus to parent select\n\tprivate onMouseUp(e: MouseEvent): void {\n\n\t\tdom.EventHelper.stop(e);\n\n\t\t// Check our mouse event is on an option (not scrollbar)\n\t\tif (!e.toElement.classList.contains('option-text')) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst listRowElement = e.toElement.parentElement;\n\t\tconst index = Number(listRowElement.getAttribute('data-index'));\n\t\tconst disabled = listRowElement.classList.contains('option-disabled');\n\n\t\t// Ignore mouse selection of disabled options\n\t\tif (index >= 0 && index < this.options.length && !disabled) {\n\t\t\tthis.selected = index;\n\t\t\tthis.select(this.selected);\n\n\t\t\tthis.selectList.setFocus([this.selected]);\n\t\t\tthis.selectList.reveal(this.selectList.getFocus()[0]);\n\n\t\t\t// Only fire if selection change\n\t\t\tif (this.selected !== this._currentSelection) {\n\t\t\t\t// Set current = selected\n\t\t\t\tthis._currentSelection = this.selected;\n\n\t\t\t\tthis._onDidSelect.fire({\n\t\t\t\t\tindex: this.selectElement.selectedIndex,\n\t\t\t\t\tselected: this.selectElement.title\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthis.hideSelectDropDown(true);\n\t\t}\n\t}\n\n\t// List Exit - passive - implicit no selection change, hide drop-down\n\tprivate onListBlur(): void {\n\n\t\tif (this.selected !== this._currentSelection) {\n\t\t\t// Reset selected to current if no change\n\t\t\tthis.select(this._currentSelection);\n\t\t}\n\n\t\tthis.hideSelectDropDown(false);\n\t}\n\n\t// List keyboard controller\n\n\t// List exit - active - hide ContextView dropdown, reset selection, return focus to parent select\n\tprivate onEscape(e: StandardKeyboardEvent): void {\n\t\tdom.EventHelper.stop(e);\n\n\t\t// Reset selection to value when opened\n\t\tthis.select(this._currentSelection);\n\t\tthis.hideSelectDropDown(true);\n\t}\n\n\t// List exit - active - hide ContextView dropdown, return focus to parent select, fire onDidSelect if change\n\tprivate onEnter(e: StandardKeyboardEvent): void {\n\t\tdom.EventHelper.stop(e);\n\n\t\t// Only fire if selection change\n\t\tif (this.selected !== this._currentSelection) {\n\t\t\tthis._currentSelection = this.selected;\n\t\t\tthis._onDidSelect.fire({\n\t\t\t\tindex: this.selectElement.selectedIndex,\n\t\t\t\tselected: this.selectElement.title\n\t\t\t});\n\t\t}\n\n\t\tthis.hideSelectDropDown(true);\n\t}\n\n\t// List navigation - have to handle a disabled option (jump over)\n\tprivate onDownArrow(): void {\n\t\tif (this.selected < this.options.length - 1) {\n\t\t\t// Skip disabled options\n\t\t\tif ((this.selected + 1) === this.disabledOptionIndex && this.options.length > this.selected + 2) {\n\t\t\t\tthis.selected += 2;\n\t\t\t} else {\n\t\t\t\tthis.selected++;\n\t\t\t}\n\t\t\t// Set focus/selection - only fire event when closing drop-down or on blur\n\t\t\tthis.select(this.selected);\n\t\t\tthis.selectList.setFocus([this.selected]);\n\t\t\tthis.selectList.reveal(this.selectList.getFocus()[0]);\n\t\t}\n\t}\n\n\tprivate onUpArrow(): void {\n\t\tif (this.selected > 0) {\n\t\t\t// Skip disabled options\n\t\t\tif ((this.selected - 1) === this.disabledOptionIndex && this.selected > 1) {\n\t\t\t\tthis.selected -= 2;\n\t\t\t} else {\n\t\t\t\tthis.selected--;\n\t\t\t}\n\t\t\t// Set focus/selection - only fire event when closing drop-down or on blur\n\t\t\tthis.select(this.selected);\n\t\t\tthis.selectList.setFocus([this.selected]);\n\t\t\tthis.selectList.reveal(this.selectList.getFocus()[0]);\n\t\t}\n\t}\n\n\tprivate onPageUp(e: StandardKeyboardEvent): void {\n\t\tdom.EventHelper.stop(e);\n\n\t\tthis.selectList.focusPreviousPage();\n\n\t\t// Allow scrolling to settle\n\t\tsetTimeout(() => {\n\t\t\tthis.selected = this.selectList.getFocus()[0];\n\n\t\t\t// Shift selection down if we land on a disabled option\n\t\t\tif (this.selected === this.disabledOptionIndex && this.selected < this.options.length - 1) {\n\t\t\t\tthis.selected++;\n\t\t\t\tthis.selectList.setFocus([this.selected]);\n\t\t\t}\n\t\t\tthis.selectList.reveal(this.selected);\n\t\t\tthis.select(this.selected);\n\t\t}, 1);\n\t}\n\n\tprivate onPageDown(e: StandardKeyboardEvent): void {\n\t\tdom.EventHelper.stop(e);\n\n\t\tthis.selectList.focusNextPage();\n\n\t\t// Allow scrolling to settle\n\t\tsetTimeout(() => {\n\t\t\tthis.selected = this.selectList.getFocus()[0];\n\n\t\t\t// Shift selection up if we land on a disabled option\n\t\t\tif (this.selected === this.disabledOptionIndex && this.selected > 0) {\n\t\t\t\tthis.selected--;\n\t\t\t\tthis.selectList.setFocus([this.selected]);\n\t\t\t}\n\t\t\tthis.selectList.reveal(this.selected);\n\t\t\tthis.select(this.selected);\n\t\t}, 1);\n\t}\n\n\tprivate onHome(e: StandardKeyboardEvent): void {\n\t\tdom.EventHelper.stop(e);\n\n\t\tif (this.options.length < 2) {\n\t\t\treturn;\n\t\t}\n\t\tthis.selected = 0;\n\t\tif (this.selected === this.disabledOptionIndex && this.selected > 1) {\n\t\t\tthis.selected++;\n\t\t}\n\t\tthis.selectList.setFocus([this.selected]);\n\t\tthis.selectList.reveal(this.selected);\n\t\tthis.select(this.selected);\n\t}\n\n\tprivate onEnd(e: StandardKeyboardEvent): void {\n\t\tdom.EventHelper.stop(e);\n\n\t\tif (this.options.length < 2) {\n\t\t\treturn;\n\t\t}\n\t\tthis.selected = this.options.length - 1;\n\t\tif (this.selected === this.disabledOptionIndex && this.selected > 1) {\n\t\t\tthis.selected--;\n\t\t}\n\t\tthis.selectList.setFocus([this.selected]);\n\t\tthis.selectList.reveal(this.selected);\n\t\tthis.select(this.selected);\n\t}\n\n\t// Mimic option first character navigation of native select\n\tprivate onCharacter(e: StandardKeyboardEvent): void {\n\t\tconst ch = KeyCodeUtils.toString(e.keyCode);\n\t\tlet optionIndex = -1;\n\n\t\tfor (let i = 0; i < this.options.length - 1; i++) {\n\t\t\toptionIndex = (i + this.selected + 1) % this.options.length;\n\t\t\tif (this.options[optionIndex].charAt(0).toUpperCase() === ch) {\n\t\t\t\tthis.select(optionIndex);\n\t\t\t\tthis.selectList.setFocus([optionIndex]);\n\t\t\t\tthis.selectList.reveal(this.selectList.getFocus()[0]);\n\t\t\t\tdom.EventHelper.stop(e);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic dispose(): void {\n\t\tthis.hideSelectDropDown(false);\n\t\tthis.toDispose = dispose(this.toDispose);\n\t}\n}\n",
            "linguagem": "ts",
            "total_linhas": 769
        },
        "solucao_humana": {
            "patch_diff": "@@ -489,8 +489,8 @@ export class SelectBoxList implements ISelectBoxDelegate, IVirtualDelegate<ISele\n \t\t\t// Set final container height after adjustments\n \t\t\tthis.selectDropDownContainer.style.height = (listHeight + verticalPadding) + 'px';\n \n-\t\t\t// Determine optimal width - min(longest option), opt(parent select), max(ContextView controlled)\n-\t\t\tconst selectWidth = dom.getTotalWidth(this.selectElement);\n+\t\t\t// Determine optimal width - min(longest option), opt(parent select, excluding margins), max(ContextView controlled)\n+\t\t\tconst selectWidth = this.selectElement.offsetWidth;\n \t\t\tconst selectMinWidth = this.setWidthControlElement(this.widthControlElement);\n \t\t\tconst selectOptimalWidth = Math.max(selectMinWidth, Math.round(selectWidth)).toString() + 'px';\n ",
            "apenas_linhas_adicionadas": [
                "\t\t\t// Determine optimal width - min(longest option), opt(parent select, excluding margins), max(ContextView controlled)",
                "\t\t\tconst selectWidth = this.selectElement.offsetWidth;"
            ]
        }
    },
    {
        "id": 54321,
        "url": "https://github.com/microsoft/vscode/pull/54321",
        "arquivo_caminho": "src/vs/base/browser/ui/selectBox/selectBoxCustom.ts",
        "descricao_bug": "#54296 \r\n\r\nCatch and ignore exception on duplicate child removal when base contextView has already\r\ndisposed and removed child on focus change.",
        "contexto": {
            "codigo_completo_bugado": "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport 'vs/css!./selectBoxCustom';\n\nimport * as nls from 'vs/nls';\nimport { IDisposable, dispose } from 'vs/base/common/lifecycle';\nimport { Event, Emitter, chain } from 'vs/base/common/event';\nimport { KeyCode, KeyCodeUtils } from 'vs/base/common/keyCodes';\nimport { StandardKeyboardEvent } from 'vs/base/browser/keyboardEvent';\nimport * as dom from 'vs/base/browser/dom';\nimport * as arrays from 'vs/base/common/arrays';\nimport { IContextViewProvider, AnchorPosition } from 'vs/base/browser/ui/contextview/contextview';\nimport { List } from 'vs/base/browser/ui/list/listWidget';\nimport { IVirtualDelegate, IRenderer } from 'vs/base/browser/ui/list/list';\nimport { domEvent } from 'vs/base/browser/event';\nimport { ScrollbarVisibility } from 'vs/base/common/scrollable';\nimport { ISelectBoxDelegate, ISelectBoxOptions, ISelectBoxStyles, ISelectData } from 'vs/base/browser/ui/selectBox/selectBox';\nimport { isMacintosh } from 'vs/base/common/platform';\n\nconst $ = dom.$;\n\nconst SELECT_OPTION_ENTRY_TEMPLATE_ID = 'selectOption.entry.template';\n\nexport interface ISelectOptionItem {\n\toptionText: string;\n\toptionDisabled: boolean;\n}\n\ninterface ISelectListTemplateData {\n\troot: HTMLElement;\n\toptionText: HTMLElement;\n\tdisposables: IDisposable[];\n}\n\nclass SelectListRenderer implements IRenderer<ISelectOptionItem, ISelectListTemplateData> {\n\n\tget templateId(): string { return SELECT_OPTION_ENTRY_TEMPLATE_ID; }\n\n\tconstructor() { }\n\n\trenderTemplate(container: HTMLElement): any {\n\t\tconst data = <ISelectListTemplateData>Object.create(null);\n\t\tdata.disposables = [];\n\t\tdata.root = container;\n\t\tdata.optionText = dom.append(container, $('.option-text'));\n\n\t\treturn data;\n\t}\n\n\trenderElement(element: ISelectOptionItem, index: number, templateData: ISelectListTemplateData): void {\n\t\tconst data = <ISelectListTemplateData>templateData;\n\t\tconst optionText = (<ISelectOptionItem>element).optionText;\n\t\tconst optionDisabled = (<ISelectOptionItem>element).optionDisabled;\n\n\t\tdata.optionText.textContent = optionText;\n\t\tdata.root.setAttribute('aria-label', nls.localize('selectAriaOption', \"{0}\", optionText));\n\n\t\t// pseudo-select disabled option\n\t\tif (optionDisabled) {\n\t\t\tdom.addClass((<HTMLElement>data.root), 'option-disabled');\n\t\t} else {\n\t\t\t// Make sure we do class removal from prior template rendering\n\t\t\tdom.removeClass((<HTMLElement>data.root), 'option-disabled');\n\t\t}\n\t}\n\n\tdisposeElement(): void {\n\t\t// noop\n\t}\n\n\tdisposeTemplate(templateData: ISelectListTemplateData): void {\n\t\ttemplateData.disposables = dispose(templateData.disposables);\n\t}\n}\n\nexport class SelectBoxList implements ISelectBoxDelegate, IVirtualDelegate<ISelectOptionItem> {\n\n\tprivate static readonly DEFAULT_DROPDOWN_MINIMUM_BOTTOM_MARGIN = 32;\n\tprivate static readonly DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN = 42;\n\tprivate static readonly DEFAULT_MINIMUM_VISIBLE_OPTIONS = 3;\n\n\tprivate _isVisible: boolean;\n\tprivate selectBoxOptions: ISelectBoxOptions;\n\tprivate selectElement: HTMLSelectElement;\n\tprivate options: string[];\n\tprivate selected: number;\n\tprivate disabledOptionIndex: number;\n\tprivate readonly _onDidSelect: Emitter<ISelectData>;\n\tprivate toDispose: IDisposable[];\n\tprivate styles: ISelectBoxStyles;\n\tprivate listRenderer: SelectListRenderer;\n\tprivate contextViewProvider: IContextViewProvider;\n\tprivate selectDropDownContainer: HTMLElement;\n\tprivate styleElement: HTMLStyleElement;\n\tprivate selectList: List<ISelectOptionItem>;\n\tprivate selectDropDownListContainer: HTMLElement;\n\tprivate widthControlElement: HTMLElement;\n\tprivate _currentSelection: number;\n\tprivate _dropDownPosition: AnchorPosition;\n\n\tconstructor(options: string[], selected: number, contextViewProvider: IContextViewProvider, styles: ISelectBoxStyles, selectBoxOptions?: ISelectBoxOptions) {\n\n\t\tthis.toDispose = [];\n\t\tthis._isVisible = false;\n\t\tthis.selectBoxOptions = selectBoxOptions || Object.create(null);\n\n\t\tif (typeof this.selectBoxOptions.minBottomMargin !== 'number') {\n\t\t\tthis.selectBoxOptions.minBottomMargin = SelectBoxList.DEFAULT_DROPDOWN_MINIMUM_BOTTOM_MARGIN;\n\t\t} else if (this.selectBoxOptions.minBottomMargin < 0) {\n\t\t\tthis.selectBoxOptions.minBottomMargin = 0;\n\t\t}\n\n\t\tthis.selectElement = document.createElement('select');\n\t\t// Use custom CSS vars for padding calculation\n\t\tthis.selectElement.className = 'monaco-select-box monaco-select-box-dropdown-padding';\n\n\t\tthis._onDidSelect = new Emitter<ISelectData>();\n\t\tthis.styles = styles;\n\n\t\tthis.registerListeners();\n\t\tthis.constructSelectDropDown(contextViewProvider);\n\n\t\tthis.setOptions(options, selected);\n\t}\n\n\t// IDelegate - List renderer\n\n\tgetHeight(): number {\n\t\treturn 18;\n\t}\n\n\tgetTemplateId(): string {\n\t\treturn SELECT_OPTION_ENTRY_TEMPLATE_ID;\n\t}\n\n\tprivate constructSelectDropDown(contextViewProvider: IContextViewProvider) {\n\n\t\t// SetUp ContextView container to hold select Dropdown\n\t\tthis.contextViewProvider = contextViewProvider;\n\t\tthis.selectDropDownContainer = dom.$('.monaco-select-box-dropdown-container');\n\t\t// Use custom CSS vars for padding calculation (shared with parent select)\n\t\tdom.addClass(this.selectDropDownContainer, 'monaco-select-box-dropdown-padding');\n\t\t// Setup list for drop-down select\n\t\tthis.createSelectList(this.selectDropDownContainer);\n\n\t\t// Create span flex box item/div we can measure and control\n\t\tlet widthControlOuterDiv = dom.append(this.selectDropDownContainer, $('.select-box-dropdown-container-width-control'));\n\t\tlet widthControlInnerDiv = dom.append(widthControlOuterDiv, $('.width-control-div'));\n\t\tthis.widthControlElement = document.createElement('span');\n\t\tthis.widthControlElement.className = 'option-text-width-control';\n\t\tdom.append(widthControlInnerDiv, this.widthControlElement);\n\n\t\t// Always default to below position\n\t\tthis._dropDownPosition = AnchorPosition.BELOW;\n\n\t\t// Inline stylesheet for themes\n\t\tthis.styleElement = dom.createStyleSheet(this.selectDropDownContainer);\n\t}\n\n\tprivate registerListeners() {\n\n\t\t// Parent native select keyboard listeners\n\n\t\tthis.toDispose.push(dom.addStandardDisposableListener(this.selectElement, 'change', (e) => {\n\t\t\tthis.selectElement.title = e.target.value;\n\t\t\tthis._onDidSelect.fire({\n\t\t\t\tindex: e.target.selectedIndex,\n\t\t\t\tselected: e.target.value\n\t\t\t});\n\t\t}));\n\n\t\t// Have to implement both keyboard and mouse controllers to handle disabled options\n\t\t// Intercept mouse events to override normal select actions on parents\n\n\t\tthis.toDispose.push(dom.addDisposableListener(this.selectElement, dom.EventType.CLICK, (e) => {\n\t\t\tdom.EventHelper.stop(e);\n\n\t\t\tif (this._isVisible) {\n\t\t\t\tthis.hideSelectDropDown(true);\n\t\t\t} else {\n\t\t\t\tthis.showSelectDropDown();\n\t\t\t}\n\t\t}));\n\n\t\tthis.toDispose.push(dom.addDisposableListener(this.selectElement, dom.EventType.MOUSE_DOWN, (e) => {\n\t\t\tdom.EventHelper.stop(e);\n\t\t}));\n\n\t\t// Intercept keyboard handling\n\n\t\tthis.toDispose.push(dom.addDisposableListener(this.selectElement, dom.EventType.KEY_DOWN, (e: KeyboardEvent) => {\n\t\t\tconst event = new StandardKeyboardEvent(e);\n\t\t\tlet showDropDown = false;\n\n\t\t\t// Create and drop down select list on keyboard select\n\t\t\tif (isMacintosh) {\n\t\t\t\tif (event.keyCode === KeyCode.DownArrow || event.keyCode === KeyCode.UpArrow || event.keyCode === KeyCode.Space || event.keyCode === KeyCode.Enter) {\n\t\t\t\t\tshowDropDown = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (event.keyCode === KeyCode.DownArrow && event.altKey || event.keyCode === KeyCode.UpArrow && event.altKey || event.keyCode === KeyCode.Space || event.keyCode === KeyCode.Enter) {\n\t\t\t\t\tshowDropDown = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (showDropDown) {\n\t\t\t\tthis.showSelectDropDown();\n\t\t\t\tdom.EventHelper.stop(e);\n\t\t\t}\n\t\t}));\n\t}\n\n\tpublic get onDidSelect(): Event<ISelectData> {\n\t\treturn this._onDidSelect.event;\n\t}\n\n\tpublic setOptions(options: string[], selected?: number, disabled?: number): void {\n\n\t\tif (!this.options || !arrays.equals(this.options, options)) {\n\t\t\tthis.options = options;\n\t\t\tthis.selectElement.options.length = 0;\n\n\t\t\tlet i = 0;\n\t\t\tthis.options.forEach((option) => {\n\t\t\t\tthis.selectElement.add(this.createOption(option, i, disabled === i++));\n\t\t\t});\n\n\t\t\t// Mirror options in drop-down\n\t\t\t// Populate select list for non-native select mode\n\t\t\tif (this.selectList && !!this.options) {\n\t\t\t\tlet listEntries: ISelectOptionItem[];\n\n\t\t\t\tlistEntries = [];\n\t\t\t\tif (disabled !== undefined) {\n\t\t\t\t\tthis.disabledOptionIndex = disabled;\n\t\t\t\t}\n\t\t\t\tfor (let index = 0; index < this.options.length; index++) {\n\t\t\t\t\tconst element = this.options[index];\n\t\t\t\t\tlet optionDisabled: boolean;\n\t\t\t\t\tindex === this.disabledOptionIndex ? optionDisabled = true : optionDisabled = false;\n\t\t\t\t\tlistEntries.push({ optionText: element, optionDisabled: optionDisabled });\n\t\t\t\t}\n\n\t\t\t\tthis.selectList.splice(0, this.selectList.length, listEntries);\n\t\t\t}\n\t\t}\n\n\t\tif (selected !== undefined) {\n\t\t\tthis.select(selected);\n\t\t\t// Set current = selected since this is not necessarily a user exit\n\t\t\tthis._currentSelection = this.selected;\n\t\t}\n\t}\n\n\tpublic select(index: number): void {\n\n\t\tif (index >= 0 && index < this.options.length) {\n\t\t\tthis.selected = index;\n\t\t} else if (index > this.options.length - 1) {\n\t\t\t// Adjust index to end of list\n\t\t\t// This could make client out of sync with the select\n\t\t\tthis.select(this.options.length - 1);\n\t\t} else if (this.selected < 0) {\n\t\t\tthis.selected = 0;\n\t\t}\n\n\t\tthis.selectElement.selectedIndex = this.selected;\n\t\tthis.selectElement.title = this.options[this.selected];\n\t}\n\n\tpublic focus(): void {\n\t\tif (this.selectElement) {\n\t\t\tthis.selectElement.focus();\n\t\t}\n\t}\n\n\tpublic blur(): void {\n\t\tif (this.selectElement) {\n\t\t\tthis.selectElement.blur();\n\t\t}\n\t}\n\n\tpublic render(container: HTMLElement): void {\n\t\tdom.addClass(container, 'select-container');\n\t\tcontainer.appendChild(this.selectElement);\n\t\tthis.setOptions(this.options, this.selected);\n\t\tthis.applyStyles();\n\t}\n\n\tpublic style(styles: ISelectBoxStyles): void {\n\n\t\tconst content: string[] = [];\n\n\t\tthis.styles = styles;\n\n\t\t// Style non-native select mode\n\n\t\tif (this.styles.listFocusBackground) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.focused { background-color: ${this.styles.listFocusBackground} !important; }`);\n\t\t}\n\n\t\tif (this.styles.listFocusForeground) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.focused:not(:hover) { color: ${this.styles.listFocusForeground} !important; }`);\n\t\t}\n\n\t\t// Hover foreground - ignore for disabled options\n\t\tif (this.styles.listHoverForeground) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:hover { color: ${this.styles.listHoverForeground} !important; }`);\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.option-disabled:hover { background-color: ${this.styles.listActiveSelectionForeground} !important; }`);\n\t\t}\n\n\t\t// Hover background - ignore for disabled options\n\t\tif (this.styles.listHoverBackground) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:not(.option-disabled):not(.focused):hover { background-color: ${this.styles.listHoverBackground} !important; }`);\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.option-disabled:hover { background-color: ${this.styles.selectBackground} !important; }`);\n\t\t}\n\n\t\t// Match quickOpen outline styles - ignore for disabled options\n\t\tif (this.styles.listFocusOutline) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.focused { outline: 1.6px dotted ${this.styles.listFocusOutline} !important; outline-offset: -1.6px !important; }`);\n\t\t}\n\n\t\tif (this.styles.listHoverOutline) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:hover:not(.focused) { outline: 1.6px dashed ${this.styles.listHoverOutline} !important; outline-offset: -1.6px !important; }`);\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.option-disabled:hover { outline: none !important; }`);\n\t\t}\n\n\t\tthis.styleElement.innerHTML = content.join('\\n');\n\n\t\tthis.applyStyles();\n\t}\n\n\tpublic applyStyles(): void {\n\n\t\t// Style parent select\n\n\t\tlet background = null;\n\n\t\tif (this.selectElement) {\n\t\t\tbackground = this.styles.selectBackground ? this.styles.selectBackground.toString() : null;\n\t\t\tconst foreground = this.styles.selectForeground ? this.styles.selectForeground.toString() : null;\n\t\t\tconst border = this.styles.selectBorder ? this.styles.selectBorder.toString() : null;\n\n\t\t\tthis.selectElement.style.backgroundColor = background;\n\t\t\tthis.selectElement.style.color = foreground;\n\t\t\tthis.selectElement.style.borderColor = border;\n\t\t}\n\n\t\t// Style drop down select list (non-native mode only)\n\n\t\tif (this.selectList) {\n\t\t\tthis.selectList.style({});\n\n\t\t\tlet listBackground = this.styles.selectListBackground ? this.styles.selectListBackground.toString() : background;\n\t\t\tthis.selectDropDownListContainer.style.backgroundColor = listBackground;\n\t\t\tconst optionsBorder = this.styles.focusBorder ? this.styles.focusBorder.toString() : null;\n\t\t\tthis.selectDropDownContainer.style.outlineColor = optionsBorder;\n\t\t\tthis.selectDropDownContainer.style.outlineOffset = '-1px';\n\t\t}\n\t}\n\n\tprivate createOption(value: string, index: number, disabled?: boolean): HTMLOptionElement {\n\t\tlet option = document.createElement('option');\n\t\toption.value = value;\n\t\toption.text = value;\n\t\toption.disabled = disabled;\n\n\t\treturn option;\n\t}\n\n\t// ContextView dropdown methods\n\n\tprivate showSelectDropDown() {\n\t\tif (!this.contextViewProvider || this._isVisible) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Set drop-down position above/below from required height and margins\n\t\tthis.layoutSelectDropDown(true);\n\n\t\tthis._isVisible = true;\n\t\tthis.cloneElementFont(this.selectElement, this.selectDropDownContainer);\n\n\t\tthis.contextViewProvider.showContextView({\n\t\t\tgetAnchor: () => this.selectElement,\n\t\t\trender: (container: HTMLElement) => this.renderSelectDropDown(container),\n\t\t\tlayout: () => this.layoutSelectDropDown(),\n\t\t\tonHide: () => {\n\t\t\t\tdom.toggleClass(this.selectDropDownContainer, 'visible', false);\n\t\t\t\tdom.toggleClass(this.selectElement, 'synthetic-focus', false);\n\t\t\t},\n\t\t\tanchorPosition: this._dropDownPosition\n\t\t});\n\n\t\t// Track initial selection the case user escape, blur\n\t\tthis._currentSelection = this.selected;\n\t}\n\n\tprivate hideSelectDropDown(focusSelect: boolean) {\n\t\tif (!this.contextViewProvider || !this._isVisible) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._isVisible = false;\n\n\t\tif (focusSelect) {\n\t\t\tthis.selectElement.focus();\n\t\t}\n\t\tthis.contextViewProvider.hideContextView();\n\t}\n\n\tprivate renderSelectDropDown(container: HTMLElement): IDisposable {\n\t\tcontainer.appendChild(this.selectDropDownContainer);\n\n\t\tthis.layoutSelectDropDown();\n\t\treturn {\n\t\t\tdispose: () => container.removeChild(this.selectDropDownContainer) // remove to take out the CSS rules we add\n\t\t};\n\t}\n\n\tprivate layoutSelectDropDown(preLayoutPosition?: boolean) {\n\n\t\t// Layout ContextView drop down select list and container\n\t\t// Have to manage our vertical overflow, sizing, position below or above\n\t\t// Position has to be determined and set prior to contextView instantiation\n\n\t\tif (this.selectList) {\n\n\t\t\tconst selectPosition = dom.getDomNodePagePosition(this.selectElement);\n\t\t\tconst styles = getComputedStyle(this.selectElement);\n\t\t\tconst verticalPadding = parseFloat(styles.getPropertyValue('--dropdown-padding-top')) + parseFloat(styles.getPropertyValue('--dropdown-padding-bottom'));\n\t\t\tlet maxSelectDropDownHeight = 0;\n\t\t\tmaxSelectDropDownHeight = (window.innerHeight - selectPosition.top - selectPosition.height - this.selectBoxOptions.minBottomMargin);\n\n\t\t\tthis.selectList.layout();\n\t\t\tlet listHeight = this.selectList.contentHeight;\n\n\t\t\t// If we are only doing pre-layout check/adjust position only\n\t\t\t// Calculate vertical space available, flip up if insufficient\n\t\t\t// Use reflected padding on parent select, ContextView style properties not available before DOM attachment\n\t\t\tif (preLayoutPosition) {\n\n\t\t\t\t// Always show complete list items - never more than Max available vertical height\n\t\t\t\tif (listHeight + verticalPadding > maxSelectDropDownHeight) {\n\t\t\t\t\tconst maxVisibleOptions = ((Math.floor((maxSelectDropDownHeight - verticalPadding) / this.getHeight())));\n\n\t\t\t\t\t// Check if we can at least show min items otherwise flip above\n\t\t\t\t\tif (maxVisibleOptions < SelectBoxList.DEFAULT_MINIMUM_VISIBLE_OPTIONS) {\n\t\t\t\t\t\tthis._dropDownPosition = AnchorPosition.ABOVE;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._dropDownPosition = AnchorPosition.BELOW;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Do full layout on showSelectDropDown only\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Make visible to enable measurements\n\t\t\tdom.toggleClass(this.selectDropDownContainer, 'visible', true);\n\n\t\t\t// SetUp list dimensions and layout - account for container padding\n\t\t\t// Use position to check above or below available space\n\t\t\tif (this._dropDownPosition === AnchorPosition.BELOW) {\n\t\t\t\t// Set container height to max from select bottom to margin (default/minBottomMargin)\n\t\t\t\tif (listHeight + verticalPadding > maxSelectDropDownHeight) {\n\t\t\t\t\tlistHeight = ((Math.floor((maxSelectDropDownHeight - verticalPadding) / this.getHeight())) * this.getHeight());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Set container height to max from select top to margin (default/minTopMargin)\n\t\t\t\tmaxSelectDropDownHeight = (selectPosition.top - SelectBoxList.DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN);\n\t\t\t\tif (listHeight + verticalPadding > maxSelectDropDownHeight) {\n\t\t\t\t\tlistHeight = ((Math.floor((maxSelectDropDownHeight - SelectBoxList.DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN) / this.getHeight())) * this.getHeight());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set adjusted list height and relayout\n\t\t\tthis.selectList.layout(listHeight);\n\t\t\tthis.selectList.domFocus();\n\n\t\t\t// Finally set focus on selected item\n\t\t\tif (this.selectList.length > 0) {\n\t\t\t\tthis.selectList.setFocus([this.selected || 0]);\n\t\t\t\tthis.selectList.reveal(this.selectList.getFocus()[0] || 0);\n\t\t\t}\n\n\t\t\t// Set final container height after adjustments\n\t\t\tthis.selectDropDownContainer.style.height = (listHeight + verticalPadding) + 'px';\n\n\t\t\t// Determine optimal width - min(longest option), opt(parent select, excluding margins), max(ContextView controlled)\n\t\t\tconst selectWidth = this.selectElement.offsetWidth;\n\t\t\tconst selectMinWidth = this.setWidthControlElement(this.widthControlElement);\n\t\t\tconst selectOptimalWidth = Math.max(selectMinWidth, Math.round(selectWidth)).toString() + 'px';\n\n\t\t\tthis.selectDropDownContainer.style.width = selectOptimalWidth;\n\n\t\t\t// Maintain focus outline on parent select as well as list container - tabindex for focus\n\t\t\tthis.selectDropDownListContainer.setAttribute('tabindex', '0');\n\t\t\tdom.toggleClass(this.selectElement, 'synthetic-focus', true);\n\t\t\tdom.toggleClass(this.selectDropDownContainer, 'synthetic-focus', true);\n\t\t}\n\t}\n\n\tprivate setWidthControlElement(container: HTMLElement): number {\n\t\tlet elementWidth = 0;\n\n\t\tif (container && !!this.options) {\n\t\t\tlet longest = 0;\n\n\t\t\tfor (let index = 0; index < this.options.length; index++) {\n\t\t\t\tif (this.options[index].length > this.options[longest].length) {\n\t\t\t\t\tlongest = index;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcontainer.innerHTML = this.options[longest];\n\t\t\telementWidth = dom.getTotalWidth(container);\n\t\t}\n\n\t\treturn elementWidth;\n\t}\n\n\tprivate cloneElementFont(source: HTMLElement, target: HTMLElement) {\n\t\tconst fontSize = window.getComputedStyle(source, null).getPropertyValue('font-size');\n\t\tconst fontFamily = window.getComputedStyle(source, null).getPropertyValue('font-family');\n\t\ttarget.style.fontFamily = fontFamily;\n\t\ttarget.style.fontSize = fontSize;\n\t}\n\n\tprivate createSelectList(parent: HTMLElement): void {\n\n\t\t// SetUp container for list\n\t\tthis.selectDropDownListContainer = dom.append(parent, $('.select-box-dropdown-list-container'));\n\n\t\tthis.listRenderer = new SelectListRenderer();\n\n\t\tthis.selectList = new List(this.selectDropDownListContainer, this, [this.listRenderer], {\n\t\t\tuseShadows: false,\n\t\t\tselectOnMouseDown: false,\n\t\t\tverticalScrollMode: ScrollbarVisibility.Visible,\n\t\t\tkeyboardSupport: false,\n\t\t\tmouseSupport: false\n\t\t});\n\n\t\t// SetUp list keyboard controller - control navigation, disabled items, focus\n\t\tconst onSelectDropDownKeyDown = chain(domEvent(this.selectDropDownListContainer, 'keydown'))\n\t\t\t.filter(() => this.selectList.length > 0)\n\t\t\t.map(e => new StandardKeyboardEvent(e));\n\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.Enter).on(e => this.onEnter(e), this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.Escape).on(e => this.onEscape(e), this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.UpArrow).on(this.onUpArrow, this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.DownArrow).on(this.onDownArrow, this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.PageDown).on(this.onPageDown, this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.PageUp).on(this.onPageUp, this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.Home).on(this.onHome, this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.End).on(this.onEnd, this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => (e.keyCode >= KeyCode.KEY_0 && e.keyCode <= KeyCode.KEY_Z) || (e.keyCode >= KeyCode.US_SEMICOLON && e.keyCode <= KeyCode.NUMPAD_DIVIDE)).on(this.onCharacter, this, this.toDispose);\n\n\t\t// SetUp list mouse controller - control navigation, disabled items, focus\n\n\t\tchain(domEvent(this.selectList.getHTMLElement(), 'mouseup'))\n\t\t\t.filter(() => this.selectList.length > 0)\n\t\t\t.on(e => this.onMouseUp(e), this, this.toDispose);\n\n\t\tthis.toDispose.push(this.selectList.onDidBlur(e => this.onListBlur()));\n\t}\n\n\t// List methods\n\n\t// List mouse controller - active exit, select option, fire onDidSelect if change, return focus to parent select\n\tprivate onMouseUp(e: MouseEvent): void {\n\n\t\tdom.EventHelper.stop(e);\n\n\t\t// Check our mouse event is on an option (not scrollbar)\n\t\tif (!e.toElement.classList.contains('option-text')) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst listRowElement = e.toElement.parentElement;\n\t\tconst index = Number(listRowElement.getAttribute('data-index'));\n\t\tconst disabled = listRowElement.classList.contains('option-disabled');\n\n\t\t// Ignore mouse selection of disabled options\n\t\tif (index >= 0 && index < this.options.length && !disabled) {\n\t\t\tthis.selected = index;\n\t\t\tthis.select(this.selected);\n\n\t\t\tthis.selectList.setFocus([this.selected]);\n\t\t\tthis.selectList.reveal(this.selectList.getFocus()[0]);\n\n\t\t\t// Only fire if selection change\n\t\t\tif (this.selected !== this._currentSelection) {\n\t\t\t\t// Set current = selected\n\t\t\t\tthis._currentSelection = this.selected;\n\n\t\t\t\tthis._onDidSelect.fire({\n\t\t\t\t\tindex: this.selectElement.selectedIndex,\n\t\t\t\t\tselected: this.selectElement.title\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthis.hideSelectDropDown(true);\n\t\t}\n\t}\n\n\t// List Exit - passive - implicit no selection change, hide drop-down\n\tprivate onListBlur(): void {\n\n\t\tif (this.selected !== this._currentSelection) {\n\t\t\t// Reset selected to current if no change\n\t\t\tthis.select(this._currentSelection);\n\t\t}\n\n\t\tthis.hideSelectDropDown(false);\n\t}\n\n\t// List keyboard controller\n\n\t// List exit - active - hide ContextView dropdown, reset selection, return focus to parent select\n\tprivate onEscape(e: StandardKeyboardEvent): void {\n\t\tdom.EventHelper.stop(e);\n\n\t\t// Reset selection to value when opened\n\t\tthis.select(this._currentSelection);\n\t\tthis.hideSelectDropDown(true);\n\t}\n\n\t// List exit - active - hide ContextView dropdown, return focus to parent select, fire onDidSelect if change\n\tprivate onEnter(e: StandardKeyboardEvent): void {\n\t\tdom.EventHelper.stop(e);\n\n\t\t// Only fire if selection change\n\t\tif (this.selected !== this._currentSelection) {\n\t\t\tthis._currentSelection = this.selected;\n\t\t\tthis._onDidSelect.fire({\n\t\t\t\tindex: this.selectElement.selectedIndex,\n\t\t\t\tselected: this.selectElement.title\n\t\t\t});\n\t\t}\n\n\t\tthis.hideSelectDropDown(true);\n\t}\n\n\t// List navigation - have to handle a disabled option (jump over)\n\tprivate onDownArrow(): void {\n\t\tif (this.selected < this.options.length - 1) {\n\t\t\t// Skip disabled options\n\t\t\tif ((this.selected + 1) === this.disabledOptionIndex && this.options.length > this.selected + 2) {\n\t\t\t\tthis.selected += 2;\n\t\t\t} else {\n\t\t\t\tthis.selected++;\n\t\t\t}\n\t\t\t// Set focus/selection - only fire event when closing drop-down or on blur\n\t\t\tthis.select(this.selected);\n\t\t\tthis.selectList.setFocus([this.selected]);\n\t\t\tthis.selectList.reveal(this.selectList.getFocus()[0]);\n\t\t}\n\t}\n\n\tprivate onUpArrow(): void {\n\t\tif (this.selected > 0) {\n\t\t\t// Skip disabled options\n\t\t\tif ((this.selected - 1) === this.disabledOptionIndex && this.selected > 1) {\n\t\t\t\tthis.selected -= 2;\n\t\t\t} else {\n\t\t\t\tthis.selected--;\n\t\t\t}\n\t\t\t// Set focus/selection - only fire event when closing drop-down or on blur\n\t\t\tthis.select(this.selected);\n\t\t\tthis.selectList.setFocus([this.selected]);\n\t\t\tthis.selectList.reveal(this.selectList.getFocus()[0]);\n\t\t}\n\t}\n\n\tprivate onPageUp(e: StandardKeyboardEvent): void {\n\t\tdom.EventHelper.stop(e);\n\n\t\tthis.selectList.focusPreviousPage();\n\n\t\t// Allow scrolling to settle\n\t\tsetTimeout(() => {\n\t\t\tthis.selected = this.selectList.getFocus()[0];\n\n\t\t\t// Shift selection down if we land on a disabled option\n\t\t\tif (this.selected === this.disabledOptionIndex && this.selected < this.options.length - 1) {\n\t\t\t\tthis.selected++;\n\t\t\t\tthis.selectList.setFocus([this.selected]);\n\t\t\t}\n\t\t\tthis.selectList.reveal(this.selected);\n\t\t\tthis.select(this.selected);\n\t\t}, 1);\n\t}\n\n\tprivate onPageDown(e: StandardKeyboardEvent): void {\n\t\tdom.EventHelper.stop(e);\n\n\t\tthis.selectList.focusNextPage();\n\n\t\t// Allow scrolling to settle\n\t\tsetTimeout(() => {\n\t\t\tthis.selected = this.selectList.getFocus()[0];\n\n\t\t\t// Shift selection up if we land on a disabled option\n\t\t\tif (this.selected === this.disabledOptionIndex && this.selected > 0) {\n\t\t\t\tthis.selected--;\n\t\t\t\tthis.selectList.setFocus([this.selected]);\n\t\t\t}\n\t\t\tthis.selectList.reveal(this.selected);\n\t\t\tthis.select(this.selected);\n\t\t}, 1);\n\t}\n\n\tprivate onHome(e: StandardKeyboardEvent): void {\n\t\tdom.EventHelper.stop(e);\n\n\t\tif (this.options.length < 2) {\n\t\t\treturn;\n\t\t}\n\t\tthis.selected = 0;\n\t\tif (this.selected === this.disabledOptionIndex && this.selected > 1) {\n\t\t\tthis.selected++;\n\t\t}\n\t\tthis.selectList.setFocus([this.selected]);\n\t\tthis.selectList.reveal(this.selected);\n\t\tthis.select(this.selected);\n\t}\n\n\tprivate onEnd(e: StandardKeyboardEvent): void {\n\t\tdom.EventHelper.stop(e);\n\n\t\tif (this.options.length < 2) {\n\t\t\treturn;\n\t\t}\n\t\tthis.selected = this.options.length - 1;\n\t\tif (this.selected === this.disabledOptionIndex && this.selected > 1) {\n\t\t\tthis.selected--;\n\t\t}\n\t\tthis.selectList.setFocus([this.selected]);\n\t\tthis.selectList.reveal(this.selected);\n\t\tthis.select(this.selected);\n\t}\n\n\t// Mimic option first character navigation of native select\n\tprivate onCharacter(e: StandardKeyboardEvent): void {\n\t\tconst ch = KeyCodeUtils.toString(e.keyCode);\n\t\tlet optionIndex = -1;\n\n\t\tfor (let i = 0; i < this.options.length - 1; i++) {\n\t\t\toptionIndex = (i + this.selected + 1) % this.options.length;\n\t\t\tif (this.options[optionIndex].charAt(0).toUpperCase() === ch) {\n\t\t\t\tthis.select(optionIndex);\n\t\t\t\tthis.selectList.setFocus([optionIndex]);\n\t\t\t\tthis.selectList.reveal(this.selectList.getFocus()[0]);\n\t\t\t\tdom.EventHelper.stop(e);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic dispose(): void {\n\t\tthis.hideSelectDropDown(false);\n\t\tthis.toDispose = dispose(this.toDispose);\n\t}\n}\n",
            "linguagem": "ts",
            "total_linhas": 769
        },
        "solucao_humana": {
            "patch_diff": "@@ -417,7 +417,15 @@ export class SelectBoxList implements ISelectBoxDelegate, IVirtualDelegate<ISele\n \n \t\tthis.layoutSelectDropDown();\n \t\treturn {\n-\t\t\tdispose: () => container.removeChild(this.selectDropDownContainer) // remove to take out the CSS rules we add\n+\t\t\tdispose: () => {\n+\t\t\t\t// contextView will dispose itself if moving from one View to another\n+\t\t\t\ttry {\n+\t\t\t\t\tcontainer.removeChild(this.selectDropDownContainer); // remove to take out the CSS rules we add\n+\t\t\t\t}\n+\t\t\t\tcatch (error) {\n+\t\t\t\t\t// Ignore, removed already by change of focus\n+\t\t\t\t}\n+\t\t\t}\n \t\t};\n \t}\n ",
            "apenas_linhas_adicionadas": [
                "\t\t\tdispose: () => {",
                "\t\t\t\t// contextView will dispose itself if moving from one View to another",
                "\t\t\t\ttry {",
                "\t\t\t\t\tcontainer.removeChild(this.selectDropDownContainer); // remove to take out the CSS rules we add",
                "\t\t\t\t}",
                "\t\t\t\tcatch (error) {",
                "\t\t\t\t\t// Ignore, removed already by change of focus",
                "\t\t\t\t}",
                "\t\t\t}"
            ]
        }
    },
    {
        "id": 54435,
        "url": "https://github.com/microsoft/vscode/pull/54435",
        "arquivo_caminho": "src/vs/base/browser/ui/selectBox/selectBoxNative.ts",
        "descricao_bug": "check property, not option",
        "contexto": {
            "codigo_completo_bugado": "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IDisposable, dispose } from 'vs/base/common/lifecycle';\nimport { Event, Emitter } from 'vs/base/common/event';\nimport { KeyCode } from 'vs/base/common/keyCodes';\nimport * as dom from 'vs/base/browser/dom';\nimport * as arrays from 'vs/base/common/arrays';\nimport { ISelectBoxDelegate, ISelectBoxOptions, ISelectBoxStyles, ISelectData } from 'vs/base/browser/ui/selectBox/selectBox';\nimport { isMacintosh } from 'vs/base/common/platform';\n\nexport class SelectBoxNative implements ISelectBoxDelegate {\n\n\tprivate selectElement: HTMLSelectElement;\n\tprivate options: string[];\n\tprivate selected: number;\n\tprivate readonly _onDidSelect: Emitter<ISelectData>;\n\tprivate toDispose: IDisposable[];\n\tprivate styles: ISelectBoxStyles;\n\n\tconstructor(options: string[], selected: number, styles: ISelectBoxStyles, selectBoxOptions?: ISelectBoxOptions) {\n\n\t\tthis.toDispose = [];\n\n\t\tthis.selectElement = document.createElement('select');\n\t\tthis.selectElement.className = 'monaco-select-box';\n\n\t\tif (typeof selectBoxOptions.ariaLabel === 'string') {\n\t\t\tthis.selectElement.setAttribute('aria-label', selectBoxOptions.ariaLabel);\n\t\t}\n\n\t\tthis._onDidSelect = new Emitter<ISelectData>();\n\n\t\tthis.styles = styles;\n\n\t\tthis.registerListeners();\n\t\tthis.setOptions(options, selected);\n\t}\n\n\tprivate registerListeners() {\n\n\t\tthis.toDispose.push(dom.addStandardDisposableListener(this.selectElement, 'change', (e) => {\n\t\t\tthis.selectElement.title = e.target.value;\n\t\t\tthis._onDidSelect.fire({\n\t\t\t\tindex: e.target.selectedIndex,\n\t\t\t\tselected: e.target.value\n\t\t\t});\n\t\t}));\n\n\t\tthis.toDispose.push(dom.addStandardDisposableListener(this.selectElement, 'keydown', (e) => {\n\t\t\tlet showSelect = false;\n\n\t\t\tif (isMacintosh) {\n\t\t\t\tif (e.keyCode === KeyCode.DownArrow || e.keyCode === KeyCode.UpArrow || e.keyCode === KeyCode.Space) {\n\t\t\t\t\tshowSelect = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (e.keyCode === KeyCode.DownArrow && e.altKey || e.keyCode === KeyCode.Space || e.keyCode === KeyCode.Enter) {\n\t\t\t\t\tshowSelect = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (showSelect) {\n\t\t\t\t// Space, Enter, is used to expand select box, do not propagate it (prevent action bar action run)\n\t\t\t\te.stopPropagation();\n\t\t\t}\n\t\t}));\n\t}\n\n\tpublic get onDidSelect(): Event<ISelectData> {\n\t\treturn this._onDidSelect.event;\n\t}\n\n\tpublic setOptions(options: string[], selected?: number, disabled?: number): void {\n\n\t\tif (!this.options || !arrays.equals(this.options, options)) {\n\t\t\tthis.options = options;\n\t\t\tthis.selectElement.options.length = 0;\n\n\t\t\tlet i = 0;\n\t\t\tthis.options.forEach((option) => {\n\t\t\t\tthis.selectElement.add(this.createOption(option, i, disabled === i++));\n\t\t\t});\n\n\t\t}\n\n\t\tif (selected !== undefined) {\n\t\t\tthis.select(selected);\n\t\t}\n\t}\n\n\tpublic select(index: number): void {\n\t\tif (index >= 0 && index < this.options.length) {\n\t\t\tthis.selected = index;\n\t\t} else if (index > this.options.length - 1) {\n\t\t\t// Adjust index to end of list\n\t\t\t// This could make client out of sync with the select\n\t\t\tthis.select(this.options.length - 1);\n\t\t} else if (this.selected < 0) {\n\t\t\tthis.selected = 0;\n\t\t}\n\n\t\tthis.selectElement.selectedIndex = this.selected;\n\t\tthis.selectElement.title = this.options[this.selected];\n\t}\n\n\tpublic focus(): void {\n\t\tif (this.selectElement) {\n\t\t\tthis.selectElement.focus();\n\t\t}\n\t}\n\n\tpublic blur(): void {\n\t\tif (this.selectElement) {\n\t\t\tthis.selectElement.blur();\n\t\t}\n\t}\n\n\tpublic render(container: HTMLElement): void {\n\t\tdom.addClass(container, 'select-container');\n\t\tcontainer.appendChild(this.selectElement);\n\t\tthis.setOptions(this.options, this.selected);\n\t\tthis.applyStyles();\n\t}\n\n\tpublic style(styles: ISelectBoxStyles): void {\n\t\tthis.styles = styles;\n\t\tthis.applyStyles();\n\t}\n\n\tpublic applyStyles(): void {\n\n\t\t// Style native select\n\t\tif (this.selectElement) {\n\t\t\tconst background = this.styles.selectBackground ? this.styles.selectBackground.toString() : null;\n\t\t\tconst foreground = this.styles.selectForeground ? this.styles.selectForeground.toString() : null;\n\t\t\tconst border = this.styles.selectBorder ? this.styles.selectBorder.toString() : null;\n\n\t\t\tthis.selectElement.style.backgroundColor = background;\n\t\t\tthis.selectElement.style.color = foreground;\n\t\t\tthis.selectElement.style.borderColor = border;\n\t\t}\n\n\t}\n\n\tprivate createOption(value: string, index: number, disabled?: boolean): HTMLOptionElement {\n\t\tlet option = document.createElement('option');\n\t\toption.value = value;\n\t\toption.text = value;\n\t\toption.disabled = disabled;\n\n\t\treturn option;\n\t}\n\n\tpublic dispose(): void {\n\t\tthis.toDispose = dispose(this.toDispose);\n\t}\n}\n",
            "linguagem": "ts",
            "total_linhas": 161
        },
        "solucao_humana": {
            "patch_diff": "@@ -14,6 +14,7 @@ import { isMacintosh } from 'vs/base/common/platform';\n export class SelectBoxNative implements ISelectBoxDelegate {\n \n \tprivate selectElement: HTMLSelectElement;\n+\tprivate selectBoxOptions: ISelectBoxOptions;\n \tprivate options: string[];\n \tprivate selected: number;\n \tprivate readonly _onDidSelect: Emitter<ISelectData>;\n@@ -23,12 +24,13 @@ export class SelectBoxNative implements ISelectBoxDelegate {\n \tconstructor(options: string[], selected: number, styles: ISelectBoxStyles, selectBoxOptions?: ISelectBoxOptions) {\n \n \t\tthis.toDispose = [];\n+\t\tthis.selectBoxOptions = selectBoxOptions || Object.create(null);\n \n \t\tthis.selectElement = document.createElement('select');\n \t\tthis.selectElement.className = 'monaco-select-box';\n \n-\t\tif (typeof selectBoxOptions.ariaLabel === 'string') {\n-\t\t\tthis.selectElement.setAttribute('aria-label', selectBoxOptions.ariaLabel);\n+\t\tif (typeof this.selectBoxOptions.ariaLabel === 'string') {\n+\t\t\tthis.selectElement.setAttribute('aria-label', this.selectBoxOptions.ariaLabel);\n \t\t}\n \n \t\tthis._onDidSelect = new Emitter<ISelectData>();",
            "apenas_linhas_adicionadas": [
                "\tprivate selectBoxOptions: ISelectBoxOptions;",
                "\t\tthis.selectBoxOptions = selectBoxOptions || Object.create(null);",
                "\t\tif (typeof this.selectBoxOptions.ariaLabel === 'string') {",
                "\t\t\tthis.selectElement.setAttribute('aria-label', this.selectBoxOptions.ariaLabel);"
            ]
        }
    },
    {
        "id": 57103,
        "url": "https://github.com/microsoft/vscode/pull/57103",
        "arquivo_caminho": "src/vs/workbench/parts/preferences/browser/settingsTree.ts",
        "descricao_bug": "@roblourens \r\n\r\n- Added disposable listener for clicking on description label\r\n- Programmatically toggle checkbox\r\n- Ignore clicks on link elements\r\n\r\nNote: \r\nI realized we have to choose which cursor type we want when over description .\r\nYou recently made the text selectable with the text cursor also.  \r\nSo right now the text does not look clickable.",
        "contexto": {
            "codigo_completo_bugado": "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as DOM from 'vs/base/browser/dom';\nimport { renderMarkdown } from 'vs/base/browser/htmlContentRenderer';\nimport { StandardKeyboardEvent } from 'vs/base/browser/keyboardEvent';\nimport { IMouseEvent } from 'vs/base/browser/mouseEvent';\nimport { Separator } from 'vs/base/browser/ui/actionbar/actionbar';\nimport { alert as ariaAlert } from 'vs/base/browser/ui/aria/aria';\nimport { Button } from 'vs/base/browser/ui/button/button';\nimport { Checkbox } from 'vs/base/browser/ui/checkbox/checkbox';\nimport { InputBox } from 'vs/base/browser/ui/inputbox/inputBox';\nimport { SelectBox } from 'vs/base/browser/ui/selectBox/selectBox';\nimport { ToolBar } from 'vs/base/browser/ui/toolbar/toolbar';\nimport { Action, IAction } from 'vs/base/common/actions';\nimport * as arrays from 'vs/base/common/arrays';\nimport { Color, RGBA } from 'vs/base/common/color';\nimport { onUnexpectedError } from 'vs/base/common/errors';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { KeyCode } from 'vs/base/common/keyCodes';\nimport { dispose, IDisposable } from 'vs/base/common/lifecycle';\nimport * as objects from 'vs/base/common/objects';\nimport { escapeRegExpCharacters, startsWith } from 'vs/base/common/strings';\nimport URI from 'vs/base/common/uri';\nimport { TPromise } from 'vs/base/common/winjs.base';\nimport { IAccessibilityProvider, IDataSource, IFilter, IRenderer as ITreeRenderer, ITree, ITreeConfiguration } from 'vs/base/parts/tree/browser/tree';\nimport { DefaultTreestyler } from 'vs/base/parts/tree/browser/treeDefaults';\nimport { Tree } from 'vs/base/parts/tree/browser/treeImpl';\nimport { localize } from 'vs/nls';\nimport { IClipboardService } from 'vs/platform/clipboard/common/clipboardService';\nimport { ICommandService } from 'vs/platform/commands/common/commands';\nimport { IConfigurationService } from 'vs/platform/configuration/common/configuration';\nimport { IContextMenuService, IContextViewService } from 'vs/platform/contextview/browser/contextView';\nimport { IInstantiationService } from 'vs/platform/instantiation/common/instantiation';\nimport { WorkbenchTreeController } from 'vs/platform/list/browser/listService';\nimport { IOpenerService } from 'vs/platform/opener/common/opener';\nimport { editorBackground, errorForeground, focusBorder, foreground, inputValidationErrorBackground, inputValidationErrorBorder } from 'vs/platform/theme/common/colorRegistry';\nimport { attachButtonStyler, attachInputBoxStyler, attachSelectBoxStyler, attachStyler } from 'vs/platform/theme/common/styler';\nimport { ICssStyleCollector, ITheme, IThemeService, registerThemingParticipant } from 'vs/platform/theme/common/themeService';\nimport { ITOCEntry } from 'vs/workbench/parts/preferences/browser/settingsLayout';\nimport { ISettingsEditorViewState, isExcludeSetting, SettingsTreeElement, SettingsTreeGroupElement, SettingsTreeNewExtensionsElement, SettingsTreeSettingElement, settingKeyToDisplayFormat } from 'vs/workbench/parts/preferences/browser/settingsTreeModels';\nimport { ExcludeSettingWidget, IExcludeDataItem, settingsHeaderForeground, settingsNumberInputBackground, settingsNumberInputBorder, settingsNumberInputForeground, settingsSelectBackground, settingsSelectBorder, settingsSelectForeground, settingsTextInputBackground, settingsTextInputBorder, settingsTextInputForeground } from 'vs/workbench/parts/preferences/browser/settingsWidgets';\nimport { ISetting, ISettingsGroup } from 'vs/workbench/services/preferences/common/preferences';\n\nconst $ = DOM.$;\n\nfunction getExcludeDisplayValue(element: SettingsTreeSettingElement): IExcludeDataItem[] {\n\tconst data = element.isConfigured ?\n\t\tobjects.mixin({ ...element.scopeValue }, element.defaultValue, false) :\n\t\telement.defaultValue;\n\n\treturn Object.keys(data)\n\t\t.filter(key => !!data[key])\n\t\t.map(key => {\n\t\t\tconst value = data[key];\n\t\t\tconst sibling = typeof value === 'boolean' ? undefined : value.when;\n\n\t\t\treturn {\n\t\t\t\tid: key,\n\t\t\t\tpattern: key,\n\t\t\t\tsibling\n\t\t\t};\n\t\t});\n}\n\nexport function resolveSettingsTree(tocData: ITOCEntry, coreSettingsGroups: ISettingsGroup[]): { tree: ITOCEntry, leftoverSettings: Set<ISetting> } {\n\tconst allSettings = getFlatSettings(coreSettingsGroups);\n\treturn {\n\t\ttree: _resolveSettingsTree(tocData, allSettings),\n\t\tleftoverSettings: allSettings\n\t};\n}\n\nexport function resolveExtensionsSettings(groups: ISettingsGroup[]): ITOCEntry {\n\tconst settingsGroupToEntry = (group: ISettingsGroup) => {\n\t\tconst flatSettings = arrays.flatten(\n\t\t\tgroup.sections.map(section => section.settings));\n\n\t\treturn {\n\t\t\tid: group.id,\n\t\t\tlabel: group.title,\n\t\t\tsettings: flatSettings\n\t\t};\n\t};\n\n\tconst extGroups = groups\n\t\t.sort((a, b) => a.title.localeCompare(b.title))\n\t\t.map(g => settingsGroupToEntry(g));\n\n\treturn {\n\t\tid: 'extensions',\n\t\tlabel: localize('extensions', \"Extensions\"),\n\t\tchildren: extGroups\n\t};\n}\n\nfunction _resolveSettingsTree(tocData: ITOCEntry, allSettings: Set<ISetting>): ITOCEntry {\n\tlet children: ITOCEntry[];\n\tif (tocData.children) {\n\t\tchildren = tocData.children\n\t\t\t.map(child => _resolveSettingsTree(child, allSettings))\n\t\t\t.filter(child => (child.children && child.children.length) || (child.settings && child.settings.length));\n\t}\n\n\tlet settings: ISetting[];\n\tif (tocData.settings) {\n\t\tsettings = arrays.flatten(tocData.settings.map(pattern => getMatchingSettings(allSettings, <string>pattern)));\n\t}\n\n\tif (!children && !settings) {\n\t\treturn null;\n\t}\n\n\treturn {\n\t\tid: tocData.id,\n\t\tlabel: tocData.label,\n\t\tchildren,\n\t\tsettings\n\t};\n}\n\nfunction getMatchingSettings(allSettings: Set<ISetting>, pattern: string): ISetting[] {\n\tconst result: ISetting[] = [];\n\n\tallSettings.forEach(s => {\n\t\tif (settingMatches(s, pattern)) {\n\t\t\tresult.push(s);\n\t\t\tallSettings.delete(s);\n\t\t}\n\t});\n\n\n\treturn result.sort((a, b) => a.key.localeCompare(b.key));\n}\n\nconst settingPatternCache = new Map<string, RegExp>();\n\nfunction createSettingMatchRegExp(pattern: string): RegExp {\n\tpattern = escapeRegExpCharacters(pattern)\n\t\t.replace(/\\\\\\*/g, '.*');\n\n\treturn new RegExp(`^${pattern}`, 'i');\n}\n\nfunction settingMatches(s: ISetting, pattern: string): boolean {\n\tlet regExp = settingPatternCache.get(pattern);\n\tif (!regExp) {\n\t\tregExp = createSettingMatchRegExp(pattern);\n\t\tsettingPatternCache.set(pattern, regExp);\n\t}\n\n\treturn regExp.test(s.key);\n}\n\nfunction getFlatSettings(settingsGroups: ISettingsGroup[]) {\n\tconst result: Set<ISetting> = new Set();\n\n\tfor (let group of settingsGroups) {\n\t\tfor (let section of group.sections) {\n\t\t\tfor (let s of section.settings) {\n\t\t\t\tif (!s.overrides || !s.overrides.length) {\n\t\t\t\t\tresult.add(s);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}\n\n\nexport class SettingsDataSource implements IDataSource {\n\n\tgetId(tree: ITree, element: SettingsTreeElement): string {\n\t\treturn element.id;\n\t}\n\n\thasChildren(tree: ITree, element: SettingsTreeElement): boolean {\n\t\tif (element instanceof SettingsTreeGroupElement) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tgetChildren(tree: ITree, element: SettingsTreeElement): TPromise<any> {\n\t\treturn TPromise.as(this._getChildren(element));\n\t}\n\n\tprivate _getChildren(element: SettingsTreeElement): SettingsTreeElement[] {\n\t\tif (element instanceof SettingsTreeGroupElement) {\n\t\t\treturn element.children;\n\t\t} else {\n\t\t\t// No children...\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tgetParent(tree: ITree, element: SettingsTreeElement): TPromise<any> {\n\t\treturn TPromise.wrap(element && element.parent);\n\t}\n\n\tshouldAutoexpand(): boolean {\n\t\treturn true;\n\t}\n}\n\ninterface IDisposableTemplate {\n\ttoDispose: IDisposable[];\n}\n\ninterface ISettingItemTemplate<T = any> extends IDisposableTemplate {\n\tonChange?: (value: T) => void;\n\n\tcontext?: SettingsTreeSettingElement;\n\tcontainerElement: HTMLElement;\n\tcategoryElement: HTMLElement;\n\tlabelElement: HTMLElement;\n\tdescriptionElement: HTMLElement;\n\tcontrolElement: HTMLElement;\n\tdeprecationWarningElement: HTMLElement;\n\totherOverridesElement: HTMLElement;\n\ttoolbar: ToolBar;\n}\n\ninterface ISettingBoolItemTemplate extends ISettingItemTemplate<boolean> {\n\tcheckbox: Checkbox;\n}\n\ninterface ISettingTextItemTemplate extends ISettingItemTemplate<string> {\n\tinputBox: InputBox;\n\tvalidationErrorMessageElement: HTMLElement;\n}\n\ntype ISettingNumberItemTemplate = ISettingTextItemTemplate;\n\ninterface ISettingEnumItemTemplate extends ISettingItemTemplate<number> {\n\tselectBox: SelectBox;\n\tenumDescriptionElement: HTMLElement;\n}\n\ninterface ISettingComplexItemTemplate extends ISettingItemTemplate<void> {\n\tbutton: Button;\n}\n\ninterface ISettingExcludeItemTemplate extends ISettingItemTemplate<void> {\n\texcludeWidget: ExcludeSettingWidget;\n}\n\ninterface ISettingNewExtensionsTemplate extends IDisposableTemplate {\n\tbutton: Button;\n\tcontext?: SettingsTreeNewExtensionsElement;\n}\n\ninterface IGroupTitleTemplate extends IDisposableTemplate {\n\tcontext?: SettingsTreeGroupElement;\n\tparent: HTMLElement;\n}\n\nconst SETTINGS_TEXT_TEMPLATE_ID = 'settings.text.template';\nconst SETTINGS_NUMBER_TEMPLATE_ID = 'settings.number.template';\nconst SETTINGS_ENUM_TEMPLATE_ID = 'settings.enum.template';\nconst SETTINGS_BOOL_TEMPLATE_ID = 'settings.bool.template';\nconst SETTINGS_EXCLUDE_TEMPLATE_ID = 'settings.exclude.template';\nconst SETTINGS_COMPLEX_TEMPLATE_ID = 'settings.complex.template';\nconst SETTINGS_NEW_EXTENSIONS_TEMPLATE_ID = 'settings.newExtensions.template';\nconst SETTINGS_GROUP_ELEMENT_TEMPLATE_ID = 'settings.group.template';\n\nexport interface ISettingChangeEvent {\n\tkey: string;\n\tvalue: any; // undefined => reset/unconfigure\n}\n\nexport class SettingsRenderer implements ITreeRenderer {\n\n\tpublic static readonly MAX_ENUM_DESCRIPTIONS = 10;\n\n\tpublic static readonly CONTROL_CLASS = 'setting-control-focus-target';\n\tpublic static readonly CONTROL_SELECTOR = '.' + SettingsRenderer.CONTROL_CLASS;\n\n\tpublic static readonly SETTING_KEY_ATTR = 'data-key';\n\n\tprivate readonly _onDidChangeSetting: Emitter<ISettingChangeEvent> = new Emitter<ISettingChangeEvent>();\n\tpublic readonly onDidChangeSetting: Event<ISettingChangeEvent> = this._onDidChangeSetting.event;\n\n\tprivate readonly _onDidOpenSettings: Emitter<string> = new Emitter<string>();\n\tpublic readonly onDidOpenSettings: Event<string> = this._onDidOpenSettings.event;\n\n\tprivate readonly _onDidClickSettingLink: Emitter<string> = new Emitter<string>();\n\tpublic readonly onDidClickSettingLink: Event<string> = this._onDidClickSettingLink.event;\n\n\tprivate readonly _onDidFocusSetting: Emitter<SettingsTreeSettingElement> = new Emitter<SettingsTreeSettingElement>();\n\tpublic readonly onDidFocusSetting: Event<SettingsTreeSettingElement> = this._onDidFocusSetting.event;\n\n\tprivate descriptionMeasureContainer: HTMLElement;\n\tprivate longestSingleLineDescription = 0;\n\n\tprivate rowHeightCache = new Map<string, number>();\n\tprivate lastRenderedWidth: number;\n\n\tprivate settingActions: IAction[];\n\n\tconstructor(\n\t\t_measureContainer: HTMLElement,\n\t\t@IThemeService private themeService: IThemeService,\n\t\t@IContextViewService private contextViewService: IContextViewService,\n\t\t@IOpenerService private readonly openerService: IOpenerService,\n\t\t@IInstantiationService private readonly instantiationService: IInstantiationService,\n\t\t@ICommandService private readonly commandService: ICommandService,\n\t\t@IContextMenuService private contextMenuService: IContextMenuService\n\t) {\n\t\tthis.descriptionMeasureContainer = $('.setting-item-description');\n\t\tDOM.append(_measureContainer,\n\t\t\t$('.setting-measure-container.monaco-tree-row', undefined,\n\t\t\t\t$('.setting-item', undefined,\n\t\t\t\t\tthis.descriptionMeasureContainer)));\n\n\t\tthis.settingActions = [\n\t\t\tthis.instantiationService.createInstance(CopySettingNameAction),\n\t\t\tthis.instantiationService.createInstance(CopySettingIdAction),\n\t\t\tthis.instantiationService.createInstance(CopySettingAsJSONAction),\n\t\t\tnew Separator(),\n\t\t\tnew Action('settings.resetSetting', localize('resetSettingLabel', \"Reset Setting\"), undefined, undefined, (context: SettingsTreeSettingElement) => {\n\t\t\t\tif (context) {\n\t\t\t\t\tthis._onDidChangeSetting.fire({ key: context.setting.key, value: undefined });\n\t\t\t\t}\n\n\t\t\t\treturn TPromise.wrap(null);\n\t\t\t})\n\t\t];\n\t}\n\n\tshowContextMenu(element: SettingsTreeSettingElement, settingDOMElement: HTMLElement): void {\n\t\tconst toolbarElement: HTMLElement = settingDOMElement.querySelector('.toolbar-toggle-more');\n\t\tif (toolbarElement) {\n\t\t\tthis.contextMenuService.showContextMenu({\n\t\t\t\tgetActions: () => TPromise.wrap(this.settingActions),\n\t\t\t\tgetAnchor: () => toolbarElement,\n\t\t\t\tgetActionsContext: () => element\n\t\t\t});\n\t\t}\n\t}\n\n\tupdateWidth(width: number): void {\n\t\tif (this.lastRenderedWidth !== width) {\n\t\t\tthis.rowHeightCache = new Map<string, number>();\n\t\t}\n\t\tthis.longestSingleLineDescription = 0;\n\n\t\tthis.lastRenderedWidth = width;\n\t}\n\n\tgetHeight(tree: ITree, element: SettingsTreeElement): number {\n\t\tif (this.rowHeightCache.has(element.id) && !(element instanceof SettingsTreeSettingElement && isExcludeSetting(element.setting))) {\n\t\t\treturn this.rowHeightCache.get(element.id);\n\t\t}\n\n\t\tconst h = this._getHeight(tree, element);\n\t\tthis.rowHeightCache.set(element.id, h);\n\t\treturn h;\n\t}\n\n\t_getHeight(tree: ITree, element: SettingsTreeElement): number {\n\t\tif (element instanceof SettingsTreeGroupElement) {\n\t\t\tif (element.isFirstGroup) {\n\t\t\t\treturn 31;\n\t\t\t}\n\n\t\t\treturn 40 + (7 * element.level);\n\t\t}\n\n\t\tif (element instanceof SettingsTreeSettingElement) {\n\t\t\tif (isExcludeSetting(element.setting)) {\n\t\t\t\treturn this._getExcludeSettingHeight(element);\n\t\t\t} else {\n\t\t\t\treturn this.measureSettingElementHeight(tree, element);\n\t\t\t}\n\t\t}\n\n\t\tif (element instanceof SettingsTreeNewExtensionsElement) {\n\t\t\treturn 40;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t_getExcludeSettingHeight(element: SettingsTreeSettingElement): number {\n\t\tconst displayValue = getExcludeDisplayValue(element);\n\t\treturn (displayValue.length + 1) * 22 + 66 + this.measureSettingDescription(element);\n\t}\n\n\tprivate measureSettingElementHeight(tree: ITree, element: SettingsTreeSettingElement): number {\n\t\tlet heightExcludingDescription = 86;\n\n\t\tif (element.valueType === 'boolean') {\n\t\t\theightExcludingDescription = 60;\n\t\t}\n\n\t\treturn heightExcludingDescription + this.measureSettingDescription(element);\n\t}\n\n\tprivate measureSettingDescription(element: SettingsTreeSettingElement): number {\n\t\tif (element.description.length < this.longestSingleLineDescription * .8) {\n\t\t\t// Most setting descriptions are one short line, so try to avoid measuring them.\n\t\t\t// If the description is less than 80% of the longest single line description, assume this will also render to be one line.\n\t\t\treturn 18;\n\t\t}\n\n\t\tconst boolMeasureClass = 'measure-bool-description';\n\t\tif (element.valueType === 'boolean') {\n\t\t\tthis.descriptionMeasureContainer.classList.add(boolMeasureClass);\n\t\t} else if (this.descriptionMeasureContainer.classList.contains(boolMeasureClass)) {\n\t\t\tthis.descriptionMeasureContainer.classList.remove(boolMeasureClass);\n\t\t}\n\n\t\t// Remove markdown links and setting links\n\t\tconst measureText = element.description\n\t\t\t.replace(/\\[(.*)\\]\\(.*\\)/g, '$1')\n\t\t\t.replace(/`#(.*)#`/g, '$1');\n\n\t\tthis.descriptionMeasureContainer.innerText = measureText;\n\t\tconst h = this.descriptionMeasureContainer.offsetHeight;\n\t\tif (h < 20 && measureText.length > this.longestSingleLineDescription) {\n\t\t\tthis.longestSingleLineDescription = measureText.length;\n\t\t}\n\n\t\treturn h;\n\t}\n\n\tgetTemplateId(tree: ITree, element: SettingsTreeElement): string {\n\t\tif (element instanceof SettingsTreeGroupElement) {\n\t\t\treturn SETTINGS_GROUP_ELEMENT_TEMPLATE_ID;\n\t\t}\n\n\t\tif (element instanceof SettingsTreeSettingElement) {\n\t\t\tif (element.valueType === 'boolean') {\n\t\t\t\treturn SETTINGS_BOOL_TEMPLATE_ID;\n\t\t\t}\n\n\t\t\tif (element.valueType === 'integer' || element.valueType === 'number' || element.valueType === 'nullable-integer' || element.valueType === 'nullable-number') {\n\t\t\t\treturn SETTINGS_NUMBER_TEMPLATE_ID;\n\t\t\t}\n\n\t\t\tif (element.valueType === 'string') {\n\t\t\t\treturn SETTINGS_TEXT_TEMPLATE_ID;\n\t\t\t}\n\n\t\t\tif (element.valueType === 'enum') {\n\t\t\t\treturn SETTINGS_ENUM_TEMPLATE_ID;\n\t\t\t}\n\n\t\t\tif (element.valueType === 'exclude') {\n\t\t\t\treturn SETTINGS_EXCLUDE_TEMPLATE_ID;\n\t\t\t}\n\n\t\t\treturn SETTINGS_COMPLEX_TEMPLATE_ID;\n\t\t}\n\n\t\tif (element instanceof SettingsTreeNewExtensionsElement) {\n\t\t\treturn SETTINGS_NEW_EXTENSIONS_TEMPLATE_ID;\n\t\t}\n\n\t\treturn '';\n\t}\n\n\trenderTemplate(tree: ITree, templateId: string, container: HTMLElement) {\n\t\tif (templateId === SETTINGS_GROUP_ELEMENT_TEMPLATE_ID) {\n\t\t\treturn this.renderGroupTitleTemplate(container);\n\t\t}\n\n\t\tif (templateId === SETTINGS_TEXT_TEMPLATE_ID) {\n\t\t\treturn this.renderSettingTextTemplate(tree, container);\n\t\t}\n\n\t\tif (templateId === SETTINGS_NUMBER_TEMPLATE_ID) {\n\t\t\treturn this.renderSettingNumberTemplate(tree, container);\n\t\t}\n\n\t\tif (templateId === SETTINGS_BOOL_TEMPLATE_ID) {\n\t\t\treturn this.renderSettingBoolTemplate(tree, container);\n\t\t}\n\n\t\tif (templateId === SETTINGS_ENUM_TEMPLATE_ID) {\n\t\t\treturn this.renderSettingEnumTemplate(tree, container);\n\t\t}\n\n\t\tif (templateId === SETTINGS_EXCLUDE_TEMPLATE_ID) {\n\t\t\treturn this.renderSettingExcludeTemplate(tree, container);\n\t\t}\n\n\t\tif (templateId === SETTINGS_COMPLEX_TEMPLATE_ID) {\n\t\t\treturn this.renderSettingComplexTemplate(tree, container);\n\t\t}\n\n\t\tif (templateId === SETTINGS_NEW_EXTENSIONS_TEMPLATE_ID) {\n\t\t\treturn this.renderNewExtensionsTemplate(container);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate renderGroupTitleTemplate(container: HTMLElement): IGroupTitleTemplate {\n\t\tDOM.addClass(container, 'group-title');\n\n\t\tconst toDispose = [];\n\t\tconst template: IGroupTitleTemplate = {\n\t\t\tparent: container,\n\t\t\ttoDispose\n\t\t};\n\n\t\treturn template;\n\t}\n\n\tprivate renderCommonTemplate(tree: ITree, container: HTMLElement, typeClass: string): ISettingItemTemplate {\n\t\tDOM.addClass(container, 'setting-item');\n\t\tDOM.addClass(container, 'setting-item-' + typeClass);\n\t\tconst titleElement = DOM.append(container, $('.setting-item-title'));\n\t\tconst labelCategoryContainer = DOM.append(titleElement, $('.setting-item-cat-label-container'));\n\t\tconst categoryElement = DOM.append(labelCategoryContainer, $('span.setting-item-category'));\n\t\tconst labelElement = DOM.append(labelCategoryContainer, $('span.setting-item-label'));\n\t\tconst otherOverridesElement = DOM.append(titleElement, $('span.setting-item-overrides'));\n\t\tconst descriptionElement = DOM.append(container, $('.setting-item-description'));\n\n\t\tconst valueElement = DOM.append(container, $('.setting-item-value'));\n\t\tconst controlElement = DOM.append(valueElement, $('div.setting-item-control'));\n\n\t\tconst deprecationWarningElement = DOM.append(container, $('.setting-item-deprecation-message'));\n\n\t\tconst toDispose = [];\n\n\t\tconst toolbar = this.renderSettingToolbar(container);\n\n\t\tconst template: ISettingItemTemplate = {\n\t\t\ttoDispose,\n\n\t\t\tcontainerElement: container,\n\t\t\tcategoryElement,\n\t\t\tlabelElement,\n\t\t\tdescriptionElement,\n\t\t\tcontrolElement,\n\t\t\tdeprecationWarningElement,\n\t\t\totherOverridesElement,\n\t\t\ttoolbar\n\t\t};\n\n\t\t// Prevent clicks from being handled by list\n\t\ttoDispose.push(DOM.addDisposableListener(controlElement, 'mousedown', (e: IMouseEvent) => e.stopPropagation()));\n\n\t\ttoDispose.push(DOM.addStandardDisposableListener(valueElement, 'keydown', (e: StandardKeyboardEvent) => {\n\t\t\tif (e.keyCode === KeyCode.Escape) {\n\t\t\t\ttree.domFocus();\n\t\t\t\te.browserEvent.stopPropagation();\n\t\t\t}\n\t\t}));\n\n\t\treturn template;\n\t}\n\n\tprivate addSettingElementFocusHandler(template: ISettingItemTemplate): void {\n\t\tconst focusTracker = DOM.trackFocus(template.containerElement);\n\t\ttemplate.toDispose.push(focusTracker);\n\t\tfocusTracker.onDidBlur(() => {\n\t\t\tif (template.containerElement.classList.contains('focused')) {\n\t\t\t\ttemplate.containerElement.classList.remove('focused');\n\t\t\t}\n\t\t});\n\n\t\tfocusTracker.onDidFocus(() => {\n\t\t\ttemplate.containerElement.classList.add('focused');\n\n\t\t\tif (template.context) {\n\t\t\t\tthis._onDidFocusSetting.fire(template.context);\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate renderSettingTextTemplate(tree: ITree, container: HTMLElement, type = 'text'): ISettingTextItemTemplate {\n\t\tconst common = this.renderCommonTemplate(tree, container, 'text');\n\t\tconst validationErrorMessageElement = DOM.append(container, $('.setting-item-validation-message'));\n\n\t\tconst inputBox = new InputBox(common.controlElement, this.contextViewService);\n\t\tcommon.toDispose.push(inputBox);\n\t\tcommon.toDispose.push(attachInputBoxStyler(inputBox, this.themeService, {\n\t\t\tinputBackground: settingsTextInputBackground,\n\t\t\tinputForeground: settingsTextInputForeground,\n\t\t\tinputBorder: settingsTextInputBorder\n\t\t}));\n\t\tcommon.toDispose.push(\n\t\t\tinputBox.onDidChange(e => {\n\t\t\t\tif (template.onChange) {\n\t\t\t\t\ttemplate.onChange(e);\n\t\t\t\t}\n\t\t\t}));\n\t\tcommon.toDispose.push(inputBox);\n\t\tinputBox.inputElement.classList.add(SettingsRenderer.CONTROL_CLASS);\n\n\t\tconst template: ISettingTextItemTemplate = {\n\t\t\t...common,\n\t\t\tinputBox,\n\t\t\tvalidationErrorMessageElement\n\t\t};\n\n\t\tthis.addSettingElementFocusHandler(template);\n\n\t\treturn template;\n\t}\n\n\tprivate renderSettingNumberTemplate(tree: ITree, container: HTMLElement): ISettingNumberItemTemplate {\n\t\tconst common = this.renderCommonTemplate(tree, container, 'number');\n\t\tconst validationErrorMessageElement = DOM.append(container, $('.setting-item-validation-message'));\n\n\t\tconst inputBox = new InputBox(common.controlElement, this.contextViewService, { type: 'number' });\n\t\tcommon.toDispose.push(inputBox);\n\t\tcommon.toDispose.push(attachInputBoxStyler(inputBox, this.themeService, {\n\t\t\tinputBackground: settingsNumberInputBackground,\n\t\t\tinputForeground: settingsNumberInputForeground,\n\t\t\tinputBorder: settingsNumberInputBorder\n\t\t}));\n\t\tcommon.toDispose.push(\n\t\t\tinputBox.onDidChange(e => {\n\t\t\t\tif (template.onChange) {\n\t\t\t\t\ttemplate.onChange(e);\n\t\t\t\t}\n\t\t\t}));\n\t\tcommon.toDispose.push(inputBox);\n\t\tinputBox.inputElement.classList.add(SettingsRenderer.CONTROL_CLASS);\n\n\t\tconst template: ISettingNumberItemTemplate = {\n\t\t\t...common,\n\t\t\tinputBox,\n\t\t\tvalidationErrorMessageElement\n\t\t};\n\n\t\tthis.addSettingElementFocusHandler(template);\n\n\t\treturn template;\n\t}\n\n\tprivate renderSettingToolbar(container: HTMLElement): ToolBar {\n\t\tconst toolbar = new ToolBar(container, this.contextMenuService, {});\n\t\ttoolbar.setActions([], this.settingActions)();\n\t\tconst button = container.querySelector('.toolbar-toggle-more');\n\t\tif (button) {\n\t\t\t(<HTMLElement>button).tabIndex = -1;\n\t\t}\n\n\t\treturn toolbar;\n\t}\n\n\tprivate renderSettingBoolTemplate(tree: ITree, container: HTMLElement): ISettingBoolItemTemplate {\n\t\tDOM.addClass(container, 'setting-item');\n\t\tDOM.addClass(container, 'setting-item-bool');\n\n\t\tconst titleElement = DOM.append(container, $('.setting-item-title'));\n\t\tconst categoryElement = DOM.append(titleElement, $('span.setting-item-category'));\n\t\tconst labelElement = DOM.append(titleElement, $('span.setting-item-label'));\n\t\tconst otherOverridesElement = DOM.append(titleElement, $('span.setting-item-overrides'));\n\n\t\tconst descriptionAndValueElement = DOM.append(container, $('.setting-item-value-description'));\n\t\tconst controlElement = DOM.append(descriptionAndValueElement, $('.setting-item-bool-control'));\n\t\tconst descriptionElement = DOM.append(descriptionAndValueElement, $('.setting-item-description'));\n\n\t\tconst deprecationWarningElement = DOM.append(container, $('.setting-item-deprecation-message'));\n\n\t\tconst toDispose = [];\n\t\tconst checkbox = new Checkbox({ actionClassName: 'setting-value-checkbox', isChecked: true, title: '', inputActiveOptionBorder: null });\n\t\tcontrolElement.appendChild(checkbox.domNode);\n\t\ttoDispose.push(checkbox);\n\t\ttoDispose.push(checkbox.onChange(() => {\n\t\t\tif (template.onChange) {\n\t\t\t\ttemplate.onChange(checkbox.checked);\n\t\t\t}\n\t\t}));\n\t\tcheckbox.domNode.classList.add(SettingsRenderer.CONTROL_CLASS);\n\t\tconst toolbar = this.renderSettingToolbar(container);\n\t\ttoDispose.push(toolbar);\n\n\t\tconst template: ISettingBoolItemTemplate = {\n\t\t\ttoDispose,\n\n\t\t\tcontainerElement: container,\n\t\t\tcategoryElement,\n\t\t\tlabelElement,\n\t\t\tcontrolElement,\n\t\t\tcheckbox,\n\t\t\tdescriptionElement,\n\t\t\tdeprecationWarningElement,\n\t\t\totherOverridesElement,\n\t\t\ttoolbar\n\t\t};\n\n\t\tthis.addSettingElementFocusHandler(template);\n\n\t\t// Prevent clicks from being handled by list\n\t\ttoDispose.push(DOM.addDisposableListener(controlElement, 'mousedown', (e: IMouseEvent) => e.stopPropagation()));\n\n\t\ttoDispose.push(DOM.addStandardDisposableListener(controlElement, 'keydown', (e: StandardKeyboardEvent) => {\n\t\t\tif (e.keyCode === KeyCode.Escape) {\n\t\t\t\ttree.domFocus();\n\t\t\t\te.browserEvent.stopPropagation();\n\t\t\t}\n\t\t}));\n\n\t\treturn template;\n\t}\n\n\tprivate renderSettingEnumTemplate(tree: ITree, container: HTMLElement): ISettingEnumItemTemplate {\n\t\tconst common = this.renderCommonTemplate(tree, container, 'enum');\n\n\t\tconst selectBox = new SelectBox([], undefined, this.contextViewService);\n\t\tcommon.toDispose.push(selectBox);\n\t\tcommon.toDispose.push(attachSelectBoxStyler(selectBox, this.themeService, {\n\t\t\tselectBackground: settingsSelectBackground,\n\t\t\tselectForeground: settingsSelectForeground,\n\t\t\tselectBorder: settingsSelectBorder\n\t\t}));\n\t\tselectBox.render(common.controlElement);\n\t\tconst selectElement = common.controlElement.querySelector('select');\n\t\tif (selectElement) {\n\t\t\tselectElement.classList.add(SettingsRenderer.CONTROL_CLASS);\n\t\t}\n\n\t\tcommon.toDispose.push(\n\t\t\tselectBox.onDidSelect(e => {\n\t\t\t\tif (template.onChange) {\n\t\t\t\t\ttemplate.onChange(e.index);\n\t\t\t\t}\n\t\t\t}));\n\n\t\tconst enumDescriptionElement = common.containerElement.insertBefore($('.setting-item-enumDescription'), common.descriptionElement.nextSibling);\n\n\t\tconst template: ISettingEnumItemTemplate = {\n\t\t\t...common,\n\t\t\tselectBox,\n\t\t\tenumDescriptionElement\n\t\t};\n\n\t\tthis.addSettingElementFocusHandler(template);\n\n\t\treturn template;\n\t}\n\n\tprivate renderSettingExcludeTemplate(tree: ITree, container: HTMLElement): ISettingExcludeItemTemplate {\n\t\tconst common = this.renderCommonTemplate(tree, container, 'exclude');\n\n\t\tconst excludeWidget = this.instantiationService.createInstance(ExcludeSettingWidget, common.controlElement);\n\t\texcludeWidget.domNode.classList.add(SettingsRenderer.CONTROL_CLASS);\n\t\tcommon.toDispose.push(excludeWidget);\n\n\t\tconst template: ISettingExcludeItemTemplate = {\n\t\t\t...common,\n\t\t\texcludeWidget\n\t\t};\n\n\t\tthis.addSettingElementFocusHandler(template);\n\n\t\tcommon.toDispose.push(excludeWidget.onDidChangeExclude(e => {\n\t\t\tif (template.context) {\n\t\t\t\tconst newValue = {\n\t\t\t\t\t...template.context.scopeValue\n\t\t\t\t};\n\n\t\t\t\tif (e.pattern) {\n\t\t\t\t\tif (e.originalPattern in newValue) {\n\t\t\t\t\t\t// editing something present in the value\n\t\t\t\t\t\tnewValue[e.pattern] = newValue[e.originalPattern];\n\t\t\t\t\t\tdelete newValue[e.originalPattern];\n\t\t\t\t\t} else if (e.originalPattern) {\n\t\t\t\t\t\t// editing a default\n\t\t\t\t\t\tnewValue[e.originalPattern] = false;\n\t\t\t\t\t\tnewValue[e.pattern] = template.context.defaultValue[e.originalPattern];\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// adding a new pattern\n\t\t\t\t\t\tnewValue[e.pattern] = true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (e.originalPattern in newValue) {\n\t\t\t\t\t\t// deleting a configured pattern\n\t\t\t\t\t\tdelete newValue[e.originalPattern];\n\t\t\t\t\t} else if (e.originalPattern) {\n\t\t\t\t\t\t// \"deleting\" a default by overriding it\n\t\t\t\t\t\tnewValue[e.originalPattern] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis._onDidChangeSetting.fire({\n\t\t\t\t\tkey: template.context.setting.key,\n\t\t\t\t\tvalue: newValue\n\t\t\t\t});\n\t\t\t}\n\t\t}));\n\n\t\treturn template;\n\t}\n\n\tprivate renderSettingComplexTemplate(tree: ITree, container: HTMLElement): ISettingComplexItemTemplate {\n\t\tconst common = this.renderCommonTemplate(tree, container, 'complex');\n\n\t\tconst openSettingsButton = new Button(common.controlElement, { title: true, buttonBackground: null, buttonHoverBackground: null });\n\t\tcommon.toDispose.push(openSettingsButton);\n\t\tcommon.toDispose.push(openSettingsButton.onDidClick(() => template.onChange(null)));\n\t\topenSettingsButton.label = localize('editInSettingsJson', \"Edit in settings.json\");\n\t\topenSettingsButton.element.classList.add('edit-in-settings-button');\n\n\t\tcommon.toDispose.push(attachButtonStyler(openSettingsButton, this.themeService, {\n\t\t\tbuttonBackground: Color.transparent.toString(),\n\t\t\tbuttonHoverBackground: Color.transparent.toString(),\n\t\t\tbuttonForeground: 'foreground'\n\t\t}));\n\n\t\tconst template: ISettingComplexItemTemplate = {\n\t\t\t...common,\n\t\t\tbutton: openSettingsButton\n\t\t};\n\n\t\tthis.addSettingElementFocusHandler(template);\n\n\t\treturn template;\n\t}\n\n\tprivate renderNewExtensionsTemplate(container: HTMLElement): ISettingNewExtensionsTemplate {\n\t\tconst toDispose = [];\n\n\t\tcontainer.classList.add('setting-item-new-extensions');\n\n\t\tconst button = new Button(container, { title: true, buttonBackground: null, buttonHoverBackground: null });\n\t\ttoDispose.push(button);\n\t\ttoDispose.push(button.onDidClick(() => {\n\t\t\tif (template.context) {\n\t\t\t\tthis.commandService.executeCommand('workbench.extensions.action.showExtensionsWithIds', template.context.extensionIds);\n\t\t\t}\n\t\t}));\n\t\tbutton.label = localize('newExtensionsButtonLabel', \"Show other matching extensions\");\n\t\tbutton.element.classList.add('settings-new-extensions-button');\n\t\ttoDispose.push(attachButtonStyler(button, this.themeService));\n\n\t\tconst template: ISettingNewExtensionsTemplate = {\n\t\t\tbutton,\n\t\t\ttoDispose\n\t\t};\n\n\t\t// this.addSettingElementFocusHandler(template);\n\n\t\treturn template;\n\t}\n\n\trenderElement(tree: ITree, element: SettingsTreeElement, templateId: string, template: any): void {\n\t\tif (templateId === SETTINGS_GROUP_ELEMENT_TEMPLATE_ID) {\n\t\t\treturn this.renderGroupElement(<SettingsTreeGroupElement>element, template);\n\t\t}\n\n\t\tif (templateId === SETTINGS_NEW_EXTENSIONS_TEMPLATE_ID) {\n\t\t\treturn this.renderNewExtensionsElement(<SettingsTreeNewExtensionsElement>element, template);\n\t\t}\n\n\t\treturn this.renderSettingElement(tree, <SettingsTreeSettingElement>element, templateId, template);\n\t}\n\n\tprivate renderGroupElement(element: SettingsTreeGroupElement, template: IGroupTitleTemplate): void {\n\t\ttemplate.parent.innerHTML = '';\n\t\tconst labelElement = DOM.append(template.parent, $('div.settings-group-title-label'));\n\t\tlabelElement.classList.add(`settings-group-level-${element.level}`);\n\t\tlabelElement.textContent = (<SettingsTreeGroupElement>element).label;\n\n\t\tif (element.isFirstGroup) {\n\t\t\tlabelElement.classList.add('settings-group-first');\n\t\t}\n\t}\n\n\tprivate renderNewExtensionsElement(element: SettingsTreeNewExtensionsElement, template: ISettingNewExtensionsTemplate): void {\n\t\ttemplate.context = element;\n\t}\n\n\tpublic getSettingDOMElementForDOMElement(domElement: HTMLElement): HTMLElement {\n\t\tconst parent = DOM.findParentWithClass(domElement, 'setting-item');\n\t\tif (parent) {\n\t\t\treturn parent;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpublic getDOMElementsForSettingKey(treeContainer: HTMLElement, key: string): NodeListOf<HTMLElement> {\n\t\treturn treeContainer.querySelectorAll(`[${SettingsRenderer.SETTING_KEY_ATTR}=\"${key}\"]`);\n\t}\n\n\tpublic getKeyForDOMElementInSetting(element: HTMLElement): string {\n\t\tconst settingElement = this.getSettingDOMElementForDOMElement(element);\n\t\treturn settingElement && settingElement.getAttribute(SettingsRenderer.SETTING_KEY_ATTR);\n\t}\n\n\tprivate renderSettingElement(tree: ITree, element: SettingsTreeSettingElement, templateId: string, template: ISettingItemTemplate | ISettingBoolItemTemplate): void {\n\t\ttemplate.context = element;\n\t\ttemplate.toolbar.context = element;\n\n\t\tconst setting = element.setting;\n\n\t\tDOM.toggleClass(template.containerElement, 'is-configured', element.isConfigured);\n\t\tDOM.toggleClass(template.containerElement, 'is-expanded', true);\n\t\ttemplate.containerElement.setAttribute(SettingsRenderer.SETTING_KEY_ATTR, element.setting.key);\n\n\t\tconst titleTooltip = setting.key + (element.isConfigured ? ' - Modified' : '');\n\t\ttemplate.categoryElement.textContent = element.displayCategory && (element.displayCategory + ': ');\n\t\ttemplate.categoryElement.title = titleTooltip;\n\n\t\ttemplate.labelElement.textContent = element.displayLabel;\n\t\ttemplate.labelElement.title = titleTooltip;\n\n\t\tthis.renderValue(element, templateId, <ISettingItemTemplate>template);\n\t\ttemplate.descriptionElement.innerHTML = '';\n\t\tif (element.setting.descriptionIsMarkdown) {\n\t\t\tconst renderedDescription = this.renderDescriptionMarkdown(element.description, template.toDispose);\n\t\t\ttemplate.descriptionElement.appendChild(renderedDescription);\n\t\t} else {\n\t\t\ttemplate.descriptionElement.innerText = element.description;\n\t\t}\n\n\t\tif (element.overriddenScopeList.length) {\n\t\t\tlet otherOverridesLabel = element.isConfigured ?\n\t\t\t\tlocalize('alsoConfiguredIn', \"Also modified in\") :\n\t\t\t\tlocalize('configuredIn', \"Modified in\");\n\n\t\t\ttemplate.otherOverridesElement.textContent = `(${otherOverridesLabel}: ${element.overriddenScopeList.join(', ')})`;\n\t\t} else {\n\t\t\ttemplate.otherOverridesElement.textContent = '';\n\t\t}\n\t}\n\n\tprivate renderDescriptionMarkdown(text: string, disposeables: IDisposable[]): HTMLElement {\n\t\t// Rewrite `#editor.fontSize#` to link format\n\t\ttext = fixSettingLinks(text);\n\n\t\tconst renderedMarkdown = renderMarkdown({ value: text }, {\n\t\t\tactionHandler: {\n\t\t\t\tcallback: (content: string) => {\n\t\t\t\t\tif (startsWith(content, '#')) {\n\t\t\t\t\t\tthis._onDidClickSettingLink.fire(content.substr(1));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.openerService.open(URI.parse(content)).then(void 0, onUnexpectedError);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tdisposeables\n\t\t\t}\n\t\t});\n\n\t\trenderedMarkdown.classList.add('setting-item-description-markdown');\n\t\tcleanRenderedMarkdown(renderedMarkdown);\n\t\treturn renderedMarkdown;\n\t}\n\n\tprivate renderValue(element: SettingsTreeSettingElement, templateId: string, template: ISettingItemTemplate | ISettingBoolItemTemplate): void {\n\t\tconst onChange = value => this._onDidChangeSetting.fire({ key: element.setting.key, value });\n\t\ttemplate.deprecationWarningElement.innerText = element.setting.deprecationMessage || '';\n\n\t\tif (templateId === SETTINGS_ENUM_TEMPLATE_ID) {\n\t\t\tthis.renderEnum(element, <ISettingEnumItemTemplate>template, onChange);\n\t\t} else if (templateId === SETTINGS_TEXT_TEMPLATE_ID) {\n\t\t\tthis.renderText(element, <ISettingTextItemTemplate>template, onChange);\n\t\t} else if (templateId === SETTINGS_NUMBER_TEMPLATE_ID) {\n\t\t\tthis.renderNumber(element, <ISettingTextItemTemplate>template, onChange);\n\t\t} else if (templateId === SETTINGS_BOOL_TEMPLATE_ID) {\n\t\t\tthis.renderBool(element, <ISettingBoolItemTemplate>template, onChange);\n\t\t} else if (templateId === SETTINGS_EXCLUDE_TEMPLATE_ID) {\n\t\t\tthis.renderExcludeSetting(element, <ISettingExcludeItemTemplate>template);\n\t\t} else if (templateId === SETTINGS_COMPLEX_TEMPLATE_ID) {\n\t\t\tthis.renderComplexSetting(element, <ISettingComplexItemTemplate>template);\n\t\t}\n\t}\n\n\tprivate renderBool(dataElement: SettingsTreeSettingElement, template: ISettingBoolItemTemplate, onChange: (value: boolean) => void): void {\n\t\ttemplate.onChange = null;\n\t\ttemplate.checkbox.checked = dataElement.value;\n\t\ttemplate.onChange = onChange;\n\n\t\t// Setup and add ARIA attributes\n\t\t// Create id and label for control/input element - parent is wrapper div\n\t\tconst id = (dataElement.displayCategory + '_' + dataElement.displayLabel).replace(/ /g, '_');\n\t\tconst modifiedText = dataElement.isConfigured ? 'Modified' : '';\n\t\tconst label = ' ' + dataElement.displayCategory + ' ' + dataElement.displayLabel + ' checkbox ' + (dataElement.value ? 'checked ' : 'unchecked ') + modifiedText;\n\n\t\t// We use the parent control div for the aria-labelledby target\n\t\t// Does not appear you can use the direct label on the element itself within a tree\n\t\ttemplate.checkbox.domNode.parentElement.setAttribute('id', id);\n\t\ttemplate.checkbox.domNode.parentElement.setAttribute('aria-label', label);\n\n\t\t// Labels will not be read on descendent input elements of the parent treeitem\n\t\t// unless defined as role=treeitem and indirect aria-labelledby approach\n\t\t// TODO: Determine method to normally label input items with value read last\n\t\ttemplate.checkbox.domNode.setAttribute('id', id + 'item');\n\t\ttemplate.checkbox.domNode.setAttribute('role', 'treeitem');\n\t\ttemplate.checkbox.domNode.setAttribute('aria-labelledby', id + 'item ' + id);\n\n\t}\n\n\tprivate renderEnum(dataElement: SettingsTreeSettingElement, template: ISettingEnumItemTemplate, onChange: (value: string) => void): void {\n\t\tconst displayOptions = getDisplayEnumOptions(dataElement.setting);\n\t\ttemplate.selectBox.setOptions(displayOptions);\n\n\t\tconst modifiedText = dataElement.isConfigured ? 'Modified' : '';\n\t\tconst label = ' ' + dataElement.displayCategory + ' ' + dataElement.displayLabel + ' combobox ' + modifiedText;\n\n\t\ttemplate.selectBox.setAriaLabel(label);\n\n\t\tconst idx = dataElement.setting.enum.indexOf(dataElement.value);\n\t\ttemplate.onChange = null;\n\t\ttemplate.selectBox.select(idx);\n\t\ttemplate.onChange = idx => onChange(dataElement.setting.enum[idx]);\n\n\t\tif (template.controlElement.firstElementChild) {\n\t\t\t// SelectBox needs to be treeitem to read correctly within tree\n\t\t\ttemplate.controlElement.firstElementChild.setAttribute('role', 'treeitem');\n\t\t}\n\n\t\ttemplate.enumDescriptionElement.innerHTML = '';\n\t\t// if (dataElement.setting.enumDescriptions && dataElement.setting.enum && dataElement.setting.enum.length < SettingsRenderer.MAX_ENUM_DESCRIPTIONS) {\n\t\t// \tif (isSelected) {\n\t\t// \t\tlet enumDescriptionText = '\\n' + dataElement.setting.enumDescriptions\n\t\t// \t\t\t.map((desc, i) => {\n\t\t// \t\t\t\tconst displayEnum = escapeInvisibleChars(dataElement.setting.enum[i]);\n\t\t// \t\t\t\treturn desc ?\n\t\t// \t\t\t\t\t` - \\`${displayEnum}\\`: ${desc}` :\n\t\t// \t\t\t\t\t` - \\`${dataElement.setting.enum[i]}\\``;\n\t\t// \t\t\t})\n\t\t// \t\t\t.filter(desc => !!desc)\n\t\t// \t\t\t.join('\\n');\n\n\t\t// \t\tconst renderedMarkdown = this.renderDescriptionMarkdown(fixSettingLinks(enumDescriptionText), template.toDispose);\n\t\t// \t\ttemplate.enumDescriptionElement.appendChild(renderedMarkdown);\n\t\t// \t}\n\n\t\t// \treturn { overflows: true };\n\t\t// }\n\t}\n\n\tprivate renderText(dataElement: SettingsTreeSettingElement, template: ISettingTextItemTemplate, onChange: (value: string) => void): void {\n\t\tconst modifiedText = dataElement.isConfigured ? 'Modified' : '';\n\t\tconst label = ' ' + dataElement.displayCategory + ' ' + dataElement.displayLabel + ' ' + modifiedText;\n\t\ttemplate.onChange = null;\n\t\ttemplate.inputBox.value = dataElement.value;\n\t\ttemplate.onChange = value => { renderValidations(dataElement, template, false, label); onChange(value); };\n\n\t\t// Setup and add ARIA attributes\n\t\t// Create id and label for control/input element - parent is wrapper div\n\t\tconst id = (dataElement.displayCategory + '_' + dataElement.displayLabel).replace(/ /g, '_');\n\n\t\t// We use the parent control div for the aria-labelledby target\n\t\t// Does not appear you can use the direct label on the element itself within a tree\n\t\ttemplate.inputBox.inputElement.parentElement.setAttribute('id', id);\n\t\ttemplate.inputBox.inputElement.parentElement.setAttribute('aria-label', label);\n\n\t\t// Labels will not be read on descendent input elements of the parent treeitem\n\t\t// unless defined as role=treeitem and indirect aria-labelledby approach\n\t\t// TODO: Determine method to normally label input items with value read last\n\t\ttemplate.inputBox.inputElement.setAttribute('id', id + 'item');\n\t\ttemplate.inputBox.inputElement.setAttribute('role', 'treeitem');\n\t\ttemplate.inputBox.inputElement.setAttribute('aria-labelledby', id + 'item ' + id);\n\n\t\trenderValidations(dataElement, template, true, label);\n\t}\n\n\n\tprivate renderNumber(dataElement: SettingsTreeSettingElement, template: ISettingTextItemTemplate, onChange: (value: number) => void): void {\n\t\tconst modifiedText = dataElement.isConfigured ? 'Modified' : '';\n\t\tconst label = ' ' + dataElement.displayCategory + ' ' + dataElement.displayLabel + ' number ' + modifiedText;\n\t\tconst numParseFn = (dataElement.valueType === 'integer' || dataElement.valueType === 'nullable-integer')\n\t\t\t? parseInt : parseFloat;\n\n\t\tconst nullNumParseFn = (dataElement.valueType === 'nullable-integer' || dataElement.valueType === 'nullable-number')\n\t\t\t? (v => v === '' ? null : numParseFn(v)) : numParseFn;\n\n\t\ttemplate.onChange = null;\n\t\ttemplate.inputBox.value = dataElement.value;\n\t\ttemplate.onChange = value => { renderValidations(dataElement, template, false, label); onChange(nullNumParseFn(value)); };\n\n\t\t// Setup and add ARIA attributes\n\t\t// Create id and label for control/input element - parent is wrapper div\n\t\tconst id = (dataElement.displayCategory + '_' + dataElement.displayLabel).replace(/ /g, '_');\n\n\t\t// We use the parent control div for the aria-labelledby target\n\t\t// Does not appear you can use the direct label on the element itself within a tree\n\t\ttemplate.inputBox.inputElement.parentElement.setAttribute('id', id);\n\t\ttemplate.inputBox.inputElement.parentElement.setAttribute('aria-label', label);\n\n\t\t// Labels will not be read on descendent input elements of the parent treeitem\n\t\t// unless defined as role=treeitem and indirect aria-labelledby approach\n\t\t// TODO: Determine method to normally label input items with value read last\n\t\ttemplate.inputBox.inputElement.setAttribute('id', id + 'item');\n\t\ttemplate.inputBox.inputElement.setAttribute('role', 'treeitem');\n\t\ttemplate.inputBox.inputElement.setAttribute('aria-labelledby', id + 'item ' + id);\n\n\t\trenderValidations(dataElement, template, true, label);\n\t}\n\n\tprivate renderExcludeSetting(dataElement: SettingsTreeSettingElement, template: ISettingExcludeItemTemplate): void {\n\t\tconst value = getExcludeDisplayValue(dataElement);\n\t\ttemplate.excludeWidget.setValue(value);\n\t\ttemplate.context = dataElement;\n\t}\n\n\tprivate renderComplexSetting(dataElement: SettingsTreeSettingElement, template: ISettingComplexItemTemplate): void {\n\t\ttemplate.onChange = () => this._onDidOpenSettings.fire(dataElement.setting.key);\n\t}\n\n\tdisposeTemplate(tree: ITree, templateId: string, template: IDisposableTemplate): void {\n\t\tdispose(template.toDispose);\n\t}\n}\n\nfunction renderValidations(dataElement: SettingsTreeSettingElement, template: ISettingTextItemTemplate, calledOnStartup: boolean, originalAriaLabel: string) {\n\tif (dataElement.setting.validator) {\n\t\tlet errMsg = dataElement.setting.validator(template.inputBox.value);\n\t\tif (errMsg) {\n\t\t\tDOM.addClass(template.containerElement, 'invalid-input');\n\t\t\ttemplate.validationErrorMessageElement.innerText = errMsg;\n\t\t\tlet validationError = localize('validationError', \"Validation Error.\");\n\t\t\ttemplate.inputBox.inputElement.parentElement.setAttribute('aria-label', [originalAriaLabel, validationError, errMsg].join(' '));\n\t\t\tif (!calledOnStartup) { ariaAlert(validationError + ' ' + errMsg); }\n\t\t\treturn;\n\t\t} else {\n\t\t\ttemplate.inputBox.inputElement.parentElement.setAttribute('aria-label', originalAriaLabel);\n\t\t}\n\t}\n\tDOM.removeClass(template.containerElement, 'invalid-input');\n}\n\nfunction cleanRenderedMarkdown(element: Node): void {\n\tfor (let i = 0; i < element.childNodes.length; i++) {\n\t\tconst child = element.childNodes.item(i);\n\n\t\tconst tagName = (<Element>child).tagName && (<Element>child).tagName.toLowerCase();\n\t\tif (tagName === 'img') {\n\t\t\telement.removeChild(child);\n\t\t} else {\n\t\t\tcleanRenderedMarkdown(child);\n\t\t}\n\t}\n}\n\nfunction fixSettingLinks(text: string): string {\n\treturn text.replace(/`#([^#]*)#`/g, (match, settingName) => {\n\t\tconst targetDisplayFormat = settingKeyToDisplayFormat(settingName);\n\t\tconst targetName = `${targetDisplayFormat.category}: ${targetDisplayFormat.label}`;\n\t\treturn `[${targetName}](#${settingName})`;\n\t});\n}\n\nfunction getDisplayEnumOptions(setting: ISetting): string[] {\n\tif (setting.enum.length > SettingsRenderer.MAX_ENUM_DESCRIPTIONS && setting.enumDescriptions) {\n\t\treturn setting.enum\n\t\t\t.map(escapeInvisibleChars)\n\t\t\t.map((value, i) => {\n\t\t\t\treturn setting.enumDescriptions[i] ?\n\t\t\t\t\t`${value}: ${setting.enumDescriptions[i]}` :\n\t\t\t\t\tvalue;\n\t\t\t});\n\t}\n\n\treturn setting.enum\n\t\t.map(String)\n\t\t.map(escapeInvisibleChars);\n}\n\nfunction escapeInvisibleChars(enumValue: string): string {\n\treturn enumValue && enumValue\n\t\t.replace(/\\n/g, '\\\\n')\n\t\t.replace(/\\r/g, '\\\\r');\n}\n\nexport class SettingsTreeFilter implements IFilter {\n\tconstructor(\n\t\tprivate viewState: ISettingsEditorViewState,\n\t) { }\n\n\tisVisible(tree: ITree, element: SettingsTreeElement): boolean {\n\t\t// Filter during search\n\t\tif (this.viewState.filterToCategory && element instanceof SettingsTreeSettingElement) {\n\t\t\tif (!this.settingContainedInGroup(element.setting, this.viewState.filterToCategory)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tif (element instanceof SettingsTreeSettingElement && this.viewState.tagFilters) {\n\t\t\treturn element.matchesAllTags(this.viewState.tagFilters);\n\t\t}\n\n\t\tif (element instanceof SettingsTreeGroupElement) {\n\t\t\tif (typeof element.count === 'number') {\n\t\t\t\treturn element.count > 0;\n\t\t\t}\n\n\t\t\treturn element.children.some(child => this.isVisible(tree, child));\n\t\t}\n\n\t\tif (element instanceof SettingsTreeNewExtensionsElement) {\n\t\t\tif ((this.viewState.tagFilters && this.viewState.tagFilters.size) || this.viewState.filterToCategory) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate settingContainedInGroup(setting: ISetting, group: SettingsTreeGroupElement): boolean {\n\t\treturn group.children.some(child => {\n\t\t\tif (child instanceof SettingsTreeGroupElement) {\n\t\t\t\treturn this.settingContainedInGroup(setting, child);\n\t\t\t} else if (child instanceof SettingsTreeSettingElement) {\n\t\t\t\treturn child.setting.key === setting.key;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t}\n}\n\nexport class SettingsTreeController extends WorkbenchTreeController {\n\tconstructor(\n\t\t@IConfigurationService configurationService: IConfigurationService\n\t) {\n\t\tsuper({}, configurationService);\n\t}\n\n\tprotected onLeftClick(tree: ITree, element: any, eventish: IMouseEvent, origin?: string): boolean {\n\t\tconst isLink = eventish.target.tagName.toLowerCase() === 'a' ||\n\t\t\teventish.target.parentElement.tagName.toLowerCase() === 'a'; // <code> inside <a>\n\n\t\tif (isLink && DOM.findParentWithClass(eventish.target, 'setting-item-description-markdown', tree.getHTMLElement())) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n}\n\nexport class SettingsAccessibilityProvider implements IAccessibilityProvider {\n\tgetAriaLabel(tree: ITree, element: SettingsTreeElement): string {\n\t\tif (!element) {\n\t\t\treturn '';\n\t\t}\n\n\t\tif (element instanceof SettingsTreeSettingElement) {\n\t\t\treturn localize('settingRowAriaLabel', \"{0} {1}, Setting\", element.displayCategory, element.displayLabel);\n\t\t}\n\n\t\tif (element instanceof SettingsTreeGroupElement) {\n\t\t\treturn localize('groupRowAriaLabel', \"{0}, group\", element.label);\n\t\t}\n\n\t\treturn '';\n\t}\n}\n\nclass NonExpandableOrSelectableTree extends Tree {\n\texpand(): TPromise<any> {\n\t\treturn TPromise.wrap(null);\n\t}\n\n\tcollapse(): TPromise<any> {\n\t\treturn TPromise.wrap(null);\n\t}\n\n\tpublic setFocus(element?: any, eventPayload?: any): void {\n\t\treturn;\n\t}\n\n\tpublic focusNext(count?: number, eventPayload?: any): void {\n\t\treturn;\n\t}\n\n\tpublic focusPrevious(count?: number, eventPayload?: any): void {\n\t\treturn;\n\t}\n\n\tpublic focusParent(eventPayload?: any): void {\n\t\treturn;\n\t}\n\n\tpublic focusFirstChild(eventPayload?: any): void {\n\t\treturn;\n\t}\n\n\tpublic focusFirst(eventPayload?: any, from?: any): void {\n\t\treturn;\n\t}\n\n\tpublic focusNth(index: number, eventPayload?: any): void {\n\t\treturn;\n\t}\n\n\tpublic focusLast(eventPayload?: any, from?: any): void {\n\t\treturn;\n\t}\n\n\tpublic focusNextPage(eventPayload?: any): void {\n\t\treturn;\n\t}\n\n\tpublic focusPreviousPage(eventPayload?: any): void {\n\t\treturn;\n\t}\n\n\tpublic select(element: any, eventPayload?: any): void {\n\t\treturn;\n\t}\n\n\tpublic selectRange(fromElement: any, toElement: any, eventPayload?: any): void {\n\t\treturn;\n\t}\n\n\tpublic selectAll(elements: any[], eventPayload?: any): void {\n\t\treturn;\n\t}\n\n\tpublic setSelection(elements: any[], eventPayload?: any): void {\n\t\treturn;\n\t}\n\n\tpublic toggleSelection(element: any, eventPayload?: any): void {\n\t\treturn;\n\t}\n}\n\nexport class SettingsTree extends NonExpandableOrSelectableTree {\n\tprotected disposables: IDisposable[];\n\n\tconstructor(\n\t\tcontainer: HTMLElement,\n\t\tviewState: ISettingsEditorViewState,\n\t\tconfiguration: Partial<ITreeConfiguration>,\n\t\t@IThemeService themeService: IThemeService,\n\t\t@IInstantiationService instantiationService: IInstantiationService\n\t) {\n\t\tconst treeClass = 'settings-editor-tree';\n\n\t\tconst controller = instantiationService.createInstance(SettingsTreeController);\n\t\tconst fullConfiguration = <ITreeConfiguration>{\n\t\t\tdataSource: instantiationService.createInstance(SettingsDataSource, viewState),\n\t\t\tcontroller,\n\t\t\taccessibilityProvider: instantiationService.createInstance(SettingsAccessibilityProvider),\n\t\t\tfilter: instantiationService.createInstance(SettingsTreeFilter, viewState),\n\t\t\tstyler: new DefaultTreestyler(DOM.createStyleSheet(container), treeClass),\n\n\t\t\t...configuration\n\t\t};\n\n\t\tconst options = {\n\t\t\tariaLabel: localize('treeAriaLabel', \"Settings\"),\n\t\t\tshowLoading: false,\n\t\t\tindentPixels: 0,\n\t\t\ttwistiePixels: 20, // Actually for gear button\n\t\t};\n\n\t\tsuper(container,\n\t\t\tfullConfiguration,\n\t\t\toptions);\n\n\t\tthis.disposables = [];\n\t\tthis.disposables.push(controller);\n\n\t\tthis.disposables.push(registerThemingParticipant((theme: ITheme, collector: ICssStyleCollector) => {\n\t\t\tconst activeBorderColor = theme.getColor(focusBorder);\n\t\t\tif (activeBorderColor) {\n\t\t\t\t// TODO@rob - why isn't this applied when added to the stylesheet from tocTree.ts? Seems like a chromium glitch.\n\t\t\t\tcollector.addRule(`.settings-editor > .settings-body > .settings-toc-container .monaco-tree:focus .monaco-tree-row.focused {outline: solid 1px ${activeBorderColor}; outline-offset: -1px;  }`);\n\t\t\t}\n\n\t\t\tconst foregroundColor = theme.getColor(foreground);\n\t\t\tif (foregroundColor) {\n\t\t\t\t// Links appear inside other elements in markdown. CSS opacity acts like a mask. So we have to dynamically compute the description color to avoid\n\t\t\t\t// applying an opacity to the link color.\n\t\t\t\tconst fgWithOpacity = new Color(new RGBA(foregroundColor.rgba.r, foregroundColor.rgba.g, foregroundColor.rgba.b, .9));\n\t\t\t\tcollector.addRule(`.settings-editor > .settings-body > .settings-tree-container .setting-item .setting-item-description { color: ${fgWithOpacity}; }`);\n\t\t\t}\n\n\t\t\tconst errorColor = theme.getColor(errorForeground);\n\t\t\tif (errorColor) {\n\t\t\t\tcollector.addRule(`.settings-editor > .settings-body > .settings-tree-container .setting-item .setting-item-deprecation-message { color: ${errorColor}; }`);\n\t\t\t}\n\n\t\t\tconst invalidInputBackground = theme.getColor(inputValidationErrorBackground);\n\t\t\tif (invalidInputBackground) {\n\t\t\t\tcollector.addRule(`.settings-editor > .settings-body > .settings-tree-container .setting-item .setting-item-validation-message { background-color: ${invalidInputBackground}; }`);\n\t\t\t}\n\n\t\t\tconst invalidInputBorder = theme.getColor(inputValidationErrorBorder);\n\t\t\tif (invalidInputBorder) {\n\t\t\t\tcollector.addRule(`.settings-editor > .settings-body > .settings-tree-container .setting-item .setting-item-validation-message { border-style:solid; border-width: 1px; border-color: ${invalidInputBorder}; }`);\n\t\t\t\tcollector.addRule(`.settings-editor > .settings-body > .settings-tree-container .setting-item.invalid-input .setting-item-control .monaco-inputbox.idle { outline-width: 0; border-style:solid; border-width: 1px; border-color: ${invalidInputBorder}; }`);\n\t\t\t}\n\n\t\t\tconst headerForegroundColor = theme.getColor(settingsHeaderForeground);\n\t\t\tif (headerForegroundColor) {\n\t\t\t\tcollector.addRule(`.settings-editor > .settings-body > .settings-tree-container .settings-group-title-label { color: ${headerForegroundColor}; }`);\n\t\t\t\tcollector.addRule(`.settings-editor > .settings-body > .settings-tree-container .setting-item-label { color: ${headerForegroundColor}; }`);\n\t\t\t}\n\t\t}));\n\n\t\tthis.getHTMLElement().classList.add(treeClass);\n\n\t\tthis.disposables.push(attachStyler(themeService, {\n\t\t\tlistActiveSelectionBackground: editorBackground,\n\t\t\tlistActiveSelectionForeground: foreground,\n\t\t\tlistFocusAndSelectionBackground: editorBackground,\n\t\t\tlistFocusAndSelectionForeground: foreground,\n\t\t\tlistFocusBackground: editorBackground,\n\t\t\tlistFocusForeground: foreground,\n\t\t\tlistHoverForeground: foreground,\n\t\t\tlistHoverBackground: editorBackground,\n\t\t\tlistHoverOutline: editorBackground,\n\t\t\tlistFocusOutline: editorBackground,\n\t\t\tlistInactiveSelectionBackground: editorBackground,\n\t\t\tlistInactiveSelectionForeground: foreground\n\t\t}, colors => {\n\t\t\tthis.style(colors);\n\t\t}));\n\t}\n}\n\nclass CopySettingIdAction extends Action {\n\tstatic readonly ID = 'settings.copySettingId';\n\tstatic readonly LABEL = localize('copySettingIdLabel', \"Copy Setting ID\");\n\n\tconstructor(\n\t\t@IClipboardService private clipboardService: IClipboardService\n\t) {\n\t\tsuper(CopySettingIdAction.ID, CopySettingIdAction.LABEL);\n\t}\n\n\trun(context: SettingsTreeSettingElement): TPromise<void> {\n\t\tif (context) {\n\t\t\tthis.clipboardService.writeText(context.setting.key);\n\t\t}\n\n\t\treturn TPromise.as(null);\n\t}\n}\n\nclass CopySettingAsJSONAction extends Action {\n\tstatic readonly ID = 'settings.copySettingAsJSON';\n\tstatic readonly LABEL = localize('copySettingAsJSONLabel', \"Copy Setting as JSON\");\n\n\tconstructor(\n\t\t@IClipboardService private clipboardService: IClipboardService\n\t) {\n\t\tsuper(CopySettingAsJSONAction.ID, CopySettingAsJSONAction.LABEL);\n\t}\n\n\trun(context: SettingsTreeSettingElement): TPromise<void> {\n\t\tif (context) {\n\t\t\tconst jsonResult = `\"${context.setting.key}\": ${JSON.stringify(context.value, undefined, '  ')}`;\n\t\t\tthis.clipboardService.writeText(jsonResult);\n\t\t}\n\n\t\treturn TPromise.as(null);\n\t}\n}\n\nclass CopySettingNameAction extends Action {\n\tstatic readonly ID = 'settings.copySettingName';\n\tstatic readonly LABEL = localize('copySettingNameLabel', \"Copy Setting Name\");\n\n\tconstructor(\n\t\t@IClipboardService private clipboardService: IClipboardService\n\t) {\n\t\tsuper(CopySettingNameAction.ID, CopySettingNameAction.LABEL);\n\t}\n\n\trun(context: SettingsTreeSettingElement): TPromise<void> {\n\t\tif (context) {\n\t\t\tconst name = `${context.displayCategory}: ${context.displayLabel}`;\n\t\t\tthis.clipboardService.writeText(name);\n\t\t}\n\n\t\treturn TPromise.as(null);\n\t}\n}\n",
            "linguagem": "ts",
            "total_linhas": 1479
        },
        "solucao_humana": {
            "patch_diff": "@@ -673,6 +673,21 @@ export class SettingsRenderer implements ITreeRenderer {\n \t\t\t\ttemplate.onChange(checkbox.checked);\n \t\t\t}\n \t\t}));\n+\n+\t\t// Need to listen for mouse clicks on description and toggle checkbox - use target ID for safety\n+\t\t// Also have to ignore embedded links - too buried to stop propagation\n+\t\ttoDispose.push(DOM.addDisposableListener(descriptionElement, DOM.EventType.MOUSE_DOWN, (e) => {\n+\t\t\tconst targetElement = <HTMLElement>e.toElement;\n+\t\t\tconst targetId = descriptionElement.getAttribute('checkboxLabelTargetId');\n+\n+\t\t\t// Make sure we are not a link and the target ID matches\n+\t\t\t// Toggle target checkbox\n+\t\t\tif (targetElement.tagName !== 'A' && targetId === template.checkbox.domNode.id) {\n+\t\t\t\ttemplate.checkbox.checked = template.checkbox.checked ? false : true;\n+\t\t\t}\n+\t\t\tDOM.EventHelper.stop(e);\n+\t\t}));\n+\n \t\tcheckbox.domNode.classList.add(SettingsRenderer.CONTROL_CLASS);\n \t\tconst toolbar = this.renderSettingToolbar(container);\n \t\ttoDispose.push(toolbar);\n@@ -917,6 +932,10 @@ export class SettingsRenderer implements ITreeRenderer {\n \t\t\ttemplate.descriptionElement.innerText = element.description;\n \t\t}\n \n+\t\t// Add checkbox target to description clickable and able to toggle checkbox\n+\t\tconst checkbox_id = (element.displayCategory + '_' + element.displayLabel).replace(/ /g, '_') + '_Item';\n+\t\ttemplate.descriptionElement.setAttribute('checkboxLabelTargetId', checkbox_id);\n+\n \t\tif (element.overriddenScopeList.length) {\n \t\t\tlet otherOverridesLabel = element.isConfigured ?\n \t\t\t\tlocalize('alsoConfiguredIn', \"Also modified in\") :\n@@ -988,9 +1007,9 @@ export class SettingsRenderer implements ITreeRenderer {\n \t\t// Labels will not be read on descendent input elements of the parent treeitem\n \t\t// unless defined as role=treeitem and indirect aria-labelledby approach\n \t\t// TODO: Determine method to normally label input items with value read last\n-\t\ttemplate.checkbox.domNode.setAttribute('id', id + 'item');\n+\t\ttemplate.checkbox.domNode.setAttribute('id', id + '_Item');\n \t\ttemplate.checkbox.domNode.setAttribute('role', 'treeitem');\n-\t\ttemplate.checkbox.domNode.setAttribute('aria-labelledby', id + 'item ' + id);\n+\t\ttemplate.checkbox.domNode.setAttribute('aria-labelledby', id + '_Item ' + id);\n \n \t}\n ",
            "apenas_linhas_adicionadas": [
                "",
                "\t\t// Need to listen for mouse clicks on description and toggle checkbox - use target ID for safety",
                "\t\t// Also have to ignore embedded links - too buried to stop propagation",
                "\t\ttoDispose.push(DOM.addDisposableListener(descriptionElement, DOM.EventType.MOUSE_DOWN, (e) => {",
                "\t\t\tconst targetElement = <HTMLElement>e.toElement;",
                "\t\t\tconst targetId = descriptionElement.getAttribute('checkboxLabelTargetId');",
                "",
                "\t\t\t// Make sure we are not a link and the target ID matches",
                "\t\t\t// Toggle target checkbox",
                "\t\t\tif (targetElement.tagName !== 'A' && targetId === template.checkbox.domNode.id) {",
                "\t\t\t\ttemplate.checkbox.checked = template.checkbox.checked ? false : true;",
                "\t\t\t}",
                "\t\t\tDOM.EventHelper.stop(e);",
                "\t\t}));",
                "",
                "\t\t// Add checkbox target to description clickable and able to toggle checkbox",
                "\t\tconst checkbox_id = (element.displayCategory + '_' + element.displayLabel).replace(/ /g, '_') + '_Item';",
                "\t\ttemplate.descriptionElement.setAttribute('checkboxLabelTargetId', checkbox_id);",
                "",
                "\t\ttemplate.checkbox.domNode.setAttribute('id', id + '_Item');",
                "\t\ttemplate.checkbox.domNode.setAttribute('aria-labelledby', id + '_Item ' + id);"
            ]
        }
    },
    {
        "id": 57184,
        "url": "https://github.com/microsoft/vscode/pull/57184",
        "arquivo_caminho": "src/vs/workbench/parts/preferences/browser/settingsTree.ts",
        "descricao_bug": "Call on change handler when checkboxes indirectly toggled",
        "contexto": {
            "codigo_completo_bugado": "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as DOM from 'vs/base/browser/dom';\nimport { renderMarkdown } from 'vs/base/browser/htmlContentRenderer';\nimport { StandardKeyboardEvent } from 'vs/base/browser/keyboardEvent';\nimport { IMouseEvent } from 'vs/base/browser/mouseEvent';\nimport { Separator } from 'vs/base/browser/ui/actionbar/actionbar';\nimport { alert as ariaAlert } from 'vs/base/browser/ui/aria/aria';\nimport { Button } from 'vs/base/browser/ui/button/button';\nimport { Checkbox } from 'vs/base/browser/ui/checkbox/checkbox';\nimport { InputBox } from 'vs/base/browser/ui/inputbox/inputBox';\nimport { SelectBox } from 'vs/base/browser/ui/selectBox/selectBox';\nimport { ToolBar } from 'vs/base/browser/ui/toolbar/toolbar';\nimport { Action, IAction } from 'vs/base/common/actions';\nimport * as arrays from 'vs/base/common/arrays';\nimport { Color, RGBA } from 'vs/base/common/color';\nimport { onUnexpectedError } from 'vs/base/common/errors';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { KeyCode } from 'vs/base/common/keyCodes';\nimport { dispose, IDisposable } from 'vs/base/common/lifecycle';\nimport * as objects from 'vs/base/common/objects';\nimport { escapeRegExpCharacters, startsWith } from 'vs/base/common/strings';\nimport URI from 'vs/base/common/uri';\nimport { TPromise } from 'vs/base/common/winjs.base';\nimport { IAccessibilityProvider, IDataSource, IFilter, IRenderer as ITreeRenderer, ITree, ITreeConfiguration } from 'vs/base/parts/tree/browser/tree';\nimport { DefaultTreestyler } from 'vs/base/parts/tree/browser/treeDefaults';\nimport { Tree } from 'vs/base/parts/tree/browser/treeImpl';\nimport { localize } from 'vs/nls';\nimport { IClipboardService } from 'vs/platform/clipboard/common/clipboardService';\nimport { ICommandService } from 'vs/platform/commands/common/commands';\nimport { IConfigurationService } from 'vs/platform/configuration/common/configuration';\nimport { IContextMenuService, IContextViewService } from 'vs/platform/contextview/browser/contextView';\nimport { IInstantiationService } from 'vs/platform/instantiation/common/instantiation';\nimport { WorkbenchTreeController } from 'vs/platform/list/browser/listService';\nimport { IOpenerService } from 'vs/platform/opener/common/opener';\nimport { editorBackground, errorForeground, focusBorder, foreground, inputValidationErrorBackground, inputValidationErrorBorder } from 'vs/platform/theme/common/colorRegistry';\nimport { attachButtonStyler, attachInputBoxStyler, attachSelectBoxStyler, attachStyler } from 'vs/platform/theme/common/styler';\nimport { ICssStyleCollector, ITheme, IThemeService, registerThemingParticipant } from 'vs/platform/theme/common/themeService';\nimport { ITOCEntry } from 'vs/workbench/parts/preferences/browser/settingsLayout';\nimport { ISettingsEditorViewState, isExcludeSetting, SettingsTreeElement, SettingsTreeGroupElement, SettingsTreeNewExtensionsElement, SettingsTreeSettingElement, settingKeyToDisplayFormat } from 'vs/workbench/parts/preferences/browser/settingsTreeModels';\nimport { ExcludeSettingWidget, IExcludeDataItem, settingsHeaderForeground, settingsNumberInputBackground, settingsNumberInputBorder, settingsNumberInputForeground, settingsSelectBackground, settingsSelectBorder, settingsSelectListBorder, settingsSelectForeground, settingsTextInputBackground, settingsTextInputBorder, settingsTextInputForeground } from 'vs/workbench/parts/preferences/browser/settingsWidgets';\nimport { ISetting, ISettingsGroup } from 'vs/workbench/services/preferences/common/preferences';\n\nconst $ = DOM.$;\n\nfunction getExcludeDisplayValue(element: SettingsTreeSettingElement): IExcludeDataItem[] {\n\tconst data = element.isConfigured ?\n\t\tobjects.mixin({ ...element.scopeValue }, element.defaultValue, false) :\n\t\telement.defaultValue;\n\n\treturn Object.keys(data)\n\t\t.filter(key => !!data[key])\n\t\t.map(key => {\n\t\t\tconst value = data[key];\n\t\t\tconst sibling = typeof value === 'boolean' ? undefined : value.when;\n\n\t\t\treturn {\n\t\t\t\tid: key,\n\t\t\t\tpattern: key,\n\t\t\t\tsibling\n\t\t\t};\n\t\t});\n}\n\nexport function resolveSettingsTree(tocData: ITOCEntry, coreSettingsGroups: ISettingsGroup[]): { tree: ITOCEntry, leftoverSettings: Set<ISetting> } {\n\tconst allSettings = getFlatSettings(coreSettingsGroups);\n\treturn {\n\t\ttree: _resolveSettingsTree(tocData, allSettings),\n\t\tleftoverSettings: allSettings\n\t};\n}\n\nexport function resolveExtensionsSettings(groups: ISettingsGroup[]): ITOCEntry {\n\tconst settingsGroupToEntry = (group: ISettingsGroup) => {\n\t\tconst flatSettings = arrays.flatten(\n\t\t\tgroup.sections.map(section => section.settings));\n\n\t\treturn {\n\t\t\tid: group.id,\n\t\t\tlabel: group.title,\n\t\t\tsettings: flatSettings\n\t\t};\n\t};\n\n\tconst extGroups = groups\n\t\t.sort((a, b) => a.title.localeCompare(b.title))\n\t\t.map(g => settingsGroupToEntry(g));\n\n\treturn {\n\t\tid: 'extensions',\n\t\tlabel: localize('extensions', \"Extensions\"),\n\t\tchildren: extGroups\n\t};\n}\n\nfunction _resolveSettingsTree(tocData: ITOCEntry, allSettings: Set<ISetting>): ITOCEntry {\n\tlet children: ITOCEntry[];\n\tif (tocData.children) {\n\t\tchildren = tocData.children\n\t\t\t.map(child => _resolveSettingsTree(child, allSettings))\n\t\t\t.filter(child => (child.children && child.children.length) || (child.settings && child.settings.length));\n\t}\n\n\tlet settings: ISetting[];\n\tif (tocData.settings) {\n\t\tsettings = arrays.flatten(tocData.settings.map(pattern => getMatchingSettings(allSettings, <string>pattern)));\n\t}\n\n\tif (!children && !settings) {\n\t\treturn null;\n\t}\n\n\treturn {\n\t\tid: tocData.id,\n\t\tlabel: tocData.label,\n\t\tchildren,\n\t\tsettings\n\t};\n}\n\nfunction getMatchingSettings(allSettings: Set<ISetting>, pattern: string): ISetting[] {\n\tconst result: ISetting[] = [];\n\n\tallSettings.forEach(s => {\n\t\tif (settingMatches(s, pattern)) {\n\t\t\tresult.push(s);\n\t\t\tallSettings.delete(s);\n\t\t}\n\t});\n\n\n\treturn result.sort((a, b) => a.key.localeCompare(b.key));\n}\n\nconst settingPatternCache = new Map<string, RegExp>();\n\nfunction createSettingMatchRegExp(pattern: string): RegExp {\n\tpattern = escapeRegExpCharacters(pattern)\n\t\t.replace(/\\\\\\*/g, '.*');\n\n\treturn new RegExp(`^${pattern}`, 'i');\n}\n\nfunction settingMatches(s: ISetting, pattern: string): boolean {\n\tlet regExp = settingPatternCache.get(pattern);\n\tif (!regExp) {\n\t\tregExp = createSettingMatchRegExp(pattern);\n\t\tsettingPatternCache.set(pattern, regExp);\n\t}\n\n\treturn regExp.test(s.key);\n}\n\nfunction getFlatSettings(settingsGroups: ISettingsGroup[]) {\n\tconst result: Set<ISetting> = new Set();\n\n\tfor (let group of settingsGroups) {\n\t\tfor (let section of group.sections) {\n\t\t\tfor (let s of section.settings) {\n\t\t\t\tif (!s.overrides || !s.overrides.length) {\n\t\t\t\t\tresult.add(s);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}\n\n\nexport class SettingsDataSource implements IDataSource {\n\n\tgetId(tree: ITree, element: SettingsTreeElement): string {\n\t\treturn element.id;\n\t}\n\n\thasChildren(tree: ITree, element: SettingsTreeElement): boolean {\n\t\tif (element instanceof SettingsTreeGroupElement) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tgetChildren(tree: ITree, element: SettingsTreeElement): TPromise<any> {\n\t\treturn TPromise.as(this._getChildren(element));\n\t}\n\n\tprivate _getChildren(element: SettingsTreeElement): SettingsTreeElement[] {\n\t\tif (element instanceof SettingsTreeGroupElement) {\n\t\t\treturn element.children;\n\t\t} else {\n\t\t\t// No children...\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tgetParent(tree: ITree, element: SettingsTreeElement): TPromise<any> {\n\t\treturn TPromise.wrap(element && element.parent);\n\t}\n\n\tshouldAutoexpand(): boolean {\n\t\treturn true;\n\t}\n}\n\ninterface IDisposableTemplate {\n\ttoDispose: IDisposable[];\n}\n\ninterface ISettingItemTemplate<T = any> extends IDisposableTemplate {\n\tonChange?: (value: T) => void;\n\n\tcontext?: SettingsTreeSettingElement;\n\tcontainerElement: HTMLElement;\n\tcategoryElement: HTMLElement;\n\tlabelElement: HTMLElement;\n\tdescriptionElement: HTMLElement;\n\tcontrolElement: HTMLElement;\n\tdeprecationWarningElement: HTMLElement;\n\totherOverridesElement: HTMLElement;\n\ttoolbar: ToolBar;\n}\n\ninterface ISettingBoolItemTemplate extends ISettingItemTemplate<boolean> {\n\tcheckbox: Checkbox;\n}\n\ninterface ISettingTextItemTemplate extends ISettingItemTemplate<string> {\n\tinputBox: InputBox;\n\tvalidationErrorMessageElement: HTMLElement;\n}\n\ntype ISettingNumberItemTemplate = ISettingTextItemTemplate;\n\ninterface ISettingEnumItemTemplate extends ISettingItemTemplate<number> {\n\tselectBox: SelectBox;\n\tenumDescriptionElement: HTMLElement;\n}\n\ninterface ISettingComplexItemTemplate extends ISettingItemTemplate<void> {\n\tbutton: Button;\n}\n\ninterface ISettingExcludeItemTemplate extends ISettingItemTemplate<void> {\n\texcludeWidget: ExcludeSettingWidget;\n}\n\ninterface ISettingNewExtensionsTemplate extends IDisposableTemplate {\n\tbutton: Button;\n\tcontext?: SettingsTreeNewExtensionsElement;\n}\n\ninterface IGroupTitleTemplate extends IDisposableTemplate {\n\tcontext?: SettingsTreeGroupElement;\n\tparent: HTMLElement;\n}\n\nconst SETTINGS_TEXT_TEMPLATE_ID = 'settings.text.template';\nconst SETTINGS_NUMBER_TEMPLATE_ID = 'settings.number.template';\nconst SETTINGS_ENUM_TEMPLATE_ID = 'settings.enum.template';\nconst SETTINGS_BOOL_TEMPLATE_ID = 'settings.bool.template';\nconst SETTINGS_EXCLUDE_TEMPLATE_ID = 'settings.exclude.template';\nconst SETTINGS_COMPLEX_TEMPLATE_ID = 'settings.complex.template';\nconst SETTINGS_NEW_EXTENSIONS_TEMPLATE_ID = 'settings.newExtensions.template';\nconst SETTINGS_GROUP_ELEMENT_TEMPLATE_ID = 'settings.group.template';\n\nexport interface ISettingChangeEvent {\n\tkey: string;\n\tvalue: any; // undefined => reset/unconfigure\n}\n\nexport class SettingsRenderer implements ITreeRenderer {\n\n\tpublic static readonly MAX_ENUM_DESCRIPTIONS = 10;\n\n\tpublic static readonly CONTROL_CLASS = 'setting-control-focus-target';\n\tpublic static readonly CONTROL_SELECTOR = '.' + SettingsRenderer.CONTROL_CLASS;\n\n\tpublic static readonly SETTING_KEY_ATTR = 'data-key';\n\n\tprivate readonly _onDidChangeSetting: Emitter<ISettingChangeEvent> = new Emitter<ISettingChangeEvent>();\n\tpublic readonly onDidChangeSetting: Event<ISettingChangeEvent> = this._onDidChangeSetting.event;\n\n\tprivate readonly _onDidOpenSettings: Emitter<string> = new Emitter<string>();\n\tpublic readonly onDidOpenSettings: Event<string> = this._onDidOpenSettings.event;\n\n\tprivate readonly _onDidClickSettingLink: Emitter<string> = new Emitter<string>();\n\tpublic readonly onDidClickSettingLink: Event<string> = this._onDidClickSettingLink.event;\n\n\tprivate readonly _onDidFocusSetting: Emitter<SettingsTreeSettingElement> = new Emitter<SettingsTreeSettingElement>();\n\tpublic readonly onDidFocusSetting: Event<SettingsTreeSettingElement> = this._onDidFocusSetting.event;\n\n\tprivate descriptionMeasureContainer: HTMLElement;\n\tprivate longestSingleLineDescription = 0;\n\n\tprivate rowHeightCache = new Map<string, number>();\n\tprivate lastRenderedWidth: number;\n\n\tprivate settingActions: IAction[];\n\n\tconstructor(\n\t\t_measureContainer: HTMLElement,\n\t\t@IThemeService private themeService: IThemeService,\n\t\t@IContextViewService private contextViewService: IContextViewService,\n\t\t@IOpenerService private readonly openerService: IOpenerService,\n\t\t@IInstantiationService private readonly instantiationService: IInstantiationService,\n\t\t@ICommandService private readonly commandService: ICommandService,\n\t\t@IContextMenuService private contextMenuService: IContextMenuService\n\t) {\n\t\tthis.descriptionMeasureContainer = $('.setting-item-description');\n\t\tDOM.append(_measureContainer,\n\t\t\t$('.setting-measure-container.monaco-tree-row', undefined,\n\t\t\t\t$('.setting-item', undefined,\n\t\t\t\t\tthis.descriptionMeasureContainer)));\n\n\t\tthis.settingActions = [\n\t\t\tthis.instantiationService.createInstance(CopySettingNameAction),\n\t\t\tthis.instantiationService.createInstance(CopySettingIdAction),\n\t\t\tthis.instantiationService.createInstance(CopySettingAsJSONAction),\n\t\t\tnew Separator(),\n\t\t\tnew Action('settings.resetSetting', localize('resetSettingLabel', \"Reset Setting\"), undefined, undefined, (context: SettingsTreeSettingElement) => {\n\t\t\t\tif (context) {\n\t\t\t\t\tthis._onDidChangeSetting.fire({ key: context.setting.key, value: undefined });\n\t\t\t\t}\n\n\t\t\t\treturn TPromise.wrap(null);\n\t\t\t})\n\t\t];\n\t}\n\n\tshowContextMenu(element: SettingsTreeSettingElement, settingDOMElement: HTMLElement): void {\n\t\tconst toolbarElement: HTMLElement = settingDOMElement.querySelector('.toolbar-toggle-more');\n\t\tif (toolbarElement) {\n\t\t\tthis.contextMenuService.showContextMenu({\n\t\t\t\tgetActions: () => TPromise.wrap(this.settingActions),\n\t\t\t\tgetAnchor: () => toolbarElement,\n\t\t\t\tgetActionsContext: () => element\n\t\t\t});\n\t\t}\n\t}\n\n\tupdateWidth(width: number): void {\n\t\tif (this.lastRenderedWidth !== width) {\n\t\t\tthis.rowHeightCache = new Map<string, number>();\n\t\t}\n\t\tthis.longestSingleLineDescription = 0;\n\n\t\tthis.lastRenderedWidth = width;\n\t}\n\n\tgetHeight(tree: ITree, element: SettingsTreeElement): number {\n\t\tif (this.rowHeightCache.has(element.id) && !(element instanceof SettingsTreeSettingElement && isExcludeSetting(element.setting))) {\n\t\t\treturn this.rowHeightCache.get(element.id);\n\t\t}\n\n\t\tconst h = this._getHeight(tree, element);\n\t\tthis.rowHeightCache.set(element.id, h);\n\t\treturn h;\n\t}\n\n\t_getHeight(tree: ITree, element: SettingsTreeElement): number {\n\t\tif (element instanceof SettingsTreeGroupElement) {\n\t\t\tif (element.isFirstGroup) {\n\t\t\t\treturn 31;\n\t\t\t}\n\n\t\t\treturn 40 + (7 * element.level);\n\t\t}\n\n\t\tif (element instanceof SettingsTreeSettingElement) {\n\t\t\tif (isExcludeSetting(element.setting)) {\n\t\t\t\treturn this._getExcludeSettingHeight(element);\n\t\t\t} else {\n\t\t\t\treturn this.measureSettingElementHeight(tree, element);\n\t\t\t}\n\t\t}\n\n\t\tif (element instanceof SettingsTreeNewExtensionsElement) {\n\t\t\treturn 40;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t_getExcludeSettingHeight(element: SettingsTreeSettingElement): number {\n\t\tconst displayValue = getExcludeDisplayValue(element);\n\t\treturn (displayValue.length + 1) * 22 + 66 + this.measureSettingDescription(element);\n\t}\n\n\tprivate measureSettingElementHeight(tree: ITree, element: SettingsTreeSettingElement): number {\n\t\tlet heightExcludingDescription = 86;\n\n\t\tif (element.valueType === 'boolean') {\n\t\t\theightExcludingDescription = 60;\n\t\t}\n\n\t\treturn heightExcludingDescription + this.measureSettingDescription(element);\n\t}\n\n\tprivate measureSettingDescription(element: SettingsTreeSettingElement): number {\n\t\tif (element.description.length < this.longestSingleLineDescription * .8) {\n\t\t\t// Most setting descriptions are one short line, so try to avoid measuring them.\n\t\t\t// If the description is less than 80% of the longest single line description, assume this will also render to be one line.\n\t\t\treturn 18;\n\t\t}\n\n\t\tconst boolMeasureClass = 'measure-bool-description';\n\t\tif (element.valueType === 'boolean') {\n\t\t\tthis.descriptionMeasureContainer.classList.add(boolMeasureClass);\n\t\t} else if (this.descriptionMeasureContainer.classList.contains(boolMeasureClass)) {\n\t\t\tthis.descriptionMeasureContainer.classList.remove(boolMeasureClass);\n\t\t}\n\n\t\t// Remove markdown links and setting links\n\t\tconst measureText = element.description\n\t\t\t.replace(/\\[(.*)\\]\\(.*\\)/g, '$1')\n\t\t\t.replace(/`#(.*)#`/g, '$1');\n\n\t\tthis.descriptionMeasureContainer.innerText = measureText;\n\t\tconst h = this.descriptionMeasureContainer.offsetHeight;\n\t\tif (h < 20 && measureText.length > this.longestSingleLineDescription) {\n\t\t\tthis.longestSingleLineDescription = measureText.length;\n\t\t}\n\n\t\treturn h;\n\t}\n\n\tgetTemplateId(tree: ITree, element: SettingsTreeElement): string {\n\t\tif (element instanceof SettingsTreeGroupElement) {\n\t\t\treturn SETTINGS_GROUP_ELEMENT_TEMPLATE_ID;\n\t\t}\n\n\t\tif (element instanceof SettingsTreeSettingElement) {\n\t\t\tif (element.valueType === 'boolean') {\n\t\t\t\treturn SETTINGS_BOOL_TEMPLATE_ID;\n\t\t\t}\n\n\t\t\tif (element.valueType === 'integer' || element.valueType === 'number' || element.valueType === 'nullable-integer' || element.valueType === 'nullable-number') {\n\t\t\t\treturn SETTINGS_NUMBER_TEMPLATE_ID;\n\t\t\t}\n\n\t\t\tif (element.valueType === 'string') {\n\t\t\t\treturn SETTINGS_TEXT_TEMPLATE_ID;\n\t\t\t}\n\n\t\t\tif (element.valueType === 'enum') {\n\t\t\t\treturn SETTINGS_ENUM_TEMPLATE_ID;\n\t\t\t}\n\n\t\t\tif (element.valueType === 'exclude') {\n\t\t\t\treturn SETTINGS_EXCLUDE_TEMPLATE_ID;\n\t\t\t}\n\n\t\t\treturn SETTINGS_COMPLEX_TEMPLATE_ID;\n\t\t}\n\n\t\tif (element instanceof SettingsTreeNewExtensionsElement) {\n\t\t\treturn SETTINGS_NEW_EXTENSIONS_TEMPLATE_ID;\n\t\t}\n\n\t\treturn '';\n\t}\n\n\trenderTemplate(tree: ITree, templateId: string, container: HTMLElement) {\n\t\tif (templateId === SETTINGS_GROUP_ELEMENT_TEMPLATE_ID) {\n\t\t\treturn this.renderGroupTitleTemplate(container);\n\t\t}\n\n\t\tif (templateId === SETTINGS_TEXT_TEMPLATE_ID) {\n\t\t\treturn this.renderSettingTextTemplate(tree, container);\n\t\t}\n\n\t\tif (templateId === SETTINGS_NUMBER_TEMPLATE_ID) {\n\t\t\treturn this.renderSettingNumberTemplate(tree, container);\n\t\t}\n\n\t\tif (templateId === SETTINGS_BOOL_TEMPLATE_ID) {\n\t\t\treturn this.renderSettingBoolTemplate(tree, container);\n\t\t}\n\n\t\tif (templateId === SETTINGS_ENUM_TEMPLATE_ID) {\n\t\t\treturn this.renderSettingEnumTemplate(tree, container);\n\t\t}\n\n\t\tif (templateId === SETTINGS_EXCLUDE_TEMPLATE_ID) {\n\t\t\treturn this.renderSettingExcludeTemplate(tree, container);\n\t\t}\n\n\t\tif (templateId === SETTINGS_COMPLEX_TEMPLATE_ID) {\n\t\t\treturn this.renderSettingComplexTemplate(tree, container);\n\t\t}\n\n\t\tif (templateId === SETTINGS_NEW_EXTENSIONS_TEMPLATE_ID) {\n\t\t\treturn this.renderNewExtensionsTemplate(container);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate renderGroupTitleTemplate(container: HTMLElement): IGroupTitleTemplate {\n\t\tDOM.addClass(container, 'group-title');\n\n\t\tconst toDispose = [];\n\t\tconst template: IGroupTitleTemplate = {\n\t\t\tparent: container,\n\t\t\ttoDispose\n\t\t};\n\n\t\treturn template;\n\t}\n\n\tprivate renderCommonTemplate(tree: ITree, container: HTMLElement, typeClass: string): ISettingItemTemplate {\n\t\tDOM.addClass(container, 'setting-item');\n\t\tDOM.addClass(container, 'setting-item-' + typeClass);\n\t\tconst titleElement = DOM.append(container, $('.setting-item-title'));\n\t\tconst labelCategoryContainer = DOM.append(titleElement, $('.setting-item-cat-label-container'));\n\t\tconst categoryElement = DOM.append(labelCategoryContainer, $('span.setting-item-category'));\n\t\tconst labelElement = DOM.append(labelCategoryContainer, $('span.setting-item-label'));\n\t\tconst otherOverridesElement = DOM.append(titleElement, $('span.setting-item-overrides'));\n\t\tconst descriptionElement = DOM.append(container, $('.setting-item-description'));\n\n\t\tconst valueElement = DOM.append(container, $('.setting-item-value'));\n\t\tconst controlElement = DOM.append(valueElement, $('div.setting-item-control'));\n\n\t\tconst deprecationWarningElement = DOM.append(container, $('.setting-item-deprecation-message'));\n\n\t\tconst toDispose = [];\n\n\t\tconst toolbar = this.renderSettingToolbar(container);\n\n\t\tconst template: ISettingItemTemplate = {\n\t\t\ttoDispose,\n\n\t\t\tcontainerElement: container,\n\t\t\tcategoryElement,\n\t\t\tlabelElement,\n\t\t\tdescriptionElement,\n\t\t\tcontrolElement,\n\t\t\tdeprecationWarningElement,\n\t\t\totherOverridesElement,\n\t\t\ttoolbar\n\t\t};\n\n\t\t// Prevent clicks from being handled by list\n\t\ttoDispose.push(DOM.addDisposableListener(controlElement, 'mousedown', (e: IMouseEvent) => e.stopPropagation()));\n\n\t\ttoDispose.push(DOM.addStandardDisposableListener(valueElement, 'keydown', (e: StandardKeyboardEvent) => {\n\t\t\tif (e.keyCode === KeyCode.Escape) {\n\t\t\t\ttree.domFocus();\n\t\t\t\te.browserEvent.stopPropagation();\n\t\t\t}\n\t\t}));\n\n\t\treturn template;\n\t}\n\n\tprivate addSettingElementFocusHandler(template: ISettingItemTemplate): void {\n\t\tconst focusTracker = DOM.trackFocus(template.containerElement);\n\t\ttemplate.toDispose.push(focusTracker);\n\t\tfocusTracker.onDidBlur(() => {\n\t\t\tif (template.containerElement.classList.contains('focused')) {\n\t\t\t\ttemplate.containerElement.classList.remove('focused');\n\t\t\t}\n\t\t});\n\n\t\tfocusTracker.onDidFocus(() => {\n\t\t\ttemplate.containerElement.classList.add('focused');\n\n\t\t\tif (template.context) {\n\t\t\t\tthis._onDidFocusSetting.fire(template.context);\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate renderSettingTextTemplate(tree: ITree, container: HTMLElement, type = 'text'): ISettingTextItemTemplate {\n\t\tconst common = this.renderCommonTemplate(tree, container, 'text');\n\t\tconst validationErrorMessageElement = DOM.append(container, $('.setting-item-validation-message'));\n\n\t\tconst inputBox = new InputBox(common.controlElement, this.contextViewService);\n\t\tcommon.toDispose.push(inputBox);\n\t\tcommon.toDispose.push(attachInputBoxStyler(inputBox, this.themeService, {\n\t\t\tinputBackground: settingsTextInputBackground,\n\t\t\tinputForeground: settingsTextInputForeground,\n\t\t\tinputBorder: settingsTextInputBorder\n\t\t}));\n\t\tcommon.toDispose.push(\n\t\t\tinputBox.onDidChange(e => {\n\t\t\t\tif (template.onChange) {\n\t\t\t\t\ttemplate.onChange(e);\n\t\t\t\t}\n\t\t\t}));\n\t\tcommon.toDispose.push(inputBox);\n\t\tinputBox.inputElement.classList.add(SettingsRenderer.CONTROL_CLASS);\n\n\t\tconst template: ISettingTextItemTemplate = {\n\t\t\t...common,\n\t\t\tinputBox,\n\t\t\tvalidationErrorMessageElement\n\t\t};\n\n\t\tthis.addSettingElementFocusHandler(template);\n\n\t\treturn template;\n\t}\n\n\tprivate renderSettingNumberTemplate(tree: ITree, container: HTMLElement): ISettingNumberItemTemplate {\n\t\tconst common = this.renderCommonTemplate(tree, container, 'number');\n\t\tconst validationErrorMessageElement = DOM.append(container, $('.setting-item-validation-message'));\n\n\t\tconst inputBox = new InputBox(common.controlElement, this.contextViewService, { type: 'number' });\n\t\tcommon.toDispose.push(inputBox);\n\t\tcommon.toDispose.push(attachInputBoxStyler(inputBox, this.themeService, {\n\t\t\tinputBackground: settingsNumberInputBackground,\n\t\t\tinputForeground: settingsNumberInputForeground,\n\t\t\tinputBorder: settingsNumberInputBorder\n\t\t}));\n\t\tcommon.toDispose.push(\n\t\t\tinputBox.onDidChange(e => {\n\t\t\t\tif (template.onChange) {\n\t\t\t\t\ttemplate.onChange(e);\n\t\t\t\t}\n\t\t\t}));\n\t\tcommon.toDispose.push(inputBox);\n\t\tinputBox.inputElement.classList.add(SettingsRenderer.CONTROL_CLASS);\n\n\t\tconst template: ISettingNumberItemTemplate = {\n\t\t\t...common,\n\t\t\tinputBox,\n\t\t\tvalidationErrorMessageElement\n\t\t};\n\n\t\tthis.addSettingElementFocusHandler(template);\n\n\t\treturn template;\n\t}\n\n\tprivate renderSettingToolbar(container: HTMLElement): ToolBar {\n\t\tconst toolbar = new ToolBar(container, this.contextMenuService, {});\n\t\ttoolbar.setActions([], this.settingActions)();\n\t\tconst button = container.querySelector('.toolbar-toggle-more');\n\t\tif (button) {\n\t\t\t(<HTMLElement>button).tabIndex = -1;\n\t\t}\n\n\t\treturn toolbar;\n\t}\n\n\tprivate renderSettingBoolTemplate(tree: ITree, container: HTMLElement): ISettingBoolItemTemplate {\n\t\tDOM.addClass(container, 'setting-item');\n\t\tDOM.addClass(container, 'setting-item-bool');\n\n\t\tconst titleElement = DOM.append(container, $('.setting-item-title'));\n\t\tconst categoryElement = DOM.append(titleElement, $('span.setting-item-category'));\n\t\tconst labelElement = DOM.append(titleElement, $('span.setting-item-label'));\n\t\tconst otherOverridesElement = DOM.append(titleElement, $('span.setting-item-overrides'));\n\n\t\tconst descriptionAndValueElement = DOM.append(container, $('.setting-item-value-description'));\n\t\tconst controlElement = DOM.append(descriptionAndValueElement, $('.setting-item-bool-control'));\n\t\tconst descriptionElement = DOM.append(descriptionAndValueElement, $('.setting-item-description'));\n\n\t\tconst deprecationWarningElement = DOM.append(container, $('.setting-item-deprecation-message'));\n\n\t\tconst toDispose = [];\n\t\tconst checkbox = new Checkbox({ actionClassName: 'setting-value-checkbox', isChecked: true, title: '', inputActiveOptionBorder: null });\n\t\tcontrolElement.appendChild(checkbox.domNode);\n\t\ttoDispose.push(checkbox);\n\t\ttoDispose.push(checkbox.onChange(() => {\n\t\t\tif (template.onChange) {\n\t\t\t\ttemplate.onChange(checkbox.checked);\n\t\t\t}\n\t\t}));\n\n\t\t// Need to listen for mouse clicks on description and toggle checkbox - use target ID for safety\n\t\t// Also have to ignore embedded links - too buried to stop propagation\n\t\ttoDispose.push(DOM.addDisposableListener(descriptionElement, DOM.EventType.MOUSE_DOWN, (e) => {\n\t\t\tconst targetElement = <HTMLElement>e.toElement;\n\t\t\tconst targetId = descriptionElement.getAttribute('checkbox-label-target-id');\n\n\t\t\t// Make sure we are not a link and the target ID matches\n\t\t\t// Toggle target checkbox\n\t\t\tif (targetElement.tagName.toLowerCase() !== 'a' && targetId === template.checkbox.domNode.id) {\n\t\t\t\ttemplate.checkbox.checked = template.checkbox.checked ? false : true;\n\t\t\t}\n\t\t\tDOM.EventHelper.stop(e);\n\t\t}));\n\n\t\tcheckbox.domNode.classList.add(SettingsRenderer.CONTROL_CLASS);\n\t\tconst toolbar = this.renderSettingToolbar(container);\n\t\ttoDispose.push(toolbar);\n\n\t\tconst template: ISettingBoolItemTemplate = {\n\t\t\ttoDispose,\n\n\t\t\tcontainerElement: container,\n\t\t\tcategoryElement,\n\t\t\tlabelElement,\n\t\t\tcontrolElement,\n\t\t\tcheckbox,\n\t\t\tdescriptionElement,\n\t\t\tdeprecationWarningElement,\n\t\t\totherOverridesElement,\n\t\t\ttoolbar\n\t\t};\n\n\t\tthis.addSettingElementFocusHandler(template);\n\n\t\t// Prevent clicks from being handled by list\n\t\ttoDispose.push(DOM.addDisposableListener(controlElement, 'mousedown', (e: IMouseEvent) => e.stopPropagation()));\n\n\t\ttoDispose.push(DOM.addStandardDisposableListener(controlElement, 'keydown', (e: StandardKeyboardEvent) => {\n\t\t\tif (e.keyCode === KeyCode.Escape) {\n\t\t\t\ttree.domFocus();\n\t\t\t\te.browserEvent.stopPropagation();\n\t\t\t}\n\t\t}));\n\n\t\treturn template;\n\t}\n\n\tpublic cancelSuggesters() {\n\t\tthis.contextViewService.hideContextView();\n\t}\n\n\tprivate renderSettingEnumTemplate(tree: ITree, container: HTMLElement): ISettingEnumItemTemplate {\n\t\tconst common = this.renderCommonTemplate(tree, container, 'enum');\n\n\t\tconst selectBox = new SelectBox([], undefined, this.contextViewService, undefined, {\n\t\t\thasDetails: true, markdownActionHandler: {\n\t\t\t\tcallback: (content: string) => {\n\t\t\t\t\tif (startsWith(content, '#')) {\n\t\t\t\t\t\tthis._onDidClickSettingLink.fire(content.substr(1));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.openerService.open(URI.parse(content)).then(void 0, onUnexpectedError);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tdisposeables: common.toDispose\n\t\t\t}\n\t\t});\n\n\t\tcommon.toDispose.push(selectBox);\n\t\tcommon.toDispose.push(attachSelectBoxStyler(selectBox, this.themeService, {\n\t\t\tselectBackground: settingsSelectBackground,\n\t\t\tselectForeground: settingsSelectForeground,\n\t\t\tselectBorder: settingsSelectBorder,\n\t\t\tselectListBorder: settingsSelectListBorder\n\t\t}));\n\t\tselectBox.render(common.controlElement);\n\t\tconst selectElement = common.controlElement.querySelector('select');\n\t\tif (selectElement) {\n\t\t\tselectElement.classList.add(SettingsRenderer.CONTROL_CLASS);\n\t\t}\n\n\t\tcommon.toDispose.push(\n\t\t\tselectBox.onDidSelect(e => {\n\t\t\t\tif (template.onChange) {\n\t\t\t\t\ttemplate.onChange(e.index);\n\t\t\t\t}\n\t\t\t}));\n\n\t\tconst enumDescriptionElement = common.containerElement.insertBefore($('.setting-item-enumDescription'), common.descriptionElement.nextSibling);\n\n\t\tconst template: ISettingEnumItemTemplate = {\n\t\t\t...common,\n\t\t\tselectBox,\n\t\t\tenumDescriptionElement\n\t\t};\n\n\t\tthis.addSettingElementFocusHandler(template);\n\n\t\treturn template;\n\t}\n\n\tprivate renderSettingExcludeTemplate(tree: ITree, container: HTMLElement): ISettingExcludeItemTemplate {\n\t\tconst common = this.renderCommonTemplate(tree, container, 'exclude');\n\n\t\tconst excludeWidget = this.instantiationService.createInstance(ExcludeSettingWidget, common.controlElement);\n\t\texcludeWidget.domNode.classList.add(SettingsRenderer.CONTROL_CLASS);\n\t\tcommon.toDispose.push(excludeWidget);\n\n\t\tconst template: ISettingExcludeItemTemplate = {\n\t\t\t...common,\n\t\t\texcludeWidget\n\t\t};\n\n\t\tthis.addSettingElementFocusHandler(template);\n\n\t\tcommon.toDispose.push(excludeWidget.onDidChangeExclude(e => {\n\t\t\tif (template.context) {\n\t\t\t\tconst newValue = {\n\t\t\t\t\t...template.context.scopeValue\n\t\t\t\t};\n\n\t\t\t\tif (e.pattern) {\n\t\t\t\t\tif (e.originalPattern in newValue) {\n\t\t\t\t\t\t// editing something present in the value\n\t\t\t\t\t\tnewValue[e.pattern] = newValue[e.originalPattern];\n\t\t\t\t\t\tdelete newValue[e.originalPattern];\n\t\t\t\t\t} else if (e.originalPattern) {\n\t\t\t\t\t\t// editing a default\n\t\t\t\t\t\tnewValue[e.originalPattern] = false;\n\t\t\t\t\t\tnewValue[e.pattern] = template.context.defaultValue[e.originalPattern];\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// adding a new pattern\n\t\t\t\t\t\tnewValue[e.pattern] = true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (e.originalPattern in newValue) {\n\t\t\t\t\t\t// deleting a configured pattern\n\t\t\t\t\t\tdelete newValue[e.originalPattern];\n\t\t\t\t\t} else if (e.originalPattern) {\n\t\t\t\t\t\t// \"deleting\" a default by overriding it\n\t\t\t\t\t\tnewValue[e.originalPattern] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis._onDidChangeSetting.fire({\n\t\t\t\t\tkey: template.context.setting.key,\n\t\t\t\t\tvalue: newValue\n\t\t\t\t});\n\t\t\t}\n\t\t}));\n\n\t\treturn template;\n\t}\n\n\tprivate renderSettingComplexTemplate(tree: ITree, container: HTMLElement): ISettingComplexItemTemplate {\n\t\tconst common = this.renderCommonTemplate(tree, container, 'complex');\n\n\t\tconst openSettingsButton = new Button(common.controlElement, { title: true, buttonBackground: null, buttonHoverBackground: null });\n\t\tcommon.toDispose.push(openSettingsButton);\n\t\tcommon.toDispose.push(openSettingsButton.onDidClick(() => template.onChange(null)));\n\t\topenSettingsButton.label = localize('editInSettingsJson', \"Edit in settings.json\");\n\t\topenSettingsButton.element.classList.add('edit-in-settings-button');\n\n\t\tcommon.toDispose.push(attachButtonStyler(openSettingsButton, this.themeService, {\n\t\t\tbuttonBackground: Color.transparent.toString(),\n\t\t\tbuttonHoverBackground: Color.transparent.toString(),\n\t\t\tbuttonForeground: 'foreground'\n\t\t}));\n\n\t\tconst template: ISettingComplexItemTemplate = {\n\t\t\t...common,\n\t\t\tbutton: openSettingsButton\n\t\t};\n\n\t\tthis.addSettingElementFocusHandler(template);\n\n\t\treturn template;\n\t}\n\n\tprivate renderNewExtensionsTemplate(container: HTMLElement): ISettingNewExtensionsTemplate {\n\t\tconst toDispose = [];\n\n\t\tcontainer.classList.add('setting-item-new-extensions');\n\n\t\tconst button = new Button(container, { title: true, buttonBackground: null, buttonHoverBackground: null });\n\t\ttoDispose.push(button);\n\t\ttoDispose.push(button.onDidClick(() => {\n\t\t\tif (template.context) {\n\t\t\t\tthis.commandService.executeCommand('workbench.extensions.action.showExtensionsWithIds', template.context.extensionIds);\n\t\t\t}\n\t\t}));\n\t\tbutton.label = localize('newExtensionsButtonLabel', \"Show other matching extensions\");\n\t\tbutton.element.classList.add('settings-new-extensions-button');\n\t\ttoDispose.push(attachButtonStyler(button, this.themeService));\n\n\t\tconst template: ISettingNewExtensionsTemplate = {\n\t\t\tbutton,\n\t\t\ttoDispose\n\t\t};\n\n\t\t// this.addSettingElementFocusHandler(template);\n\n\t\treturn template;\n\t}\n\n\trenderElement(tree: ITree, element: SettingsTreeElement, templateId: string, template: any): void {\n\t\tif (templateId === SETTINGS_GROUP_ELEMENT_TEMPLATE_ID) {\n\t\t\treturn this.renderGroupElement(<SettingsTreeGroupElement>element, template);\n\t\t}\n\n\t\tif (templateId === SETTINGS_NEW_EXTENSIONS_TEMPLATE_ID) {\n\t\t\treturn this.renderNewExtensionsElement(<SettingsTreeNewExtensionsElement>element, template);\n\t\t}\n\n\t\treturn this.renderSettingElement(tree, <SettingsTreeSettingElement>element, templateId, template);\n\t}\n\n\tprivate renderGroupElement(element: SettingsTreeGroupElement, template: IGroupTitleTemplate): void {\n\t\ttemplate.parent.innerHTML = '';\n\t\tconst labelElement = DOM.append(template.parent, $('div.settings-group-title-label'));\n\t\tlabelElement.classList.add(`settings-group-level-${element.level}`);\n\t\tlabelElement.textContent = (<SettingsTreeGroupElement>element).label;\n\n\t\tif (element.isFirstGroup) {\n\t\t\tlabelElement.classList.add('settings-group-first');\n\t\t}\n\t}\n\n\tprivate renderNewExtensionsElement(element: SettingsTreeNewExtensionsElement, template: ISettingNewExtensionsTemplate): void {\n\t\ttemplate.context = element;\n\t}\n\n\tpublic getSettingDOMElementForDOMElement(domElement: HTMLElement): HTMLElement {\n\t\tconst parent = DOM.findParentWithClass(domElement, 'setting-item');\n\t\tif (parent) {\n\t\t\treturn parent;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpublic getDOMElementsForSettingKey(treeContainer: HTMLElement, key: string): NodeListOf<HTMLElement> {\n\t\treturn treeContainer.querySelectorAll(`[${SettingsRenderer.SETTING_KEY_ATTR}=\"${key}\"]`);\n\t}\n\n\tpublic getKeyForDOMElementInSetting(element: HTMLElement): string {\n\t\tconst settingElement = this.getSettingDOMElementForDOMElement(element);\n\t\treturn settingElement && settingElement.getAttribute(SettingsRenderer.SETTING_KEY_ATTR);\n\t}\n\n\tprivate renderSettingElement(tree: ITree, element: SettingsTreeSettingElement, templateId: string, template: ISettingItemTemplate | ISettingBoolItemTemplate): void {\n\t\ttemplate.context = element;\n\t\ttemplate.toolbar.context = element;\n\n\t\tconst setting = element.setting;\n\n\t\tDOM.toggleClass(template.containerElement, 'is-configured', element.isConfigured);\n\t\tDOM.toggleClass(template.containerElement, 'is-expanded', true);\n\t\ttemplate.containerElement.setAttribute(SettingsRenderer.SETTING_KEY_ATTR, element.setting.key);\n\n\t\tconst titleTooltip = setting.key + (element.isConfigured ? ' - Modified' : '');\n\t\ttemplate.categoryElement.textContent = element.displayCategory && (element.displayCategory + ': ');\n\t\ttemplate.categoryElement.title = titleTooltip;\n\n\t\ttemplate.labelElement.textContent = element.displayLabel;\n\t\ttemplate.labelElement.title = titleTooltip;\n\n\t\tthis.renderValue(element, templateId, <ISettingItemTemplate>template);\n\t\ttemplate.descriptionElement.innerHTML = '';\n\t\tif (element.setting.descriptionIsMarkdown) {\n\t\t\tconst renderedDescription = this.renderDescriptionMarkdown(element.description, template.toDispose);\n\t\t\ttemplate.descriptionElement.appendChild(renderedDescription);\n\t\t} else {\n\t\t\ttemplate.descriptionElement.innerText = element.description;\n\t\t}\n\n\t\tif (templateId === SETTINGS_BOOL_TEMPLATE_ID) {\n\t\t\t// Add checkbox target to description clickable and able to toggle checkbox\n\t\t\tconst checkbox_id = (element.displayCategory + '_' + element.displayLabel).replace(/ /g, '_') + '_Item';\n\t\t\ttemplate.descriptionElement.setAttribute('checkbox-label-target-id', checkbox_id);\n\t\t}\n\n\t\tif (element.overriddenScopeList.length) {\n\t\t\tlet otherOverridesLabel = element.isConfigured ?\n\t\t\t\tlocalize('alsoConfiguredIn', \"Also modified in\") :\n\t\t\t\tlocalize('configuredIn', \"Modified in\");\n\n\t\t\ttemplate.otherOverridesElement.textContent = `(${otherOverridesLabel}: ${element.overriddenScopeList.join(', ')})`;\n\t\t} else {\n\t\t\ttemplate.otherOverridesElement.textContent = '';\n\t\t}\n\t}\n\n\tprivate renderDescriptionMarkdown(text: string, disposeables: IDisposable[]): HTMLElement {\n\t\t// Rewrite `#editor.fontSize#` to link format\n\t\ttext = fixSettingLinks(text);\n\n\t\tconst renderedMarkdown = renderMarkdown({ value: text }, {\n\t\t\tactionHandler: {\n\t\t\t\tcallback: (content: string) => {\n\t\t\t\t\tif (startsWith(content, '#')) {\n\t\t\t\t\t\tthis._onDidClickSettingLink.fire(content.substr(1));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.openerService.open(URI.parse(content)).then(void 0, onUnexpectedError);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tdisposeables\n\t\t\t}\n\t\t});\n\n\t\trenderedMarkdown.classList.add('setting-item-description-markdown');\n\t\tcleanRenderedMarkdown(renderedMarkdown);\n\t\treturn renderedMarkdown;\n\t}\n\n\tprivate renderValue(element: SettingsTreeSettingElement, templateId: string, template: ISettingItemTemplate | ISettingBoolItemTemplate): void {\n\t\tconst onChange = value => this._onDidChangeSetting.fire({ key: element.setting.key, value });\n\t\ttemplate.deprecationWarningElement.innerText = element.setting.deprecationMessage || '';\n\n\t\tif (templateId === SETTINGS_ENUM_TEMPLATE_ID) {\n\t\t\tthis.renderEnum(element, <ISettingEnumItemTemplate>template, onChange);\n\t\t} else if (templateId === SETTINGS_TEXT_TEMPLATE_ID) {\n\t\t\tthis.renderText(element, <ISettingTextItemTemplate>template, onChange);\n\t\t} else if (templateId === SETTINGS_NUMBER_TEMPLATE_ID) {\n\t\t\tthis.renderNumber(element, <ISettingTextItemTemplate>template, onChange);\n\t\t} else if (templateId === SETTINGS_BOOL_TEMPLATE_ID) {\n\t\t\tthis.renderBool(element, <ISettingBoolItemTemplate>template, onChange);\n\t\t} else if (templateId === SETTINGS_EXCLUDE_TEMPLATE_ID) {\n\t\t\tthis.renderExcludeSetting(element, <ISettingExcludeItemTemplate>template);\n\t\t} else if (templateId === SETTINGS_COMPLEX_TEMPLATE_ID) {\n\t\t\tthis.renderComplexSetting(element, <ISettingComplexItemTemplate>template);\n\t\t}\n\t}\n\n\tprivate renderBool(dataElement: SettingsTreeSettingElement, template: ISettingBoolItemTemplate, onChange: (value: boolean) => void): void {\n\t\ttemplate.onChange = null;\n\t\ttemplate.checkbox.checked = dataElement.value;\n\t\ttemplate.onChange = onChange;\n\n\t\t// Setup and add ARIA attributes\n\t\t// Create id and label for control/input element - parent is wrapper div\n\t\tconst id = (dataElement.displayCategory + '_' + dataElement.displayLabel).replace(/ /g, '_');\n\t\tconst modifiedText = dataElement.isConfigured ? 'Modified' : '';\n\t\tconst label = ' ' + dataElement.displayCategory + ' ' + dataElement.displayLabel + ' checkbox ' + (dataElement.value ? 'checked ' : 'unchecked ') + modifiedText;\n\n\t\t// We use the parent control div for the aria-labelledby target\n\t\t// Does not appear you can use the direct label on the element itself within a tree\n\t\ttemplate.checkbox.domNode.parentElement.setAttribute('id', id);\n\t\ttemplate.checkbox.domNode.parentElement.setAttribute('aria-label', label);\n\n\t\t// Labels will not be read on descendent input elements of the parent treeitem\n\t\t// unless defined as role=treeitem and indirect aria-labelledby approach\n\t\t// TODO: Determine method to normally label input items with value read last\n\t\ttemplate.checkbox.domNode.setAttribute('id', id + '_Item');\n\t\ttemplate.checkbox.domNode.setAttribute('role', 'treeitem');\n\t\ttemplate.checkbox.domNode.setAttribute('aria-labelledby', id + '_Item ' + id);\n\n\t}\n\n\tprivate renderEnum(dataElement: SettingsTreeSettingElement, template: ISettingEnumItemTemplate, onChange: (value: string) => void): void {\n\t\tconst displayOptions = getDisplayEnumOptions(dataElement.setting);\n\t\ttemplate.selectBox.setOptions(displayOptions);\n\t\tconst descriptions = dataElement.setting.enumDescriptions;\n\t\tconst descriptionsAreMarkdown = dataElement.setting.descriptionIsMarkdown;\n\t\ttemplate.selectBox.setDetailsProvider(index =>\n\t\t\t({\n\t\t\t\tdetails: descriptions && descriptions[index] && (descriptionsAreMarkdown ? fixSettingLinks(descriptions[index]) : descriptions[index]),\n\t\t\t\tisMarkdown: descriptionsAreMarkdown\n\t\t\t}));\n\n\t\tconst modifiedText = dataElement.isConfigured ? 'Modified' : '';\n\t\tconst label = ' ' + dataElement.displayCategory + ' ' + dataElement.displayLabel + ' combobox ' + modifiedText;\n\n\t\ttemplate.selectBox.setAriaLabel(label);\n\n\t\tconst idx = dataElement.setting.enum.indexOf(dataElement.value);\n\t\ttemplate.onChange = null;\n\t\ttemplate.selectBox.select(idx);\n\t\ttemplate.onChange = idx => onChange(dataElement.setting.enum[idx]);\n\n\t\tif (template.controlElement.firstElementChild) {\n\t\t\t// SelectBox needs to be treeitem to read correctly within tree\n\t\t\ttemplate.controlElement.firstElementChild.setAttribute('role', 'treeitem');\n\t\t}\n\n\t\ttemplate.enumDescriptionElement.innerHTML = '';\n\t}\n\n\tprivate renderText(dataElement: SettingsTreeSettingElement, template: ISettingTextItemTemplate, onChange: (value: string) => void): void {\n\t\tconst modifiedText = dataElement.isConfigured ? 'Modified' : '';\n\t\tconst label = ' ' + dataElement.displayCategory + ' ' + dataElement.displayLabel + ' ' + modifiedText;\n\t\ttemplate.onChange = null;\n\t\ttemplate.inputBox.value = dataElement.value;\n\t\ttemplate.onChange = value => { renderValidations(dataElement, template, false, label); onChange(value); };\n\n\t\t// Setup and add ARIA attributes\n\t\t// Create id and label for control/input element - parent is wrapper div\n\t\tconst id = (dataElement.displayCategory + '_' + dataElement.displayLabel).replace(/ /g, '_');\n\n\t\t// We use the parent control div for the aria-labelledby target\n\t\t// Does not appear you can use the direct label on the element itself within a tree\n\t\ttemplate.inputBox.inputElement.parentElement.setAttribute('id', id);\n\t\ttemplate.inputBox.inputElement.parentElement.setAttribute('aria-label', label);\n\n\t\t// Labels will not be read on descendent input elements of the parent treeitem\n\t\t// unless defined as role=treeitem and indirect aria-labelledby approach\n\t\t// TODO: Determine method to normally label input items with value read last\n\t\ttemplate.inputBox.inputElement.setAttribute('id', id + 'item');\n\t\ttemplate.inputBox.inputElement.setAttribute('role', 'treeitem');\n\t\ttemplate.inputBox.inputElement.setAttribute('aria-labelledby', id + 'item ' + id);\n\n\t\trenderValidations(dataElement, template, true, label);\n\t}\n\n\n\tprivate renderNumber(dataElement: SettingsTreeSettingElement, template: ISettingTextItemTemplate, onChange: (value: number) => void): void {\n\t\tconst modifiedText = dataElement.isConfigured ? 'Modified' : '';\n\t\tconst label = ' ' + dataElement.displayCategory + ' ' + dataElement.displayLabel + ' number ' + modifiedText;\n\t\tconst numParseFn = (dataElement.valueType === 'integer' || dataElement.valueType === 'nullable-integer')\n\t\t\t? parseInt : parseFloat;\n\n\t\tconst nullNumParseFn = (dataElement.valueType === 'nullable-integer' || dataElement.valueType === 'nullable-number')\n\t\t\t? (v => v === '' ? null : numParseFn(v)) : numParseFn;\n\n\t\ttemplate.onChange = null;\n\t\ttemplate.inputBox.value = dataElement.value;\n\t\ttemplate.onChange = value => { renderValidations(dataElement, template, false, label); onChange(nullNumParseFn(value)); };\n\n\t\t// Setup and add ARIA attributes\n\t\t// Create id and label for control/input element - parent is wrapper div\n\t\tconst id = (dataElement.displayCategory + '_' + dataElement.displayLabel).replace(/ /g, '_');\n\n\t\t// We use the parent control div for the aria-labelledby target\n\t\t// Does not appear you can use the direct label on the element itself within a tree\n\t\ttemplate.inputBox.inputElement.parentElement.setAttribute('id', id);\n\t\ttemplate.inputBox.inputElement.parentElement.setAttribute('aria-label', label);\n\n\t\t// Labels will not be read on descendent input elements of the parent treeitem\n\t\t// unless defined as role=treeitem and indirect aria-labelledby approach\n\t\t// TODO: Determine method to normally label input items with value read last\n\t\ttemplate.inputBox.inputElement.setAttribute('id', id + 'item');\n\t\ttemplate.inputBox.inputElement.setAttribute('role', 'treeitem');\n\t\ttemplate.inputBox.inputElement.setAttribute('aria-labelledby', id + 'item ' + id);\n\n\t\trenderValidations(dataElement, template, true, label);\n\t}\n\n\tprivate renderExcludeSetting(dataElement: SettingsTreeSettingElement, template: ISettingExcludeItemTemplate): void {\n\t\tconst value = getExcludeDisplayValue(dataElement);\n\t\ttemplate.excludeWidget.setValue(value);\n\t\ttemplate.context = dataElement;\n\t}\n\n\tprivate renderComplexSetting(dataElement: SettingsTreeSettingElement, template: ISettingComplexItemTemplate): void {\n\t\ttemplate.onChange = () => this._onDidOpenSettings.fire(dataElement.setting.key);\n\t}\n\n\tdisposeTemplate(tree: ITree, templateId: string, template: IDisposableTemplate): void {\n\t\tdispose(template.toDispose);\n\t}\n}\n\nfunction renderValidations(dataElement: SettingsTreeSettingElement, template: ISettingTextItemTemplate, calledOnStartup: boolean, originalAriaLabel: string) {\n\tif (dataElement.setting.validator) {\n\t\tlet errMsg = dataElement.setting.validator(template.inputBox.value);\n\t\tif (errMsg) {\n\t\t\tDOM.addClass(template.containerElement, 'invalid-input');\n\t\t\ttemplate.validationErrorMessageElement.innerText = errMsg;\n\t\t\tlet validationError = localize('validationError', \"Validation Error.\");\n\t\t\ttemplate.inputBox.inputElement.parentElement.setAttribute('aria-label', [originalAriaLabel, validationError, errMsg].join(' '));\n\t\t\tif (!calledOnStartup) { ariaAlert(validationError + ' ' + errMsg); }\n\t\t\treturn;\n\t\t} else {\n\t\t\ttemplate.inputBox.inputElement.parentElement.setAttribute('aria-label', originalAriaLabel);\n\t\t}\n\t}\n\tDOM.removeClass(template.containerElement, 'invalid-input');\n}\n\nfunction cleanRenderedMarkdown(element: Node): void {\n\tfor (let i = 0; i < element.childNodes.length; i++) {\n\t\tconst child = element.childNodes.item(i);\n\n\t\tconst tagName = (<Element>child).tagName && (<Element>child).tagName.toLowerCase();\n\t\tif (tagName === 'img') {\n\t\t\telement.removeChild(child);\n\t\t} else {\n\t\t\tcleanRenderedMarkdown(child);\n\t\t}\n\t}\n}\n\nfunction fixSettingLinks(text: string): string {\n\treturn text.replace(/`#([^#]*)#`/g, (match, settingName) => {\n\t\tconst targetDisplayFormat = settingKeyToDisplayFormat(settingName);\n\t\tconst targetName = `${targetDisplayFormat.category}: ${targetDisplayFormat.label}`;\n\t\treturn `[${targetName}](#${settingName})`;\n\t});\n}\n\nfunction getDisplayEnumOptions(setting: ISetting): string[] {\n\tif (setting.enum.length > SettingsRenderer.MAX_ENUM_DESCRIPTIONS && setting.enumDescriptions) {\n\t\treturn setting.enum\n\t\t\t.map(escapeInvisibleChars)\n\t\t\t.map((value, i) => {\n\t\t\t\treturn setting.enumDescriptions[i] ?\n\t\t\t\t\t`${value}: ${setting.enumDescriptions[i]}` :\n\t\t\t\t\tvalue;\n\t\t\t});\n\t}\n\n\treturn setting.enum\n\t\t.map(String)\n\t\t.map(escapeInvisibleChars);\n}\n\nfunction escapeInvisibleChars(enumValue: string): string {\n\treturn enumValue && enumValue\n\t\t.replace(/\\n/g, '\\\\n')\n\t\t.replace(/\\r/g, '\\\\r');\n}\n\nexport class SettingsTreeFilter implements IFilter {\n\tconstructor(\n\t\tprivate viewState: ISettingsEditorViewState,\n\t) { }\n\n\tisVisible(tree: ITree, element: SettingsTreeElement): boolean {\n\t\t// Filter during search\n\t\tif (this.viewState.filterToCategory && element instanceof SettingsTreeSettingElement) {\n\t\t\tif (!this.settingContainedInGroup(element.setting, this.viewState.filterToCategory)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tif (element instanceof SettingsTreeSettingElement && this.viewState.tagFilters) {\n\t\t\treturn element.matchesAllTags(this.viewState.tagFilters);\n\t\t}\n\n\t\tif (element instanceof SettingsTreeGroupElement) {\n\t\t\tif (typeof element.count === 'number') {\n\t\t\t\treturn element.count > 0;\n\t\t\t}\n\n\t\t\treturn element.children.some(child => this.isVisible(tree, child));\n\t\t}\n\n\t\tif (element instanceof SettingsTreeNewExtensionsElement) {\n\t\t\tif ((this.viewState.tagFilters && this.viewState.tagFilters.size) || this.viewState.filterToCategory) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate settingContainedInGroup(setting: ISetting, group: SettingsTreeGroupElement): boolean {\n\t\treturn group.children.some(child => {\n\t\t\tif (child instanceof SettingsTreeGroupElement) {\n\t\t\t\treturn this.settingContainedInGroup(setting, child);\n\t\t\t} else if (child instanceof SettingsTreeSettingElement) {\n\t\t\t\treturn child.setting.key === setting.key;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t}\n}\n\nexport class SettingsTreeController extends WorkbenchTreeController {\n\tconstructor(\n\t\t@IConfigurationService configurationService: IConfigurationService\n\t) {\n\t\tsuper({}, configurationService);\n\t}\n\n\tprotected onLeftClick(tree: ITree, element: any, eventish: IMouseEvent, origin?: string): boolean {\n\t\tconst isLink = eventish.target.tagName.toLowerCase() === 'a' ||\n\t\t\teventish.target.parentElement.tagName.toLowerCase() === 'a'; // <code> inside <a>\n\n\t\tif (isLink && (DOM.findParentWithClass(eventish.target, 'setting-item-description-markdown', tree.getHTMLElement()) || DOM.findParentWithClass(eventish.target, 'select-box-description-markdown'))) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n}\n\nexport class SettingsAccessibilityProvider implements IAccessibilityProvider {\n\tgetAriaLabel(tree: ITree, element: SettingsTreeElement): string {\n\t\tif (!element) {\n\t\t\treturn '';\n\t\t}\n\n\t\tif (element instanceof SettingsTreeSettingElement) {\n\t\t\treturn localize('settingRowAriaLabel', \"{0} {1}, Setting\", element.displayCategory, element.displayLabel);\n\t\t}\n\n\t\tif (element instanceof SettingsTreeGroupElement) {\n\t\t\treturn localize('groupRowAriaLabel', \"{0}, group\", element.label);\n\t\t}\n\n\t\treturn '';\n\t}\n}\n\nclass NonExpandableOrSelectableTree extends Tree {\n\texpand(): TPromise<any> {\n\t\treturn TPromise.wrap(null);\n\t}\n\n\tcollapse(): TPromise<any> {\n\t\treturn TPromise.wrap(null);\n\t}\n\n\tpublic setFocus(element?: any, eventPayload?: any): void {\n\t\treturn;\n\t}\n\n\tpublic focusNext(count?: number, eventPayload?: any): void {\n\t\treturn;\n\t}\n\n\tpublic focusPrevious(count?: number, eventPayload?: any): void {\n\t\treturn;\n\t}\n\n\tpublic focusParent(eventPayload?: any): void {\n\t\treturn;\n\t}\n\n\tpublic focusFirstChild(eventPayload?: any): void {\n\t\treturn;\n\t}\n\n\tpublic focusFirst(eventPayload?: any, from?: any): void {\n\t\treturn;\n\t}\n\n\tpublic focusNth(index: number, eventPayload?: any): void {\n\t\treturn;\n\t}\n\n\tpublic focusLast(eventPayload?: any, from?: any): void {\n\t\treturn;\n\t}\n\n\tpublic focusNextPage(eventPayload?: any): void {\n\t\treturn;\n\t}\n\n\tpublic focusPreviousPage(eventPayload?: any): void {\n\t\treturn;\n\t}\n\n\tpublic select(element: any, eventPayload?: any): void {\n\t\treturn;\n\t}\n\n\tpublic selectRange(fromElement: any, toElement: any, eventPayload?: any): void {\n\t\treturn;\n\t}\n\n\tpublic selectAll(elements: any[], eventPayload?: any): void {\n\t\treturn;\n\t}\n\n\tpublic setSelection(elements: any[], eventPayload?: any): void {\n\t\treturn;\n\t}\n\n\tpublic toggleSelection(element: any, eventPayload?: any): void {\n\t\treturn;\n\t}\n}\n\nexport class SettingsTree extends NonExpandableOrSelectableTree {\n\tprotected disposables: IDisposable[];\n\n\tconstructor(\n\t\tcontainer: HTMLElement,\n\t\tviewState: ISettingsEditorViewState,\n\t\tconfiguration: Partial<ITreeConfiguration>,\n\t\t@IThemeService themeService: IThemeService,\n\t\t@IInstantiationService instantiationService: IInstantiationService\n\t) {\n\t\tconst treeClass = 'settings-editor-tree';\n\n\t\tconst controller = instantiationService.createInstance(SettingsTreeController);\n\t\tconst fullConfiguration = <ITreeConfiguration>{\n\t\t\tdataSource: instantiationService.createInstance(SettingsDataSource, viewState),\n\t\t\tcontroller,\n\t\t\taccessibilityProvider: instantiationService.createInstance(SettingsAccessibilityProvider),\n\t\t\tfilter: instantiationService.createInstance(SettingsTreeFilter, viewState),\n\t\t\tstyler: new DefaultTreestyler(DOM.createStyleSheet(container), treeClass),\n\n\t\t\t...configuration\n\t\t};\n\n\t\tconst options = {\n\t\t\tariaLabel: localize('treeAriaLabel', \"Settings\"),\n\t\t\tshowLoading: false,\n\t\t\tindentPixels: 0,\n\t\t\ttwistiePixels: 20, // Actually for gear button\n\t\t};\n\n\t\tsuper(container,\n\t\t\tfullConfiguration,\n\t\t\toptions);\n\n\t\tthis.disposables = [];\n\t\tthis.disposables.push(controller);\n\n\t\tthis.disposables.push(registerThemingParticipant((theme: ITheme, collector: ICssStyleCollector) => {\n\t\t\tconst activeBorderColor = theme.getColor(focusBorder);\n\t\t\tif (activeBorderColor) {\n\t\t\t\t// TODO@rob - why isn't this applied when added to the stylesheet from tocTree.ts? Seems like a chromium glitch.\n\t\t\t\tcollector.addRule(`.settings-editor > .settings-body > .settings-toc-container .monaco-tree:focus .monaco-tree-row.focused {outline: solid 1px ${activeBorderColor}; outline-offset: -1px;  }`);\n\t\t\t}\n\n\t\t\tconst foregroundColor = theme.getColor(foreground);\n\t\t\tif (foregroundColor) {\n\t\t\t\t// Links appear inside other elements in markdown. CSS opacity acts like a mask. So we have to dynamically compute the description color to avoid\n\t\t\t\t// applying an opacity to the link color.\n\t\t\t\tconst fgWithOpacity = new Color(new RGBA(foregroundColor.rgba.r, foregroundColor.rgba.g, foregroundColor.rgba.b, .9));\n\t\t\t\tcollector.addRule(`.settings-editor > .settings-body > .settings-tree-container .setting-item .setting-item-description { color: ${fgWithOpacity}; }`);\n\t\t\t}\n\n\t\t\tconst errorColor = theme.getColor(errorForeground);\n\t\t\tif (errorColor) {\n\t\t\t\tcollector.addRule(`.settings-editor > .settings-body > .settings-tree-container .setting-item .setting-item-deprecation-message { color: ${errorColor}; }`);\n\t\t\t}\n\n\t\t\tconst invalidInputBackground = theme.getColor(inputValidationErrorBackground);\n\t\t\tif (invalidInputBackground) {\n\t\t\t\tcollector.addRule(`.settings-editor > .settings-body > .settings-tree-container .setting-item .setting-item-validation-message { background-color: ${invalidInputBackground}; }`);\n\t\t\t}\n\n\t\t\tconst invalidInputBorder = theme.getColor(inputValidationErrorBorder);\n\t\t\tif (invalidInputBorder) {\n\t\t\t\tcollector.addRule(`.settings-editor > .settings-body > .settings-tree-container .setting-item .setting-item-validation-message { border-style:solid; border-width: 1px; border-color: ${invalidInputBorder}; }`);\n\t\t\t\tcollector.addRule(`.settings-editor > .settings-body > .settings-tree-container .setting-item.invalid-input .setting-item-control .monaco-inputbox.idle { outline-width: 0; border-style:solid; border-width: 1px; border-color: ${invalidInputBorder}; }`);\n\t\t\t}\n\n\t\t\tconst headerForegroundColor = theme.getColor(settingsHeaderForeground);\n\t\t\tif (headerForegroundColor) {\n\t\t\t\tcollector.addRule(`.settings-editor > .settings-body > .settings-tree-container .settings-group-title-label { color: ${headerForegroundColor}; }`);\n\t\t\t\tcollector.addRule(`.settings-editor > .settings-body > .settings-tree-container .setting-item-label { color: ${headerForegroundColor}; }`);\n\t\t\t}\n\t\t}));\n\n\t\tthis.getHTMLElement().classList.add(treeClass);\n\n\t\tthis.disposables.push(attachStyler(themeService, {\n\t\t\tlistActiveSelectionBackground: editorBackground,\n\t\t\tlistActiveSelectionForeground: foreground,\n\t\t\tlistFocusAndSelectionBackground: editorBackground,\n\t\t\tlistFocusAndSelectionForeground: foreground,\n\t\t\tlistFocusBackground: editorBackground,\n\t\t\tlistFocusForeground: foreground,\n\t\t\tlistHoverForeground: foreground,\n\t\t\tlistHoverBackground: editorBackground,\n\t\t\tlistHoverOutline: editorBackground,\n\t\t\tlistFocusOutline: editorBackground,\n\t\t\tlistInactiveSelectionBackground: editorBackground,\n\t\t\tlistInactiveSelectionForeground: foreground\n\t\t}, colors => {\n\t\t\tthis.style(colors);\n\t\t}));\n\t}\n}\n\nclass CopySettingIdAction extends Action {\n\tstatic readonly ID = 'settings.copySettingId';\n\tstatic readonly LABEL = localize('copySettingIdLabel', \"Copy Setting ID\");\n\n\tconstructor(\n\t\t@IClipboardService private clipboardService: IClipboardService\n\t) {\n\t\tsuper(CopySettingIdAction.ID, CopySettingIdAction.LABEL);\n\t}\n\n\trun(context: SettingsTreeSettingElement): TPromise<void> {\n\t\tif (context) {\n\t\t\tthis.clipboardService.writeText(context.setting.key);\n\t\t}\n\n\t\treturn TPromise.as(null);\n\t}\n}\n\nclass CopySettingAsJSONAction extends Action {\n\tstatic readonly ID = 'settings.copySettingAsJSON';\n\tstatic readonly LABEL = localize('copySettingAsJSONLabel', \"Copy Setting as JSON\");\n\n\tconstructor(\n\t\t@IClipboardService private clipboardService: IClipboardService\n\t) {\n\t\tsuper(CopySettingAsJSONAction.ID, CopySettingAsJSONAction.LABEL);\n\t}\n\n\trun(context: SettingsTreeSettingElement): TPromise<void> {\n\t\tif (context) {\n\t\t\tconst jsonResult = `\"${context.setting.key}\": ${JSON.stringify(context.value, undefined, '  ')}`;\n\t\t\tthis.clipboardService.writeText(jsonResult);\n\t\t}\n\n\t\treturn TPromise.as(null);\n\t}\n}\n\nclass CopySettingNameAction extends Action {\n\tstatic readonly ID = 'settings.copySettingName';\n\tstatic readonly LABEL = localize('copySettingNameLabel', \"Copy Setting Name\");\n\n\tconstructor(\n\t\t@IClipboardService private clipboardService: IClipboardService\n\t) {\n\t\tsuper(CopySettingNameAction.ID, CopySettingNameAction.LABEL);\n\t}\n\n\trun(context: SettingsTreeSettingElement): TPromise<void> {\n\t\tif (context) {\n\t\t\tconst name = `${context.displayCategory}: ${context.displayLabel}`;\n\t\t\tthis.clipboardService.writeText(name);\n\t\t}\n\n\t\treturn TPromise.as(null);\n\t}\n}\n",
            "linguagem": "ts",
            "total_linhas": 1506
        },
        "solucao_humana": {
            "patch_diff": "@@ -684,6 +684,7 @@ export class SettingsRenderer implements ITreeRenderer {\n \t\t\t// Toggle target checkbox\n \t\t\tif (targetElement.tagName.toLowerCase() !== 'a' && targetId === template.checkbox.domNode.id) {\n \t\t\t\ttemplate.checkbox.checked = template.checkbox.checked ? false : true;\n+\t\t\t\ttemplate.onChange(checkbox.checked);\n \t\t\t}\n \t\t\tDOM.EventHelper.stop(e);\n \t\t}));",
            "apenas_linhas_adicionadas": [
                "\t\t\t\ttemplate.onChange(checkbox.checked);"
            ]
        }
    },
    {
        "id": 58114,
        "url": "https://github.com/microsoft/vscode/pull/58114",
        "arquivo_caminho": "src/vs/base/browser/ui/selectBox/selectBoxCustom.ts",
        "descricao_bug": "- Measures highest detailed description\r\n- Adjusts context view when description changes\r\n- layout description at top if drop down above\r\n- Fix selected for collapsed select change by keyboard",
        "contexto": {
            "codigo_completo_bugado": "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport 'vs/css!./selectBoxCustom';\n\nimport * as nls from 'vs/nls';\nimport { IDisposable, dispose } from 'vs/base/common/lifecycle';\nimport { Event, Emitter, chain } from 'vs/base/common/event';\nimport { KeyCode, KeyCodeUtils } from 'vs/base/common/keyCodes';\nimport { StandardKeyboardEvent } from 'vs/base/browser/keyboardEvent';\nimport * as dom from 'vs/base/browser/dom';\nimport * as arrays from 'vs/base/common/arrays';\nimport { IContextViewProvider, AnchorPosition } from 'vs/base/browser/ui/contextview/contextview';\nimport { List } from 'vs/base/browser/ui/list/listWidget';\nimport { IVirtualDelegate, IRenderer, IListEvent } from 'vs/base/browser/ui/list/list';\nimport { domEvent } from 'vs/base/browser/event';\nimport { ScrollbarVisibility } from 'vs/base/common/scrollable';\nimport { ISelectBoxDelegate, ISelectBoxOptions, ISelectBoxStyles, ISelectData } from 'vs/base/browser/ui/selectBox/selectBox';\nimport { isMacintosh } from 'vs/base/common/platform';\nimport { renderMarkdown } from 'vs/base/browser/htmlContentRenderer';\n\nconst $ = dom.$;\n\nconst SELECT_OPTION_ENTRY_TEMPLATE_ID = 'selectOption.entry.template';\n\nexport interface ISelectOptionItem {\n\toptionText: string;\n\toptionDisabled: boolean;\n}\n\ninterface ISelectListTemplateData {\n\troot: HTMLElement;\n\toptionText: HTMLElement;\n\tdisposables: IDisposable[];\n}\n\nclass SelectListRenderer implements IRenderer<ISelectOptionItem, ISelectListTemplateData> {\n\n\tget templateId(): string { return SELECT_OPTION_ENTRY_TEMPLATE_ID; }\n\n\tconstructor() { }\n\n\trenderTemplate(container: HTMLElement): any {\n\t\tconst data = <ISelectListTemplateData>Object.create(null);\n\t\tdata.disposables = [];\n\t\tdata.root = container;\n\t\tdata.optionText = dom.append(container, $('.option-text'));\n\n\t\treturn data;\n\t}\n\n\trenderElement(element: ISelectOptionItem, index: number, templateData: ISelectListTemplateData): void {\n\t\tconst data = <ISelectListTemplateData>templateData;\n\t\tconst optionText = (<ISelectOptionItem>element).optionText;\n\t\tconst optionDisabled = (<ISelectOptionItem>element).optionDisabled;\n\n\t\tdata.optionText.textContent = optionText;\n\t\tdata.root.setAttribute('aria-label', nls.localize('selectAriaOption', \"{0}\", optionText));\n\n\t\t// Workaround for list labels\n\t\tdata.root.setAttribute('aria-selected', 'true');\n\n\t\t// pseudo-select disabled option\n\t\tif (optionDisabled) {\n\t\t\tdom.addClass((<HTMLElement>data.root), 'option-disabled');\n\t\t} else {\n\t\t\t// Make sure we do class removal from prior template rendering\n\t\t\tdom.removeClass((<HTMLElement>data.root), 'option-disabled');\n\t\t}\n\t}\n\n\tdisposeElement(): void {\n\t\t// noop\n\t}\n\n\tdisposeTemplate(templateData: ISelectListTemplateData): void {\n\t\ttemplateData.disposables = dispose(templateData.disposables);\n\t}\n}\n\nexport class SelectBoxList implements ISelectBoxDelegate, IVirtualDelegate<ISelectOptionItem> {\n\n\tprivate static readonly DEFAULT_DROPDOWN_MINIMUM_BOTTOM_MARGIN = 32;\n\tprivate static readonly DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN = 2;\n\tprivate static readonly DEFAULT_MINIMUM_VISIBLE_OPTIONS = 3;\n\n\tprivate _isVisible: boolean;\n\tprivate selectBoxOptions: ISelectBoxOptions;\n\tprivate selectElement: HTMLSelectElement;\n\tprivate options: string[];\n\tprivate selected: number;\n\tprivate disabledOptionIndex: number;\n\tprivate readonly _onDidSelect: Emitter<ISelectData>;\n\tprivate toDispose: IDisposable[];\n\tprivate styles: ISelectBoxStyles;\n\tprivate listRenderer: SelectListRenderer;\n\tprivate contextViewProvider: IContextViewProvider;\n\tprivate selectDropDownContainer: HTMLElement;\n\tprivate styleElement: HTMLStyleElement;\n\tprivate selectList: List<ISelectOptionItem>;\n\tprivate selectDropDownListContainer: HTMLElement;\n\tprivate widthControlElement: HTMLElement;\n\tprivate _currentSelection: number;\n\tprivate _dropDownPosition: AnchorPosition;\n\tprivate detailsProvider: (index: number) => { details: string, isMarkdown: boolean };\n\tprivate selectionDetailsPane: HTMLElement;\n\n\n\tprivate _sticky: boolean = false; // for dev purposes only\n\n\tconstructor(options: string[], selected: number, contextViewProvider: IContextViewProvider, styles: ISelectBoxStyles, selectBoxOptions?: ISelectBoxOptions) {\n\n\t\tthis.toDispose = [];\n\t\tthis._isVisible = false;\n\t\tthis.selectBoxOptions = selectBoxOptions || Object.create(null);\n\n\t\tif (typeof this.selectBoxOptions.minBottomMargin !== 'number') {\n\t\t\tthis.selectBoxOptions.minBottomMargin = SelectBoxList.DEFAULT_DROPDOWN_MINIMUM_BOTTOM_MARGIN;\n\t\t} else if (this.selectBoxOptions.minBottomMargin < 0) {\n\t\t\tthis.selectBoxOptions.minBottomMargin = 0;\n\t\t}\n\n\t\tthis.selectElement = document.createElement('select');\n\t\t// Use custom CSS vars for padding calculation\n\t\tthis.selectElement.className = 'monaco-select-box monaco-select-box-dropdown-padding';\n\n\t\tif (typeof this.selectBoxOptions.ariaLabel === 'string') {\n\t\t\tthis.selectElement.setAttribute('aria-label', this.selectBoxOptions.ariaLabel);\n\t\t}\n\n\t\tthis._onDidSelect = new Emitter<ISelectData>();\n\t\tthis.toDispose.push(this._onDidSelect);\n\n\t\tthis.styles = styles;\n\n\t\tthis.registerListeners();\n\t\tthis.constructSelectDropDown(contextViewProvider);\n\n\t\tthis.setOptions(options, selected);\n\t}\n\n\t// IDelegate - List renderer\n\n\tgetHeight(): number {\n\t\treturn 18;\n\t}\n\n\tgetTemplateId(): string {\n\t\treturn SELECT_OPTION_ENTRY_TEMPLATE_ID;\n\t}\n\n\tprivate constructSelectDropDown(contextViewProvider: IContextViewProvider) {\n\n\t\t// SetUp ContextView container to hold select Dropdown\n\t\tthis.contextViewProvider = contextViewProvider;\n\t\tthis.selectDropDownContainer = dom.$('.monaco-select-box-dropdown-container');\n\t\t// Use custom CSS vars for padding calculation (shared with parent select)\n\t\tdom.addClass(this.selectDropDownContainer, 'monaco-select-box-dropdown-padding');\n\t\t// Setup list for drop-down select\n\t\tthis.createSelectList(this.selectDropDownContainer);\n\t\tthis.selectionDetailsPane = dom.append(this.selectDropDownContainer, $('.select-box-details-pane'));\n\n\t\t// Create span flex box item/div we can measure and control\n\t\tlet widthControlOuterDiv = dom.append(this.selectDropDownContainer, $('.select-box-dropdown-container-width-control'));\n\t\tlet widthControlInnerDiv = dom.append(widthControlOuterDiv, $('.width-control-div'));\n\t\tthis.widthControlElement = document.createElement('span');\n\t\tthis.widthControlElement.className = 'option-text-width-control';\n\t\tdom.append(widthControlInnerDiv, this.widthControlElement);\n\n\t\t// Always default to below position\n\t\tthis._dropDownPosition = AnchorPosition.BELOW;\n\n\t\t// Inline stylesheet for themes\n\t\tthis.styleElement = dom.createStyleSheet(this.selectDropDownContainer);\n\t}\n\n\tprivate registerListeners() {\n\n\t\t// Parent native select keyboard listeners\n\n\t\tthis.toDispose.push(dom.addStandardDisposableListener(this.selectElement, 'change', (e) => {\n\t\t\tthis.selectElement.title = e.target.value;\n\t\t\tthis._onDidSelect.fire({\n\t\t\t\tindex: e.target.selectedIndex,\n\t\t\t\tselected: e.target.value\n\t\t\t});\n\t\t}));\n\n\t\t// Have to implement both keyboard and mouse controllers to handle disabled options\n\t\t// Intercept mouse events to override normal select actions on parents\n\n\t\tthis.toDispose.push(dom.addDisposableListener(this.selectElement, dom.EventType.CLICK, (e) => {\n\t\t\tdom.EventHelper.stop(e);\n\n\t\t\tif (this._isVisible) {\n\t\t\t\tthis.hideSelectDropDown(true);\n\t\t\t} else {\n\t\t\t\tthis.showSelectDropDown();\n\t\t\t}\n\t\t}));\n\n\t\tthis.toDispose.push(dom.addDisposableListener(this.selectElement, dom.EventType.MOUSE_DOWN, (e) => {\n\t\t\tdom.EventHelper.stop(e);\n\t\t}));\n\n\t\t// Intercept keyboard handling\n\n\t\tthis.toDispose.push(dom.addDisposableListener(this.selectElement, dom.EventType.KEY_DOWN, (e: KeyboardEvent) => {\n\t\t\tconst event = new StandardKeyboardEvent(e);\n\t\t\tlet showDropDown = false;\n\n\t\t\t// Create and drop down select list on keyboard select\n\t\t\tif (isMacintosh) {\n\t\t\t\tif (event.keyCode === KeyCode.DownArrow || event.keyCode === KeyCode.UpArrow || event.keyCode === KeyCode.Space || event.keyCode === KeyCode.Enter) {\n\t\t\t\t\tshowDropDown = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (event.keyCode === KeyCode.DownArrow && event.altKey || event.keyCode === KeyCode.UpArrow && event.altKey || event.keyCode === KeyCode.Space || event.keyCode === KeyCode.Enter) {\n\t\t\t\t\tshowDropDown = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (showDropDown) {\n\t\t\t\tthis.showSelectDropDown();\n\t\t\t\tdom.EventHelper.stop(e);\n\t\t\t}\n\t\t}));\n\t}\n\n\tpublic get onDidSelect(): Event<ISelectData> {\n\t\treturn this._onDidSelect.event;\n\t}\n\n\tpublic setOptions(options: string[], selected?: number, disabled?: number): void {\n\n\t\tif (!this.options || !arrays.equals(this.options, options)) {\n\t\t\tthis.options = options;\n\t\t\tthis.selectElement.options.length = 0;\n\n\t\t\tlet i = 0;\n\t\t\tthis.options.forEach((option) => {\n\t\t\t\tthis.selectElement.add(this.createOption(option, i, disabled === i++));\n\t\t\t});\n\n\t\t\t// Mirror options in drop-down\n\t\t\t// Populate select list for non-native select mode\n\t\t\tif (this.selectList && !!this.options) {\n\t\t\t\tlet listEntries: ISelectOptionItem[];\n\n\t\t\t\tlistEntries = [];\n\t\t\t\tif (disabled !== undefined) {\n\t\t\t\t\tthis.disabledOptionIndex = disabled;\n\t\t\t\t}\n\t\t\t\tfor (let index = 0; index < this.options.length; index++) {\n\t\t\t\t\tconst element = this.options[index];\n\t\t\t\t\tlet optionDisabled: boolean;\n\t\t\t\t\tindex === this.disabledOptionIndex ? optionDisabled = true : optionDisabled = false;\n\t\t\t\t\tlistEntries.push({ optionText: element, optionDisabled: optionDisabled });\n\t\t\t\t}\n\n\t\t\t\tthis.selectList.splice(0, this.selectList.length, listEntries);\n\t\t\t}\n\t\t}\n\n\t\tif (selected !== undefined) {\n\t\t\tthis.select(selected);\n\t\t\t// Set current = selected since this is not necessarily a user exit\n\t\t\tthis._currentSelection = this.selected;\n\t\t}\n\t}\n\n\tpublic select(index: number): void {\n\n\t\tif (index >= 0 && index < this.options.length) {\n\t\t\tthis.selected = index;\n\t\t} else if (index > this.options.length - 1) {\n\t\t\t// Adjust index to end of list\n\t\t\t// This could make client out of sync with the select\n\t\t\tthis.select(this.options.length - 1);\n\t\t} else if (this.selected < 0) {\n\t\t\tthis.selected = 0;\n\t\t}\n\n\t\tthis.selectElement.selectedIndex = this.selected;\n\t\tthis.selectElement.title = this.options[this.selected];\n\t}\n\n\tpublic setAriaLabel(label: string): void {\n\t\tthis.selectBoxOptions.ariaLabel = label;\n\t\tthis.selectElement.setAttribute('aria-label', this.selectBoxOptions.ariaLabel);\n\t\tthis.selectList.getHTMLElement().setAttribute('aria-label', this.selectBoxOptions.ariaLabel);\n\t}\n\n\tpublic setDetailsProvider(provider: (index: number) => { details: string, isMarkdown: boolean }): void {\n\t\tthis.detailsProvider = provider;\n\t}\n\n\tpublic focus(): void {\n\t\tif (this.selectElement) {\n\t\t\tthis.selectElement.focus();\n\t\t}\n\t}\n\n\tpublic blur(): void {\n\t\tif (this.selectElement) {\n\t\t\tthis.selectElement.blur();\n\t\t}\n\t}\n\n\tpublic render(container: HTMLElement): void {\n\t\tdom.addClass(container, 'select-container');\n\t\tcontainer.appendChild(this.selectElement);\n\t\tthis.setOptions(this.options, this.selected);\n\t\tthis.applyStyles();\n\t}\n\n\tpublic style(styles: ISelectBoxStyles): void {\n\n\t\tconst content: string[] = [];\n\n\t\tthis.styles = styles;\n\n\t\t// Style non-native select mode\n\n\t\tif (this.styles.listFocusBackground) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.focused { background-color: ${this.styles.listFocusBackground} !important; }`);\n\t\t}\n\n\t\tif (this.styles.listFocusForeground) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.focused:not(:hover) { color: ${this.styles.listFocusForeground} !important; }`);\n\t\t}\n\n\t\tif (!this.styles.selectBorder.equals(this.styles.selectBackground)) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container { border: 1px solid ${this.styles.selectBorder} } `);\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-details-pane { border-top: 1px solid ${this.styles.selectBorder} } `);\n\t\t}\n\t\telse if (this.styles.selectListBorder) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container { border: 1px solid ${this.styles.selectListBorder} } `);\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-details-pane { border-top: 1px solid ${this.styles.selectListBorder} } `);\n\t\t}\n\n\t\t// Hover foreground - ignore for disabled options\n\t\tif (this.styles.listHoverForeground) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:hover { color: ${this.styles.listHoverForeground} !important; }`);\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.option-disabled:hover { background-color: ${this.styles.listActiveSelectionForeground} !important; }`);\n\t\t}\n\n\t\t// Hover background - ignore for disabled options\n\t\tif (this.styles.listHoverBackground) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:not(.option-disabled):not(.focused):hover { background-color: ${this.styles.listHoverBackground} !important; }`);\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.option-disabled:hover { background-color: ${this.styles.selectBackground} !important; }`);\n\t\t}\n\n\t\t// Match quickOpen outline styles - ignore for disabled options\n\t\tif (this.styles.listFocusOutline) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.focused { outline: 1.6px dotted ${this.styles.listFocusOutline} !important; outline-offset: -1.6px !important; }`);\n\t\t}\n\n\t\tif (this.styles.listHoverOutline) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:hover:not(.focused) { outline: 1.6px dashed ${this.styles.listHoverOutline} !important; outline-offset: -1.6px !important; }`);\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.option-disabled:hover { outline: none !important; }`);\n\t\t}\n\n\t\tthis.styleElement.innerHTML = content.join('\\n');\n\n\t\tthis.applyStyles();\n\t}\n\n\tpublic applyStyles(): void {\n\n\t\t// Style parent select\n\n\t\tlet background = null;\n\n\t\tif (this.selectElement) {\n\t\t\tbackground = this.styles.selectBackground ? this.styles.selectBackground.toString() : null;\n\t\t\tconst foreground = this.styles.selectForeground ? this.styles.selectForeground.toString() : null;\n\t\t\tconst border = this.styles.selectBorder ? this.styles.selectBorder.toString() : null;\n\n\t\t\tthis.selectElement.style.backgroundColor = background;\n\t\t\tthis.selectElement.style.color = foreground;\n\t\t\tthis.selectElement.style.borderColor = border;\n\t\t}\n\n\t\t// Style drop down select list (non-native mode only)\n\n\t\tif (this.selectList) {\n\t\t\tthis.selectList.style({});\n\n\t\t\tlet listBackground = this.styles.selectListBackground ? this.styles.selectListBackground.toString() : background;\n\t\t\tthis.selectDropDownListContainer.style.backgroundColor = listBackground;\n\t\t\tthis.selectionDetailsPane.style.backgroundColor = listBackground;\n\t\t\tconst optionsBorder = this.styles.focusBorder ? this.styles.focusBorder.toString() : null;\n\t\t\tthis.selectDropDownContainer.style.outlineColor = optionsBorder;\n\t\t\tthis.selectDropDownContainer.style.outlineOffset = '-1px';\n\t\t}\n\t}\n\n\tprivate createOption(value: string, index: number, disabled?: boolean): HTMLOptionElement {\n\t\tlet option = document.createElement('option');\n\t\toption.value = value;\n\t\toption.text = value;\n\t\toption.disabled = disabled;\n\n\t\treturn option;\n\t}\n\n\t// ContextView dropdown methods\n\n\tprivate showSelectDropDown() {\n\t\tif (!this.contextViewProvider || this._isVisible) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Set drop-down position above/below from required height and margins\n\t\t// If pre-layout cannot fit at least one option do not show drop-down\n\t\tif (!this.layoutSelectDropDown(true)) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.cloneElementFont(this.selectElement, this.selectDropDownContainer);\n\n\t\tthis.contextViewProvider.showContextView({\n\t\t\tgetAnchor: () => this.selectElement,\n\t\t\trender: (container: HTMLElement) => this.renderSelectDropDown(container),\n\t\t\tlayout: () => this.layoutSelectDropDown(),\n\t\t\tonHide: () => {\n\t\t\t\tdom.toggleClass(this.selectDropDownContainer, 'visible', false);\n\t\t\t\tdom.toggleClass(this.selectElement, 'synthetic-focus', false);\n\t\t\t},\n\t\t\tanchorPosition: this._dropDownPosition\n\t\t});\n\n\t\t// Track initial selection the case user escape, blur\n\t\tthis._currentSelection = this.selected;\n\t\tthis._isVisible = true;\n\t}\n\n\tprivate hideSelectDropDown(focusSelect: boolean) {\n\t\tif (!this.contextViewProvider || !this._isVisible) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._isVisible = false;\n\n\t\tif (focusSelect) {\n\t\t\tthis.selectElement.focus();\n\t\t}\n\n\t\tthis.contextViewProvider.hideContextView();\n\t}\n\n\tprivate renderSelectDropDown(container: HTMLElement): IDisposable {\n\t\tcontainer.appendChild(this.selectDropDownContainer);\n\n\t\tthis.layoutSelectDropDown();\n\t\treturn {\n\t\t\tdispose: () => {\n\t\t\t\t// contextView will dispose itself if moving from one View to another\n\t\t\t\ttry {\n\t\t\t\t\tcontainer.removeChild(this.selectDropDownContainer); // remove to take out the CSS rules we add\n\t\t\t\t}\n\t\t\t\tcatch (error) {\n\t\t\t\t\t// Ignore, removed already by change of focus\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\tprivate layoutSelectDropDown(preLayoutPosition?: boolean): boolean {\n\n\t\t// Layout ContextView drop down select list and container\n\t\t// Have to manage our vertical overflow, sizing, position below or above\n\t\t// Position has to be determined and set prior to contextView instantiation\n\n\t\tif (this.selectList) {\n\n\t\t\tconst selectPosition = dom.getDomNodePagePosition(this.selectElement);\n\t\t\tconst styles = getComputedStyle(this.selectElement);\n\t\t\tconst verticalPadding = parseFloat(styles.getPropertyValue('--dropdown-padding-top')) + parseFloat(styles.getPropertyValue('--dropdown-padding-bottom'));\n\t\t\tconst maxSelectDropDownHeightBelow = (window.innerHeight - selectPosition.top - selectPosition.height - this.selectBoxOptions.minBottomMargin);\n\t\t\tconst maxSelectDropDownHeightAbove = (selectPosition.top - SelectBoxList.DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN);\n\n\t\t\t// Get initial list height and determine space above and below\n\t\t\tthis.selectList.layout();\n\t\t\tlet listHeight = this.selectList.contentHeight;\n\t\t\tconst minRequiredDropDownHeight = listHeight + verticalPadding;\n\t\t\tconst maxVisibleOptionsBelow = ((Math.floor((maxSelectDropDownHeightBelow - verticalPadding) / this.getHeight())));\n\t\t\tconst maxVisibleOptionsAbove = ((Math.floor((maxSelectDropDownHeightAbove - verticalPadding) / this.getHeight())));\n\n\t\t\t// If we are only doing pre-layout check/adjust position only\n\t\t\t// Calculate vertical space available, flip up if insufficient\n\t\t\t// Use reflected padding on parent select, ContextView style\n\t\t\t// properties not available before DOM attachment\n\n\t\t\tif (preLayoutPosition) {\n\t\t\t\t// Check if select moved out of viewport , do not open\n\t\t\t\t// If at least one option cannot be shown, don't open the drop-down or hide/remove if open\n\n\t\t\t\tif ((selectPosition.top + selectPosition.height) > (window.innerHeight - 22)\n\t\t\t\t\t|| selectPosition.top < SelectBoxList.DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN\n\t\t\t\t\t|| ((maxVisibleOptionsBelow < 1) && (maxVisibleOptionsAbove < 1))) {\n\t\t\t\t\t// Indicate we cannot open\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Determine if we have to flip up\n\t\t\t\t// Always show complete list items - never more than Max available vertical height\n\t\t\t\tif (maxVisibleOptionsBelow < SelectBoxList.DEFAULT_MINIMUM_VISIBLE_OPTIONS\n\t\t\t\t\t&& maxVisibleOptionsAbove > maxVisibleOptionsBelow\n\t\t\t\t\t&& this.options.length > maxVisibleOptionsBelow\n\t\t\t\t) {\n\t\t\t\t\tthis._dropDownPosition = AnchorPosition.ABOVE;\n\t\t\t\t} else {\n\t\t\t\t\tthis._dropDownPosition = AnchorPosition.BELOW;\n\t\t\t\t}\n\t\t\t\t// Do full layout on showSelectDropDown only\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// Check if select out of viewport or cutting into status bar\n\t\t\tif ((selectPosition.top + selectPosition.height) > (window.innerHeight - 22)\n\t\t\t\t|| selectPosition.top < SelectBoxList.DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN\n\t\t\t\t|| (this._dropDownPosition === AnchorPosition.BELOW && maxVisibleOptionsBelow < 1)\n\t\t\t\t|| (this._dropDownPosition === AnchorPosition.ABOVE && maxVisibleOptionsAbove < 1)) {\n\t\t\t\t// Cannot properly layout, close and hide\n\t\t\t\tthis.hideSelectDropDown(true);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Make visible to enable measurements\n\t\t\tdom.toggleClass(this.selectDropDownContainer, 'visible', true);\n\n\t\t\t// SetUp list dimensions and layout - account for container padding\n\t\t\t// Use position to check above or below available space\n\t\t\tif (this._dropDownPosition === AnchorPosition.BELOW) {\n\t\t\t\tif (this._isVisible && maxVisibleOptionsBelow + maxVisibleOptionsAbove < 1) {\n\t\t\t\t\t// If drop-down is visible, must be doing a DOM re-layout, hide since we don't fit\n\t\t\t\t\t// Hide drop-down, hide contextview, focus on parent select\n\t\t\t\t\tthis.hideSelectDropDown(true);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Set container height to max from select bottom to margin (default/minBottomMargin)\n\t\t\t\tif (minRequiredDropDownHeight > maxSelectDropDownHeightBelow) {\n\t\t\t\t\tlistHeight = (maxVisibleOptionsBelow * this.getHeight() + verticalPadding);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Set container height to max from select top to margin (default/minTopMargin)\n\t\t\t\tif (minRequiredDropDownHeight > maxSelectDropDownHeightAbove) {\n\t\t\t\t\t// listHeight = ((Math.floor((maxSelectDropDownHeightBelow - verticalPadding) / this.getHeight())) * this.getHeight());\n\t\t\t\t\tlistHeight = (maxVisibleOptionsAbove * this.getHeight() + verticalPadding);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set adjusted list height and relayout\n\t\t\tthis.selectList.layout(listHeight);\n\t\t\tthis.selectList.domFocus();\n\n\t\t\t// Finally set focus on selected item\n\t\t\tif (this.selectList.length > 0) {\n\t\t\t\tthis.selectList.setFocus([this.selected || 0]);\n\t\t\t\tthis.selectList.reveal(this.selectList.getFocus()[0] || 0);\n\t\t\t}\n\n\t\t\tif (this.detailsProvider) {\n\t\t\t\t// Leave the selectDropDownContainer to size itself according to children (list + details) - #57447\n\t\t\t\tthis.selectList.getHTMLElement().style.height = (listHeight + verticalPadding) + 'px';\n\t\t\t} else {\n\t\t\t\tthis.selectDropDownContainer.style.height = (listHeight + verticalPadding) + 'px';\n\t\t\t}\n\n\t\t\t// Determine optimal width - min(longest option), opt(parent select, excluding margins), max(ContextView controlled)\n\t\t\tconst selectWidth = this.selectElement.offsetWidth;\n\t\t\tconst selectMinWidth = this.setWidthControlElement(this.widthControlElement);\n\t\t\tconst selectOptimalWidth = Math.max(selectMinWidth, Math.round(selectWidth)).toString() + 'px';\n\n\t\t\tthis.selectDropDownContainer.style.width = selectOptimalWidth;\n\n\t\t\t// Maintain focus outline on parent select as well as list container - tabindex for focus\n\t\t\tthis.selectDropDownListContainer.setAttribute('tabindex', '0');\n\t\t\tdom.toggleClass(this.selectElement, 'synthetic-focus', true);\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate setWidthControlElement(container: HTMLElement): number {\n\t\tlet elementWidth = 0;\n\n\t\tif (container && !!this.options) {\n\t\t\tlet longest = 0;\n\n\t\t\tfor (let index = 0; index < this.options.length; index++) {\n\t\t\t\tif (this.options[index].length > this.options[longest].length) {\n\t\t\t\t\tlongest = index;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcontainer.innerHTML = this.options[longest];\n\t\t\telementWidth = dom.getTotalWidth(container);\n\t\t}\n\n\t\treturn elementWidth;\n\t}\n\n\tprivate cloneElementFont(source: HTMLElement, target: HTMLElement) {\n\t\tconst fontSize = window.getComputedStyle(source, null).getPropertyValue('font-size');\n\t\tconst fontFamily = window.getComputedStyle(source, null).getPropertyValue('font-family');\n\t\ttarget.style.fontFamily = fontFamily;\n\t\ttarget.style.fontSize = fontSize;\n\t}\n\n\tprivate createSelectList(parent: HTMLElement): void {\n\n\t\t// SetUp container for list\n\t\tthis.selectDropDownListContainer = dom.append(parent, $('.select-box-dropdown-list-container'));\n\n\t\tthis.listRenderer = new SelectListRenderer();\n\n\t\tthis.selectList = new List(this.selectDropDownListContainer, this, [this.listRenderer], {\n\t\t\tariaLabel: this.selectBoxOptions.ariaLabel,\n\t\t\tuseShadows: false,\n\t\t\tselectOnMouseDown: false,\n\t\t\tverticalScrollMode: ScrollbarVisibility.Visible,\n\t\t\tkeyboardSupport: false,\n\t\t\tmouseSupport: false\n\t\t});\n\n\t\t// SetUp list keyboard controller - control navigation, disabled items, focus\n\t\tconst onSelectDropDownKeyDown = chain(domEvent(this.selectDropDownListContainer, 'keydown'))\n\t\t\t.filter(() => this.selectList.length > 0)\n\t\t\t.map(e => new StandardKeyboardEvent(e));\n\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.Enter).on(e => this.onEnter(e), this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.Escape).on(e => this.onEscape(e), this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.UpArrow).on(this.onUpArrow, this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.DownArrow).on(this.onDownArrow, this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.PageDown).on(this.onPageDown, this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.PageUp).on(this.onPageUp, this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.Home).on(this.onHome, this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.End).on(this.onEnd, this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => (e.keyCode >= KeyCode.KEY_0 && e.keyCode <= KeyCode.KEY_Z) || (e.keyCode >= KeyCode.US_SEMICOLON && e.keyCode <= KeyCode.NUMPAD_DIVIDE)).on(this.onCharacter, this, this.toDispose);\n\n\t\t// SetUp list mouse controller - control navigation, disabled items, focus\n\n\t\tchain(domEvent(this.selectList.getHTMLElement(), 'mouseup'))\n\t\t\t.filter(() => this.selectList.length > 0)\n\t\t\t.on(e => this.onMouseUp(e), this, this.toDispose);\n\n\t\tthis.toDispose.push(\n\t\t\tthis.selectList.onDidBlur(e => this.onListBlur()),\n\t\t\tthis.selectList.onMouseOver(e => this.selectList.setFocus([e.index])),\n\t\t\tthis.selectList.onFocusChange(e => this.onListFocus(e))\n\t\t);\n\n\t\tthis.selectList.getHTMLElement().setAttribute('aria-expanded', 'true');\n\t}\n\n\t// List methods\n\n\t// List mouse controller - active exit, select option, fire onDidSelect if change, return focus to parent select\n\tprivate onMouseUp(e: MouseEvent): void {\n\n\t\tdom.EventHelper.stop(e);\n\n\t\t// Check our mouse event is on an option (not scrollbar)\n\t\tif (!e.toElement.classList.contains('option-text')) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst listRowElement = e.toElement.parentElement;\n\t\tconst index = Number(listRowElement.getAttribute('data-index'));\n\t\tconst disabled = listRowElement.classList.contains('option-disabled');\n\n\t\t// Ignore mouse selection of disabled options\n\t\tif (index >= 0 && index < this.options.length && !disabled) {\n\t\t\tthis.selected = index;\n\t\t\tthis.select(this.selected);\n\n\t\t\tthis.selectList.setFocus([this.selected]);\n\t\t\tthis.selectList.reveal(this.selectList.getFocus()[0]);\n\n\t\t\t// Only fire if selection change\n\t\t\tif (this.selected !== this._currentSelection) {\n\t\t\t\t// Set current = selected\n\t\t\t\tthis._currentSelection = this.selected;\n\n\t\t\t\tthis._onDidSelect.fire({\n\t\t\t\t\tindex: this.selectElement.selectedIndex,\n\t\t\t\t\tselected: this.selectElement.title\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthis.hideSelectDropDown(true);\n\t\t}\n\t}\n\n\t// List Exit - passive - implicit no selection change, hide drop-down\n\tprivate onListBlur(): void {\n\t\tif (this._sticky) { return; }\n\t\tif (this.selected !== this._currentSelection) {\n\t\t\t// Reset selected to current if no change\n\t\t\tthis.select(this._currentSelection);\n\t\t}\n\n\t\tthis.hideSelectDropDown(false);\n\t}\n\n\n\tprivate renderDescriptionMarkdown(text: string): HTMLElement {\n\t\tconst cleanRenderedMarkdown = (element: Node) => {\n\t\t\tfor (let i = 0; i < element.childNodes.length; i++) {\n\t\t\t\tconst child = element.childNodes.item(i);\n\n\t\t\t\tconst tagName = (<Element>child).tagName && (<Element>child).tagName.toLowerCase();\n\t\t\t\tif (tagName === 'img') {\n\t\t\t\t\telement.removeChild(child);\n\t\t\t\t} else {\n\t\t\t\t\tcleanRenderedMarkdown(child);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tconst renderedMarkdown = renderMarkdown({ value: text }, {\n\t\t\tactionHandler: this.selectBoxOptions.markdownActionHandler\n\t\t});\n\n\t\trenderedMarkdown.classList.add('select-box-description-markdown');\n\t\tcleanRenderedMarkdown(renderedMarkdown);\n\n\t\treturn renderedMarkdown;\n\t}\n\n\t// List Focus Change - passive - update details pane with newly focused element's data\n\tprivate onListFocus(e: IListEvent<ISelectOptionItem>) {\n\t\tthis.selectionDetailsPane.innerText = '';\n\t\tconst selectedIndex = e.indexes[0];\n\t\tlet description = this.detailsProvider ? this.detailsProvider(selectedIndex) : { details: '', isMarkdown: false };\n\t\tif (description.details) {\n\t\t\tif (description.isMarkdown) {\n\t\t\t\tthis.selectionDetailsPane.appendChild(this.renderDescriptionMarkdown(description.details));\n\t\t\t} else {\n\t\t\t\tthis.selectionDetailsPane.innerText = description.details;\n\t\t\t}\n\t\t\tthis.selectionDetailsPane.style.display = 'block';\n\t\t} else {\n\t\t\tthis.selectionDetailsPane.style.display = 'none';\n\t\t}\n\t}\n\n\t// List keyboard controller\n\n\t// List exit - active - hide ContextView dropdown, reset selection, return focus to parent select\n\tprivate onEscape(e: StandardKeyboardEvent): void {\n\t\tdom.EventHelper.stop(e);\n\n\t\t// Reset selection to value when opened\n\t\tthis.select(this._currentSelection);\n\t\tthis.hideSelectDropDown(true);\n\t}\n\n\t// List exit - active - hide ContextView dropdown, return focus to parent select, fire onDidSelect if change\n\tprivate onEnter(e: StandardKeyboardEvent): void {\n\t\tdom.EventHelper.stop(e);\n\n\t\t// Only fire if selection change\n\t\tif (this.selected !== this._currentSelection) {\n\t\t\tthis._currentSelection = this.selected;\n\t\t\tthis._onDidSelect.fire({\n\t\t\t\tindex: this.selectElement.selectedIndex,\n\t\t\t\tselected: this.selectElement.title\n\t\t\t});\n\t\t}\n\n\t\tthis.hideSelectDropDown(true);\n\t}\n\n\t// List navigation - have to handle a disabled option (jump over)\n\tprivate onDownArrow(): void {\n\t\tif (this.selected < this.options.length - 1) {\n\t\t\t// Skip disabled options\n\t\t\tif ((this.selected + 1) === this.disabledOptionIndex && this.options.length > this.selected + 2) {\n\t\t\t\tthis.selected += 2;\n\t\t\t} else {\n\t\t\t\tthis.selected++;\n\t\t\t}\n\t\t\t// Set focus/selection - only fire event when closing drop-down or on blur\n\t\t\tthis.select(this.selected);\n\t\t\tthis.selectList.setFocus([this.selected]);\n\t\t\tthis.selectList.reveal(this.selectList.getFocus()[0]);\n\t\t}\n\t}\n\n\tprivate onUpArrow(): void {\n\t\tif (this.selected > 0) {\n\t\t\t// Skip disabled options\n\t\t\tif ((this.selected - 1) === this.disabledOptionIndex && this.selected > 1) {\n\t\t\t\tthis.selected -= 2;\n\t\t\t} else {\n\t\t\t\tthis.selected--;\n\t\t\t}\n\t\t\t// Set focus/selection - only fire event when closing drop-down or on blur\n\t\t\tthis.select(this.selected);\n\t\t\tthis.selectList.setFocus([this.selected]);\n\t\t\tthis.selectList.reveal(this.selectList.getFocus()[0]);\n\t\t}\n\t}\n\n\tprivate onPageUp(e: StandardKeyboardEvent): void {\n\t\tdom.EventHelper.stop(e);\n\n\t\tthis.selectList.focusPreviousPage();\n\n\t\t// Allow scrolling to settle\n\t\tsetTimeout(() => {\n\t\t\tthis.selected = this.selectList.getFocus()[0];\n\n\t\t\t// Shift selection down if we land on a disabled option\n\t\t\tif (this.selected === this.disabledOptionIndex && this.selected < this.options.length - 1) {\n\t\t\t\tthis.selected++;\n\t\t\t\tthis.selectList.setFocus([this.selected]);\n\t\t\t}\n\t\t\tthis.selectList.reveal(this.selected);\n\t\t\tthis.select(this.selected);\n\t\t}, 1);\n\t}\n\n\tprivate onPageDown(e: StandardKeyboardEvent): void {\n\t\tdom.EventHelper.stop(e);\n\n\t\tthis.selectList.focusNextPage();\n\n\t\t// Allow scrolling to settle\n\t\tsetTimeout(() => {\n\t\t\tthis.selected = this.selectList.getFocus()[0];\n\n\t\t\t// Shift selection up if we land on a disabled option\n\t\t\tif (this.selected === this.disabledOptionIndex && this.selected > 0) {\n\t\t\t\tthis.selected--;\n\t\t\t\tthis.selectList.setFocus([this.selected]);\n\t\t\t}\n\t\t\tthis.selectList.reveal(this.selected);\n\t\t\tthis.select(this.selected);\n\t\t}, 1);\n\t}\n\n\tprivate onHome(e: StandardKeyboardEvent): void {\n\t\tdom.EventHelper.stop(e);\n\n\t\tif (this.options.length < 2) {\n\t\t\treturn;\n\t\t}\n\t\tthis.selected = 0;\n\t\tif (this.selected === this.disabledOptionIndex && this.selected > 1) {\n\t\t\tthis.selected++;\n\t\t}\n\t\tthis.selectList.setFocus([this.selected]);\n\t\tthis.selectList.reveal(this.selected);\n\t\tthis.select(this.selected);\n\t}\n\n\tprivate onEnd(e: StandardKeyboardEvent): void {\n\t\tdom.EventHelper.stop(e);\n\n\t\tif (this.options.length < 2) {\n\t\t\treturn;\n\t\t}\n\t\tthis.selected = this.options.length - 1;\n\t\tif (this.selected === this.disabledOptionIndex && this.selected > 1) {\n\t\t\tthis.selected--;\n\t\t}\n\t\tthis.selectList.setFocus([this.selected]);\n\t\tthis.selectList.reveal(this.selected);\n\t\tthis.select(this.selected);\n\t}\n\n\t// Mimic option first character navigation of native select\n\tprivate onCharacter(e: StandardKeyboardEvent): void {\n\t\tconst ch = KeyCodeUtils.toString(e.keyCode);\n\t\tlet optionIndex = -1;\n\n\t\tfor (let i = 0; i < this.options.length - 1; i++) {\n\t\t\toptionIndex = (i + this.selected + 1) % this.options.length;\n\t\t\tif (this.options[optionIndex].charAt(0).toUpperCase() === ch) {\n\t\t\t\tthis.select(optionIndex);\n\t\t\t\tthis.selectList.setFocus([optionIndex]);\n\t\t\t\tthis.selectList.reveal(this.selectList.getFocus()[0]);\n\t\t\t\tdom.EventHelper.stop(e);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic dispose(): void {\n\t\tthis.hideSelectDropDown(false);\n\t\tthis.toDispose = dispose(this.toDispose);\n\t}\n}\n",
            "linguagem": "ts",
            "total_linhas": 903
        },
        "solucao_humana": {
            "patch_diff": "@@ -106,7 +106,7 @@ export class SelectBoxList implements ISelectBoxDelegate, IVirtualDelegate<ISele\n \tprivate _dropDownPosition: AnchorPosition;\n \tprivate detailsProvider: (index: number) => { details: string, isMarkdown: boolean };\n \tprivate selectionDetailsPane: HTMLElement;\n-\n+\tprivate _skipLayout: boolean = false;\n \n \tprivate _sticky: boolean = false; // for dev purposes only\n \n@@ -181,6 +181,7 @@ export class SelectBoxList implements ISelectBoxDelegate, IVirtualDelegate<ISele\n \n \t\tthis.toDispose.push(dom.addStandardDisposableListener(this.selectElement, 'change', (e) => {\n \t\t\tthis.selectElement.title = e.target.value;\n+\t\t\tthis.selected = e.target.selectedIndex;\n \t\t\tthis._onDidSelect.fire({\n \t\t\t\tindex: e.target.selectedIndex,\n \t\t\t\tselected: e.target.value\n@@ -333,11 +334,13 @@ export class SelectBoxList implements ISelectBoxDelegate, IVirtualDelegate<ISele\n \n \t\tif (!this.styles.selectBorder.equals(this.styles.selectBackground)) {\n \t\t\tcontent.push(`.monaco-select-box-dropdown-container { border: 1px solid ${this.styles.selectBorder} } `);\n-\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-details-pane { border-top: 1px solid ${this.styles.selectBorder} } `);\n+\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-details-pane.border-top { border-top: 1px solid ${this.styles.selectBorder} } `);\n+\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-details-pane.border-bottom { border-bottom: 1px solid ${this.styles.selectBorder} } `);\n+\n \t\t}\n \t\telse if (this.styles.selectListBorder) {\n-\t\t\tcontent.push(`.monaco-select-box-dropdown-container { border: 1px solid ${this.styles.selectListBorder} } `);\n-\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-details-pane { border-top: 1px solid ${this.styles.selectListBorder} } `);\n+\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-details-pane.border-top { border-top: 1px solid ${this.styles.selectListBorder} } `);\n+\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-details-pane.border-bottom { border-bottom: 1px solid ${this.styles.selectListBorder} } `);\n \t\t}\n \n \t\t// Hover foreground - ignore for disabled options\n@@ -355,6 +358,7 @@ export class SelectBoxList implements ISelectBoxDelegate, IVirtualDelegate<ISele\n \t\t// Match quickOpen outline styles - ignore for disabled options\n \t\tif (this.styles.listFocusOutline) {\n \t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.focused { outline: 1.6px dotted ${this.styles.listFocusOutline} !important; outline-offset: -1.6px !important; }`);\n+\n \t\t}\n \n \t\tif (this.styles.listHoverOutline) {\n@@ -413,13 +417,28 @@ export class SelectBoxList implements ISelectBoxDelegate, IVirtualDelegate<ISele\n \t\t\treturn;\n \t\t}\n \n+\t\tthis.cloneElementFont(this.selectElement, this.selectDropDownContainer);\n+\n+\t\t// This allows us to flip the position based on measurement\n \t\t// Set drop-down position above/below from required height and margins\n \t\t// If pre-layout cannot fit at least one option do not show drop-down\n-\t\tif (!this.layoutSelectDropDown(true)) {\n-\t\t\treturn;\n-\t\t}\n \n-\t\tthis.cloneElementFont(this.selectElement, this.selectDropDownContainer);\n+\t\tthis.contextViewProvider.showContextView({\n+\t\t\tgetAnchor: () => this.selectElement,\n+\t\t\trender: (container: HTMLElement) => this.renderSelectDropDown(container, true),\n+\t\t\tlayout: () => {\n+\t\t\t\tthis.layoutSelectDropDown();\n+\t\t\t},\n+\t\t\tonHide: () => {\n+\t\t\t\tdom.toggleClass(this.selectDropDownContainer, 'visible', false);\n+\t\t\t\tdom.toggleClass(this.selectElement, 'synthetic-focus', false);\n+\t\t\t},\n+\t\t\tanchorPosition: this._dropDownPosition\n+\t\t});\n+\n+\t\t// Hide so we can relay out\n+\t\tthis._isVisible = true;\n+\t\tthis.hideSelectDropDown(false);\n \n \t\tthis.contextViewProvider.showContextView({\n \t\t\tgetAnchor: () => this.selectElement,\n@@ -451,10 +470,12 @@ export class SelectBoxList implements ISelectBoxDelegate, IVirtualDelegate<ISele\n \t\tthis.contextViewProvider.hideContextView();\n \t}\n \n-\tprivate renderSelectDropDown(container: HTMLElement): IDisposable {\n+\tprivate renderSelectDropDown(container: HTMLElement, preLayoutPosition?: boolean): IDisposable {\n \t\tcontainer.appendChild(this.selectDropDownContainer);\n \n-\t\tthis.layoutSelectDropDown();\n+\t\t// Pre-Layout allows us to change position\n+\t\tthis.layoutSelectDropDown(preLayoutPosition);\n+\n \t\treturn {\n \t\t\tdispose: () => {\n \t\t\t\t// contextView will dispose itself if moving from one View to another\n@@ -468,33 +489,99 @@ export class SelectBoxList implements ISelectBoxDelegate, IVirtualDelegate<ISele\n \t\t};\n \t}\n \n+\t// Iterate over detailed descriptions, find max height\n+\tprivate measureMaxDetailsHeight(): number {\n+\n+\t\tif (!this.detailsProvider) {\n+\t\t\treturn 0;\n+\t\t}\n+\n+\t\tlet maxDetailsPaneHeight = 0;\n+\t\tlet description = { details: '', isMarkdown: false };\n+\n+\t\tthis.options.forEach((option, index) => {\n+\n+\t\t\tthis.selectionDetailsPane.innerText = '';\n+\n+\t\t\tdescription = this.detailsProvider ? this.detailsProvider(index) : { details: '', isMarkdown: false };\n+\t\t\tif (description.details) {\n+\t\t\t\tif (description.isMarkdown) {\n+\t\t\t\t\tthis.selectionDetailsPane.appendChild(this.renderDescriptionMarkdown(description.details));\n+\t\t\t\t} else {\n+\t\t\t\t\tthis.selectionDetailsPane.innerText = description.details;\n+\t\t\t\t}\n+\t\t\t\tthis.selectionDetailsPane.style.display = 'block';\n+\t\t\t} else {\n+\t\t\t\tthis.selectionDetailsPane.style.display = 'none';\n+\t\t\t}\n+\n+\t\t\tif (this.selectionDetailsPane.offsetHeight > maxDetailsPaneHeight) {\n+\t\t\t\tmaxDetailsPaneHeight = this.selectionDetailsPane.offsetHeight;\n+\t\t\t}\n+\t\t});\n+\n+\t\t// Reset description to selected\n+\t\tdescription = this.detailsProvider ? this.detailsProvider(this.selected) : { details: '', isMarkdown: false };\n+\t\tthis.selectionDetailsPane.innerText = '';\n+\n+\t\tif (description.details) {\n+\t\t\tif (description.isMarkdown) {\n+\t\t\t\tthis.selectionDetailsPane.appendChild(this.renderDescriptionMarkdown(description.details));\n+\t\t\t} else {\n+\t\t\t\tthis.selectionDetailsPane.innerText = description.details;\n+\t\t\t}\n+\t\t\tthis.selectionDetailsPane.style.display = 'block';\n+\t\t}\n+\n+\t\treturn maxDetailsPaneHeight;\n+\t}\n+\n \tprivate layoutSelectDropDown(preLayoutPosition?: boolean): boolean {\n \n+\t\t// Avoid recursion from layout called in onListFocus\n+\t\tif (this._skipLayout) {\n+\t\t\treturn false;\n+\t\t}\n+\n \t\t// Layout ContextView drop down select list and container\n \t\t// Have to manage our vertical overflow, sizing, position below or above\n \t\t// Position has to be determined and set prior to contextView instantiation\n \n \t\tif (this.selectList) {\n \n+\t\t\t// Make visible to enable measurements\n+\t\t\tdom.toggleClass(this.selectDropDownContainer, 'visible', true);\n+\n \t\t\tconst selectPosition = dom.getDomNodePagePosition(this.selectElement);\n \t\t\tconst styles = getComputedStyle(this.selectElement);\n \t\t\tconst verticalPadding = parseFloat(styles.getPropertyValue('--dropdown-padding-top')) + parseFloat(styles.getPropertyValue('--dropdown-padding-bottom'));\n \t\t\tconst maxSelectDropDownHeightBelow = (window.innerHeight - selectPosition.top - selectPosition.height - this.selectBoxOptions.minBottomMargin);\n \t\t\tconst maxSelectDropDownHeightAbove = (selectPosition.top - SelectBoxList.DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN);\n \n-\t\t\t// Get initial list height and determine space above and below\n+\t\t\t// Determine optimal width - min(longest option), opt(parent select, excluding margins), max(ContextView controlled)\n+\t\t\tconst selectWidth = this.selectElement.offsetWidth;\n+\t\t\tconst selectMinWidth = this.setWidthControlElement(this.widthControlElement);\n+\t\t\tconst selectOptimalWidth = Math.max(selectMinWidth, Math.round(selectWidth)).toString() + 'px';\n+\n+\t\t\tthis.selectDropDownContainer.style.width = selectOptimalWidth;\n+\n+\t\t\t// Get initial list height and determine space ab1you knowove and below\n \t\t\tthis.selectList.layout();\n \t\t\tlet listHeight = this.selectList.contentHeight;\n-\t\t\tconst minRequiredDropDownHeight = listHeight + verticalPadding;\n-\t\t\tconst maxVisibleOptionsBelow = ((Math.floor((maxSelectDropDownHeightBelow - verticalPadding) / this.getHeight())));\n-\t\t\tconst maxVisibleOptionsAbove = ((Math.floor((maxSelectDropDownHeightAbove - verticalPadding) / this.getHeight())));\n+\n+\t\t\tconst maxDetailsPaneHeight = this.measureMaxDetailsHeight();\n+\n+\t\t\tconst minRequiredDropDownHeight = listHeight + verticalPadding + maxDetailsPaneHeight;\n+\t\t\tconst maxVisibleOptionsBelow = ((Math.floor((maxSelectDropDownHeightBelow - verticalPadding - maxDetailsPaneHeight) / this.getHeight())));\n+\t\t\tconst maxVisibleOptionsAbove = ((Math.floor((maxSelectDropDownHeightAbove - verticalPadding - maxDetailsPaneHeight) / this.getHeight())));\n \n \t\t\t// If we are only doing pre-layout check/adjust position only\n \t\t\t// Calculate vertical space available, flip up if insufficient\n \t\t\t// Use reflected padding on parent select, ContextView style\n \t\t\t// properties not available before DOM attachment\n \n \t\t\tif (preLayoutPosition) {\n+\n \t\t\t\t// Check if select moved out of viewport , do not open\n \t\t\t\t// If at least one option cannot be shown, don't open the drop-down or hide/remove if open\n \n@@ -512,8 +599,23 @@ export class SelectBoxList implements ISelectBoxDelegate, IVirtualDelegate<ISele\n \t\t\t\t\t&& this.options.length > maxVisibleOptionsBelow\n \t\t\t\t) {\n \t\t\t\t\tthis._dropDownPosition = AnchorPosition.ABOVE;\n+\t\t\t\t\tthis.selectDropDownContainer.removeChild(this.selectDropDownListContainer);\n+\t\t\t\t\tthis.selectDropDownContainer.removeChild(this.selectionDetailsPane);\n+\t\t\t\t\tthis.selectDropDownContainer.appendChild(this.selectionDetailsPane);\n+\t\t\t\t\tthis.selectDropDownContainer.appendChild(this.selectDropDownListContainer);\n+\n+\t\t\t\t\tdom.removeClass(this.selectionDetailsPane, 'border-top');\n+\t\t\t\t\tdom.addClass(this.selectionDetailsPane, 'border-bottom');\n+\n \t\t\t\t} else {\n \t\t\t\t\tthis._dropDownPosition = AnchorPosition.BELOW;\n+\t\t\t\t\tthis.selectDropDownContainer.removeChild(this.selectDropDownListContainer);\n+\t\t\t\t\tthis.selectDropDownContainer.removeChild(this.selectionDetailsPane);\n+\t\t\t\t\tthis.selectDropDownContainer.appendChild(this.selectDropDownListContainer);\n+\t\t\t\t\tthis.selectDropDownContainer.appendChild(this.selectionDetailsPane);\n+\n+\t\t\t\t\tdom.removeClass(this.selectionDetailsPane, 'border-bottom');\n+\t\t\t\t\tdom.addClass(this.selectionDetailsPane, 'border-top');\n \t\t\t\t}\n \t\t\t\t// Do full layout on showSelectDropDown only\n \t\t\t\treturn true;\n@@ -529,9 +631,6 @@ export class SelectBoxList implements ISelectBoxDelegate, IVirtualDelegate<ISele\n \t\t\t\treturn false;\n \t\t\t}\n \n-\t\t\t// Make visible to enable measurements\n-\t\t\tdom.toggleClass(this.selectDropDownContainer, 'visible', true);\n-\n \t\t\t// SetUp list dimensions and layout - account for container padding\n \t\t\t// Use position to check above or below available space\n \t\t\tif (this._dropDownPosition === AnchorPosition.BELOW) {\n@@ -542,15 +641,13 @@ export class SelectBoxList implements ISelectBoxDelegate, IVirtualDelegate<ISele\n \t\t\t\t\treturn false;\n \t\t\t\t}\n \n-\t\t\t\t// Set container height to max from select bottom to margin (default/minBottomMargin)\n+\t\t\t\t// Adjust list height to max from select bottom to margin (default/minBottomMargin)\n \t\t\t\tif (minRequiredDropDownHeight > maxSelectDropDownHeightBelow) {\n-\t\t\t\t\tlistHeight = (maxVisibleOptionsBelow * this.getHeight() + verticalPadding);\n+\t\t\t\t\tlistHeight = (maxVisibleOptionsBelow * this.getHeight());\n \t\t\t\t}\n \t\t\t} else {\n-\t\t\t\t// Set container height to max from select top to margin (default/minTopMargin)\n \t\t\t\tif (minRequiredDropDownHeight > maxSelectDropDownHeightAbove) {\n-\t\t\t\t\t// listHeight = ((Math.floor((maxSelectDropDownHeightBelow - verticalPadding) / this.getHeight())) * this.getHeight());\n-\t\t\t\t\tlistHeight = (maxVisibleOptionsAbove * this.getHeight() + verticalPadding);\n+\t\t\t\t\tlistHeight = (maxVisibleOptionsAbove * this.getHeight());\n \t\t\t\t}\n \t\t\t}\n \n@@ -571,16 +668,13 @@ export class SelectBoxList implements ISelectBoxDelegate, IVirtualDelegate<ISele\n \t\t\t\tthis.selectDropDownContainer.style.height = (listHeight + verticalPadding) + 'px';\n \t\t\t}\n \n-\t\t\t// Determine optimal width - min(longest option), opt(parent select, excluding margins), max(ContextView controlled)\n-\t\t\tconst selectWidth = this.selectElement.offsetWidth;\n-\t\t\tconst selectMinWidth = this.setWidthControlElement(this.widthControlElement);\n-\t\t\tconst selectOptimalWidth = Math.max(selectMinWidth, Math.round(selectWidth)).toString() + 'px';\n-\n \t\t\tthis.selectDropDownContainer.style.width = selectOptimalWidth;\n \n \t\t\t// Maintain focus outline on parent select as well as list container - tabindex for focus\n \t\t\tthis.selectDropDownListContainer.setAttribute('tabindex', '0');\n \t\t\tdom.toggleClass(this.selectElement, 'synthetic-focus', true);\n+\t\t\tdom.toggleClass(this.selectDropDownContainer, 'synthetic-focus', true);\n+\n \t\t\treturn true;\n \t\t} else {\n \t\t\treturn false;\n@@ -736,6 +830,10 @@ export class SelectBoxList implements ISelectBoxDelegate, IVirtualDelegate<ISele\n \n \t// List Focus Change - passive - update details pane with newly focused element's data\n \tprivate onListFocus(e: IListEvent<ISelectOptionItem>) {\n+\t\t// Skip during initial layout\n+\t\tif (!this._isVisible) {\n+\t\t\treturn;\n+\t\t}\n \t\tthis.selectionDetailsPane.innerText = '';\n \t\tconst selectedIndex = e.indexes[0];\n \t\tlet description = this.detailsProvider ? this.detailsProvider(selectedIndex) : { details: '', isMarkdown: false };\n@@ -749,6 +847,12 @@ export class SelectBoxList implements ISelectBoxDelegate, IVirtualDelegate<ISele\n \t\t} else {\n \t\t\tthis.selectionDetailsPane.style.display = 'none';\n \t\t}\n+\n+\t\t// Avoid recursion\n+\t\tthis._skipLayout = true;\n+\t\tthis.contextViewProvider.layout();\n+\t\tthis._skipLayout = false;\n+\n \t}\n \n \t// List keyboard controller",
            "apenas_linhas_adicionadas": [
                "\tprivate _skipLayout: boolean = false;",
                "\t\t\tthis.selected = e.target.selectedIndex;",
                "\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-details-pane.border-top { border-top: 1px solid ${this.styles.selectBorder} } `);",
                "\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-details-pane.border-bottom { border-bottom: 1px solid ${this.styles.selectBorder} } `);",
                "",
                "\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-details-pane.border-top { border-top: 1px solid ${this.styles.selectListBorder} } `);",
                "\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-details-pane.border-bottom { border-bottom: 1px solid ${this.styles.selectListBorder} } `);",
                "",
                "\t\tthis.cloneElementFont(this.selectElement, this.selectDropDownContainer);",
                "",
                "\t\t// This allows us to flip the position based on measurement",
                "\t\tthis.contextViewProvider.showContextView({",
                "\t\t\tgetAnchor: () => this.selectElement,",
                "\t\t\trender: (container: HTMLElement) => this.renderSelectDropDown(container, true),",
                "\t\t\tlayout: () => {",
                "\t\t\t\tthis.layoutSelectDropDown();",
                "\t\t\t},",
                "\t\t\tonHide: () => {",
                "\t\t\t\tdom.toggleClass(this.selectDropDownContainer, 'visible', false);",
                "\t\t\t\tdom.toggleClass(this.selectElement, 'synthetic-focus', false);",
                "\t\t\t},",
                "\t\t\tanchorPosition: this._dropDownPosition",
                "\t\t});",
                "",
                "\t\t// Hide so we can relay out",
                "\t\tthis._isVisible = true;",
                "\t\tthis.hideSelectDropDown(false);",
                "\tprivate renderSelectDropDown(container: HTMLElement, preLayoutPosition?: boolean): IDisposable {",
                "\t\t// Pre-Layout allows us to change position",
                "\t\tthis.layoutSelectDropDown(preLayoutPosition);",
                "",
                "\t// Iterate over detailed descriptions, find max height",
                "\tprivate measureMaxDetailsHeight(): number {",
                "",
                "\t\tif (!this.detailsProvider) {",
                "\t\t\treturn 0;",
                "\t\t}",
                "",
                "\t\tlet maxDetailsPaneHeight = 0;",
                "\t\tlet description = { details: '', isMarkdown: false };",
                "",
                "\t\tthis.options.forEach((option, index) => {",
                "",
                "\t\t\tthis.selectionDetailsPane.innerText = '';",
                "",
                "\t\t\tdescription = this.detailsProvider ? this.detailsProvider(index) : { details: '', isMarkdown: false };",
                "\t\t\tif (description.details) {",
                "\t\t\t\tif (description.isMarkdown) {",
                "\t\t\t\t\tthis.selectionDetailsPane.appendChild(this.renderDescriptionMarkdown(description.details));",
                "\t\t\t\t} else {",
                "\t\t\t\t\tthis.selectionDetailsPane.innerText = description.details;",
                "\t\t\t\t}",
                "\t\t\t\tthis.selectionDetailsPane.style.display = 'block';",
                "\t\t\t} else {",
                "\t\t\t\tthis.selectionDetailsPane.style.display = 'none';",
                "\t\t\t}",
                "",
                "\t\t\tif (this.selectionDetailsPane.offsetHeight > maxDetailsPaneHeight) {",
                "\t\t\t\tmaxDetailsPaneHeight = this.selectionDetailsPane.offsetHeight;",
                "\t\t\t}",
                "\t\t});",
                "",
                "\t\t// Reset description to selected",
                "\t\tdescription = this.detailsProvider ? this.detailsProvider(this.selected) : { details: '', isMarkdown: false };",
                "\t\tthis.selectionDetailsPane.innerText = '';",
                "",
                "\t\tif (description.details) {",
                "\t\t\tif (description.isMarkdown) {",
                "\t\t\t\tthis.selectionDetailsPane.appendChild(this.renderDescriptionMarkdown(description.details));",
                "\t\t\t} else {",
                "\t\t\t\tthis.selectionDetailsPane.innerText = description.details;",
                "\t\t\t}",
                "\t\t\tthis.selectionDetailsPane.style.display = 'block';",
                "\t\t}",
                "",
                "\t\treturn maxDetailsPaneHeight;",
                "\t}",
                "",
                "\t\t// Avoid recursion from layout called in onListFocus",
                "\t\tif (this._skipLayout) {",
                "\t\t\treturn false;",
                "\t\t}",
                "",
                "\t\t\t// Make visible to enable measurements",
                "\t\t\tdom.toggleClass(this.selectDropDownContainer, 'visible', true);",
                "",
                "\t\t\t// Determine optimal width - min(longest option), opt(parent select, excluding margins), max(ContextView controlled)",
                "\t\t\tconst selectWidth = this.selectElement.offsetWidth;",
                "\t\t\tconst selectMinWidth = this.setWidthControlElement(this.widthControlElement);",
                "\t\t\tconst selectOptimalWidth = Math.max(selectMinWidth, Math.round(selectWidth)).toString() + 'px';",
                "",
                "\t\t\tthis.selectDropDownContainer.style.width = selectOptimalWidth;",
                "",
                "\t\t\t// Get initial list height and determine space ab1you knowove and below",
                "",
                "\t\t\tconst maxDetailsPaneHeight = this.measureMaxDetailsHeight();",
                "",
                "\t\t\tconst minRequiredDropDownHeight = listHeight + verticalPadding + maxDetailsPaneHeight;",
                "\t\t\tconst maxVisibleOptionsBelow = ((Math.floor((maxSelectDropDownHeightBelow - verticalPadding - maxDetailsPaneHeight) / this.getHeight())));",
                "\t\t\tconst maxVisibleOptionsAbove = ((Math.floor((maxSelectDropDownHeightAbove - verticalPadding - maxDetailsPaneHeight) / this.getHeight())));",
                "",
                "\t\t\t\t\tthis.selectDropDownContainer.removeChild(this.selectDropDownListContainer);",
                "\t\t\t\t\tthis.selectDropDownContainer.removeChild(this.selectionDetailsPane);",
                "\t\t\t\t\tthis.selectDropDownContainer.appendChild(this.selectionDetailsPane);",
                "\t\t\t\t\tthis.selectDropDownContainer.appendChild(this.selectDropDownListContainer);",
                "",
                "\t\t\t\t\tdom.removeClass(this.selectionDetailsPane, 'border-top');",
                "\t\t\t\t\tdom.addClass(this.selectionDetailsPane, 'border-bottom');",
                "",
                "\t\t\t\t\tthis.selectDropDownContainer.removeChild(this.selectDropDownListContainer);",
                "\t\t\t\t\tthis.selectDropDownContainer.removeChild(this.selectionDetailsPane);",
                "\t\t\t\t\tthis.selectDropDownContainer.appendChild(this.selectDropDownListContainer);",
                "\t\t\t\t\tthis.selectDropDownContainer.appendChild(this.selectionDetailsPane);",
                "",
                "\t\t\t\t\tdom.removeClass(this.selectionDetailsPane, 'border-bottom');",
                "\t\t\t\t\tdom.addClass(this.selectionDetailsPane, 'border-top');",
                "\t\t\t\t// Adjust list height to max from select bottom to margin (default/minBottomMargin)",
                "\t\t\t\t\tlistHeight = (maxVisibleOptionsBelow * this.getHeight());",
                "\t\t\t\t\tlistHeight = (maxVisibleOptionsAbove * this.getHeight());",
                "\t\t\tdom.toggleClass(this.selectDropDownContainer, 'synthetic-focus', true);",
                "",
                "\t\t// Skip during initial layout",
                "\t\tif (!this._isVisible) {",
                "\t\t\treturn;",
                "\t\t}",
                "",
                "\t\t// Avoid recursion",
                "\t\tthis._skipLayout = true;",
                "\t\tthis.contextViewProvider.layout();",
                "\t\tthis._skipLayout = false;",
                ""
            ]
        }
    },
    {
        "id": 58982,
        "url": "https://github.com/microsoft/vscode/pull/58982",
        "arquivo_caminho": "src/vs/base/browser/ui/selectBox/selectBoxCustom.ts",
        "descricao_bug": "- make sure disabled option is skipped, including last option",
        "contexto": {
            "codigo_completo_bugado": "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport 'vs/css!./selectBoxCustom';\n\nimport * as nls from 'vs/nls';\nimport { IDisposable, dispose } from 'vs/base/common/lifecycle';\nimport { Event, Emitter, chain } from 'vs/base/common/event';\nimport { KeyCode, KeyCodeUtils } from 'vs/base/common/keyCodes';\nimport { StandardKeyboardEvent } from 'vs/base/browser/keyboardEvent';\nimport * as dom from 'vs/base/browser/dom';\nimport * as arrays from 'vs/base/common/arrays';\nimport { IContextViewProvider, AnchorPosition } from 'vs/base/browser/ui/contextview/contextview';\nimport { List } from 'vs/base/browser/ui/list/listWidget';\nimport { IVirtualDelegate, IRenderer, IListEvent } from 'vs/base/browser/ui/list/list';\nimport { domEvent } from 'vs/base/browser/event';\nimport { ScrollbarVisibility } from 'vs/base/common/scrollable';\nimport { ISelectBoxDelegate, ISelectBoxOptions, ISelectBoxStyles, ISelectData } from 'vs/base/browser/ui/selectBox/selectBox';\nimport { isMacintosh } from 'vs/base/common/platform';\nimport { renderMarkdown } from 'vs/base/browser/htmlContentRenderer';\n\nconst $ = dom.$;\n\nconst SELECT_OPTION_ENTRY_TEMPLATE_ID = 'selectOption.entry.template';\n\nexport interface ISelectOptionItem {\n\toptionText: string;\n\toptionDescriptionText?: string;\n\toptionDisabled: boolean;\n}\n\ninterface ISelectListTemplateData {\n\troot: HTMLElement;\n\toptionText: HTMLElement;\n\toptionDescriptionText: HTMLElement;\n\tdisposables: IDisposable[];\n}\n\nclass SelectListRenderer implements IRenderer<ISelectOptionItem, ISelectListTemplateData> {\n\n\tget templateId(): string { return SELECT_OPTION_ENTRY_TEMPLATE_ID; }\n\n\tconstructor() { }\n\n\trenderTemplate(container: HTMLElement): any {\n\t\tconst data = <ISelectListTemplateData>Object.create(null);\n\t\tdata.disposables = [];\n\t\tdata.root = container;\n\t\tdata.optionText = dom.append(container, $('.option-text'));\n\t\tdata.optionDescriptionText = dom.append(container, $('.option-text-description'));\n\n\t\treturn data;\n\t}\n\n\trenderElement(element: ISelectOptionItem, index: number, templateData: ISelectListTemplateData): void {\n\t\tconst data = <ISelectListTemplateData>templateData;\n\t\tconst optionText = (<ISelectOptionItem>element).optionText;\n\t\tconst optionDisabled = (<ISelectOptionItem>element).optionDisabled;\n\n\t\tdata.optionText.textContent = optionText;\n\t\tdata.root.setAttribute('aria-label', nls.localize('selectAriaOption', \"{0}\", optionText) + ',.');\n\n\t\tif (typeof element.optionDescriptionText === 'string') {\n\t\t\tconst optionDescriptionId = (optionText.replace(/ /g, '_').toLowerCase() + '_description_' + data.root.id);\n\t\t\tdata.root.setAttribute('aria-describedby', optionDescriptionId);\n\t\t\tdata.optionDescriptionText.id = optionDescriptionId;\n\t\t\tdata.optionDescriptionText.setAttribute('aria-label', element.optionDescriptionText);\n\t\t}\n\n\t\t// Workaround for list labels\n\t\tdata.root.setAttribute('aria-selected', 'true');\n\n\t\t// pseudo-select disabled option\n\t\tif (optionDisabled) {\n\t\t\tdom.addClass((<HTMLElement>data.root), 'option-disabled');\n\t\t} else {\n\t\t\t// Make sure we do class removal from prior template rendering\n\t\t\tdom.removeClass((<HTMLElement>data.root), 'option-disabled');\n\t\t}\n\t}\n\n\tdisposeElement(): void {\n\t\t// noop\n\t}\n\n\tdisposeTemplate(templateData: ISelectListTemplateData): void {\n\t\ttemplateData.disposables = dispose(templateData.disposables);\n\t}\n}\n\nexport class SelectBoxList implements ISelectBoxDelegate, IVirtualDelegate<ISelectOptionItem> {\n\n\tprivate static readonly DEFAULT_DROPDOWN_MINIMUM_BOTTOM_MARGIN = 32;\n\tprivate static readonly DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN = 2;\n\tprivate static readonly DEFAULT_MINIMUM_VISIBLE_OPTIONS = 3;\n\n\tprivate _isVisible: boolean;\n\tprivate selectBoxOptions: ISelectBoxOptions;\n\tprivate selectElement: HTMLSelectElement;\n\tprivate options: string[];\n\tprivate selected: number;\n\tprivate disabledOptionIndex: number;\n\tprivate readonly _onDidSelect: Emitter<ISelectData>;\n\tprivate toDispose: IDisposable[];\n\tprivate styles: ISelectBoxStyles;\n\tprivate listRenderer: SelectListRenderer;\n\tprivate contextViewProvider: IContextViewProvider;\n\tprivate selectDropDownContainer: HTMLElement;\n\tprivate styleElement: HTMLStyleElement;\n\tprivate selectList: List<ISelectOptionItem>;\n\tprivate selectDropDownListContainer: HTMLElement;\n\tprivate widthControlElement: HTMLElement;\n\tprivate _currentSelection: number;\n\tprivate _dropDownPosition: AnchorPosition;\n\tprivate detailsProvider: (index: number) => { details: string, isMarkdown: boolean };\n\tprivate selectionDetailsPane: HTMLElement;\n\tprivate _skipLayout: boolean = false;\n\n\tprivate _sticky: boolean = false; // for dev purposes only\n\n\tconstructor(options: string[], selected: number, contextViewProvider: IContextViewProvider, styles: ISelectBoxStyles, selectBoxOptions?: ISelectBoxOptions) {\n\n\t\tthis.toDispose = [];\n\t\tthis._isVisible = false;\n\t\tthis.selectBoxOptions = selectBoxOptions || Object.create(null);\n\n\t\tif (typeof this.selectBoxOptions.minBottomMargin !== 'number') {\n\t\t\tthis.selectBoxOptions.minBottomMargin = SelectBoxList.DEFAULT_DROPDOWN_MINIMUM_BOTTOM_MARGIN;\n\t\t} else if (this.selectBoxOptions.minBottomMargin < 0) {\n\t\t\tthis.selectBoxOptions.minBottomMargin = 0;\n\t\t}\n\n\t\tthis.selectElement = document.createElement('select');\n\t\t// Use custom CSS vars for padding calculation\n\t\tthis.selectElement.className = 'monaco-select-box monaco-select-box-dropdown-padding';\n\n\t\tif (typeof this.selectBoxOptions.ariaLabel === 'string') {\n\t\t\tthis.selectElement.setAttribute('aria-label', this.selectBoxOptions.ariaLabel);\n\t\t}\n\n\t\tthis._onDidSelect = new Emitter<ISelectData>();\n\t\tthis.toDispose.push(this._onDidSelect);\n\n\t\tthis.styles = styles;\n\n\t\tthis.registerListeners();\n\t\tthis.constructSelectDropDown(contextViewProvider);\n\n\t\tthis.selected = selected || 0;\n\n\t\t// CDL check\n\t\tif (options) {\n\t\t\tthis.setOptions(options, selected);\n\t\t}\n\n\t}\n\n\t// IDelegate - List renderer\n\n\tgetHeight(): number {\n\t\treturn 18;\n\t}\n\n\tgetTemplateId(): string {\n\t\treturn SELECT_OPTION_ENTRY_TEMPLATE_ID;\n\t}\n\n\tprivate constructSelectDropDown(contextViewProvider: IContextViewProvider) {\n\n\t\t// SetUp ContextView container to hold select Dropdown\n\t\tthis.contextViewProvider = contextViewProvider;\n\t\tthis.selectDropDownContainer = dom.$('.monaco-select-box-dropdown-container');\n\t\t// Use custom CSS vars for padding calculation (shared with parent select)\n\t\tdom.addClass(this.selectDropDownContainer, 'monaco-select-box-dropdown-padding');\n\n\t\t// Setup container for select option details\n\t\tthis.selectionDetailsPane = dom.append(this.selectDropDownContainer, $('.select-box-details-pane'));\n\n\t\t// Create span flex box item/div we can measure and control\n\t\tlet widthControlOuterDiv = dom.append(this.selectDropDownContainer, $('.select-box-dropdown-container-width-control'));\n\t\tlet widthControlInnerDiv = dom.append(widthControlOuterDiv, $('.width-control-div'));\n\t\tthis.widthControlElement = document.createElement('span');\n\t\tthis.widthControlElement.className = 'option-text-width-control';\n\t\tdom.append(widthControlInnerDiv, this.widthControlElement);\n\n\t\t// Always default to below position\n\t\tthis._dropDownPosition = AnchorPosition.BELOW;\n\n\t\t// Inline stylesheet for themes\n\t\tthis.styleElement = dom.createStyleSheet(this.selectDropDownContainer);\n\t}\n\n\tprivate registerListeners() {\n\n\t\t// Parent native select keyboard listeners\n\n\t\tthis.toDispose.push(dom.addStandardDisposableListener(this.selectElement, 'change', (e) => {\n\t\t\tthis.selectElement.title = e.target.value;\n\t\t\tthis.selected = e.target.selectedIndex;\n\t\t\tthis._onDidSelect.fire({\n\t\t\t\tindex: e.target.selectedIndex,\n\t\t\t\tselected: e.target.value\n\t\t\t});\n\t\t}));\n\n\t\t// Have to implement both keyboard and mouse controllers to handle disabled options\n\t\t// Intercept mouse events to override normal select actions on parents\n\n\t\tthis.toDispose.push(dom.addDisposableListener(this.selectElement, dom.EventType.CLICK, (e) => {\n\t\t\tdom.EventHelper.stop(e);\n\n\t\t\tif (this._isVisible) {\n\t\t\t\tthis.hideSelectDropDown(true);\n\t\t\t} else {\n\t\t\t\tthis.showSelectDropDown();\n\t\t\t}\n\t\t}));\n\n\t\tthis.toDispose.push(dom.addDisposableListener(this.selectElement, dom.EventType.MOUSE_DOWN, (e) => {\n\t\t\tdom.EventHelper.stop(e);\n\t\t}));\n\n\t\t// Intercept keyboard handling\n\n\t\tthis.toDispose.push(dom.addDisposableListener(this.selectElement, dom.EventType.KEY_DOWN, (e: KeyboardEvent) => {\n\t\t\tconst event = new StandardKeyboardEvent(e);\n\t\t\tlet showDropDown = false;\n\n\t\t\t// Create and drop down select list on keyboard select\n\t\t\tif (isMacintosh) {\n\t\t\t\tif (event.keyCode === KeyCode.DownArrow || event.keyCode === KeyCode.UpArrow || event.keyCode === KeyCode.Space || event.keyCode === KeyCode.Enter) {\n\t\t\t\t\tshowDropDown = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (event.keyCode === KeyCode.DownArrow && event.altKey || event.keyCode === KeyCode.UpArrow && event.altKey || event.keyCode === KeyCode.Space || event.keyCode === KeyCode.Enter) {\n\t\t\t\t\tshowDropDown = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (showDropDown) {\n\t\t\t\tthis.showSelectDropDown();\n\t\t\t\tdom.EventHelper.stop(e);\n\t\t\t}\n\t\t}));\n\t}\n\n\tpublic get onDidSelect(): Event<ISelectData> {\n\t\treturn this._onDidSelect.event;\n\t}\n\n\tpublic setOptions(options: string[], selected?: number, disabled?: number): void {\n\n\t\tif (!this.options || !arrays.equals(this.options, options)) {\n\t\t\tthis.options = options;\n\t\t\tthis.selectElement.options.length = 0;\n\n\t\t\tlet i = 0;\n\t\t\tthis.options.forEach((option) => {\n\t\t\t\tthis.selectElement.add(this.createOption(option, i, disabled === i++));\n\t\t\t});\n\t\t}\n\n\t\tif (selected !== undefined) {\n\t\t\tthis.select(selected);\n\t\t\t// Set current = selected since this is not necessarily a user exit\n\t\t\tthis._currentSelection = this.selected;\n\t\t}\n\t}\n\n\n\tprivate setOptionsList() {\n\n\t\t// Mirror options in drop-down\n\t\t// Populate select list for non-native select mode\n\t\tif (this.selectList && !!this.options) {\n\t\t\tlet listEntries: ISelectOptionItem[];\n\t\t\tlistEntries = [];\n\n\t\t\tfor (let index = 0; index < this.options.length; index++) {\n\t\t\t\tconst element = this.options[index];\n\t\t\t\tlet optionDisabled: boolean;\n\t\t\t\tindex === this.disabledOptionIndex ? optionDisabled = true : optionDisabled = false;\n\t\t\t\tconst optionDescription = this.detailsProvider ? this.detailsProvider(index) : { details: null, isMarkdown: false };\n\n\t\t\t\tlistEntries.push({ optionText: element, optionDisabled: optionDisabled, optionDescriptionText: optionDescription.details });\n\t\t\t}\n\t\t\tthis.selectList.splice(0, this.selectList.length, listEntries);\n\t\t}\n\t}\n\n\tpublic select(index: number): void {\n\n\t\tif (index >= 0 && index < this.options.length) {\n\t\t\tthis.selected = index;\n\t\t} else if (index > this.options.length - 1) {\n\t\t\t// Adjust index to end of list\n\t\t\t// This could make client out of sync with the select\n\t\t\tthis.select(this.options.length - 1);\n\t\t} else if (this.selected < 0) {\n\t\t\tthis.selected = 0;\n\t\t}\n\n\t\tthis.selectElement.selectedIndex = this.selected;\n\t\tthis.selectElement.title = this.options[this.selected];\n\t}\n\n\tpublic setAriaLabel(label: string): void {\n\t\tthis.selectBoxOptions.ariaLabel = label;\n\t\tthis.selectElement.setAttribute('aria-label', this.selectBoxOptions.ariaLabel);\n\t}\n\n\tpublic setDetailsProvider(provider: (index: number) => { details: string, isMarkdown: boolean }): void {\n\t\tthis.detailsProvider = provider;\n\t}\n\n\tpublic focus(): void {\n\t\tif (this.selectElement) {\n\t\t\tthis.selectElement.focus();\n\t\t}\n\t}\n\n\tpublic blur(): void {\n\t\tif (this.selectElement) {\n\t\t\tthis.selectElement.blur();\n\t\t}\n\t}\n\n\tpublic render(container: HTMLElement): void {\n\t\tdom.addClass(container, 'select-container');\n\t\tcontainer.appendChild(this.selectElement);\n\t\tthis.applyStyles();\n\t}\n\n\tpublic style(styles: ISelectBoxStyles): void {\n\n\t\tconst content: string[] = [];\n\n\t\tthis.styles = styles;\n\n\t\t// Style non-native select mode\n\n\t\tif (this.styles.listFocusBackground) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.focused { background-color: ${this.styles.listFocusBackground} !important; }`);\n\t\t}\n\n\t\tif (this.styles.listFocusForeground) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.focused:not(:hover) { color: ${this.styles.listFocusForeground} !important; }`);\n\t\t}\n\n\t\tif (!this.styles.selectBorder.equals(this.styles.selectBackground)) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container { border: 1px solid ${this.styles.selectBorder} } `);\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-details-pane.border-top { border-top: 1px solid ${this.styles.selectBorder} } `);\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-details-pane.border-bottom { border-bottom: 1px solid ${this.styles.selectBorder} } `);\n\n\t\t}\n\t\telse if (this.styles.selectListBorder) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-details-pane.border-top { border-top: 1px solid ${this.styles.selectListBorder} } `);\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-details-pane.border-bottom { border-bottom: 1px solid ${this.styles.selectListBorder} } `);\n\t\t}\n\n\t\t// Hover foreground - ignore for disabled options\n\t\tif (this.styles.listHoverForeground) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:hover { color: ${this.styles.listHoverForeground} !important; }`);\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.option-disabled:hover { background-color: ${this.styles.listActiveSelectionForeground} !important; }`);\n\t\t}\n\n\t\t// Hover background - ignore for disabled options\n\t\tif (this.styles.listHoverBackground) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:not(.option-disabled):not(.focused):hover { background-color: ${this.styles.listHoverBackground} !important; }`);\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.option-disabled:hover { background-color: ${this.styles.selectBackground} !important; }`);\n\t\t}\n\n\t\t// Match quickOpen outline styles - ignore for disabled options\n\t\tif (this.styles.listFocusOutline) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.focused { outline: 1.6px dotted ${this.styles.listFocusOutline} !important; outline-offset: -1.6px !important; }`);\n\n\t\t}\n\n\t\tif (this.styles.listHoverOutline) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:hover:not(.focused) { outline: 1.6px dashed ${this.styles.listHoverOutline} !important; outline-offset: -1.6px !important; }`);\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.option-disabled:hover { outline: none !important; }`);\n\t\t}\n\n\t\tthis.styleElement.innerHTML = content.join('\\n');\n\n\t\tthis.applyStyles();\n\t}\n\n\tpublic applyStyles(): void {\n\n\t\t// Style parent select\n\n\t\tlet background = null;\n\n\t\tif (this.selectElement) {\n\t\t\tbackground = this.styles.selectBackground ? this.styles.selectBackground.toString() : null;\n\t\t\tconst foreground = this.styles.selectForeground ? this.styles.selectForeground.toString() : null;\n\t\t\tconst border = this.styles.selectBorder ? this.styles.selectBorder.toString() : null;\n\n\t\t\tthis.selectElement.style.backgroundColor = background;\n\t\t\tthis.selectElement.style.color = foreground;\n\t\t\tthis.selectElement.style.borderColor = border;\n\t\t}\n\n\t\t// Style drop down select list (non-native mode only)\n\n\t\tif (this.selectList) {\n\t\t\tthis.styleList();\n\t\t}\n\t}\n\n\tprivate styleList() {\n\n\t\tif (this.selectList) {\n\t\t\tlet background = null;\n\t\t\tbackground = this.styles.selectBackground ? this.styles.selectBackground.toString() : null;\n\t\t\tthis.selectList.style({});\n\n\t\t\tlet listBackground = this.styles.selectListBackground ? this.styles.selectListBackground.toString() : background;\n\t\t\tthis.selectDropDownListContainer.style.backgroundColor = listBackground;\n\t\t\tthis.selectionDetailsPane.style.backgroundColor = listBackground;\n\t\t\tconst optionsBorder = this.styles.focusBorder ? this.styles.focusBorder.toString() : null;\n\t\t\tthis.selectDropDownContainer.style.outlineColor = optionsBorder;\n\t\t\tthis.selectDropDownContainer.style.outlineOffset = '-1px';\n\t\t}\n\t}\n\n\tprivate createOption(value: string, index: number, disabled?: boolean): HTMLOptionElement {\n\t\tlet option = document.createElement('option');\n\t\toption.value = value;\n\t\toption.text = value;\n\t\toption.disabled = disabled;\n\n\t\treturn option;\n\t}\n\n\t// ContextView dropdown methods\n\n\tprivate showSelectDropDown() {\n\n\t\tif (!this.contextViewProvider || this._isVisible) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Lazily create and populate list only at open, moved from constructor\n\t\tthis.createSelectList(this.selectDropDownContainer);\n\t\tthis.setOptionsList();\n\n\t\tthis.cloneElementFont(this.selectElement, this.selectDropDownContainer);\n\n\t\t// This allows us to flip the position based on measurement\n\t\t// Set drop-down position above/below from required height and margins\n\t\t// If pre-layout cannot fit at least one option do not show drop-down\n\n\t\tthis.contextViewProvider.showContextView({\n\t\t\tgetAnchor: () => this.selectElement,\n\t\t\trender: (container: HTMLElement) => this.renderSelectDropDown(container, true),\n\t\t\tlayout: () => {\n\t\t\t\tthis.layoutSelectDropDown();\n\t\t\t},\n\t\t\tonHide: () => {\n\t\t\t\tdom.toggleClass(this.selectDropDownContainer, 'visible', false);\n\t\t\t\tdom.toggleClass(this.selectElement, 'synthetic-focus', false);\n\t\t\t},\n\t\t\tanchorPosition: this._dropDownPosition\n\t\t});\n\n\t\t// Hide so we can relay out\n\t\tthis._isVisible = true;\n\t\tthis.hideSelectDropDown(false);\n\n\t\tthis.contextViewProvider.showContextView({\n\t\t\tgetAnchor: () => this.selectElement,\n\t\t\trender: (container: HTMLElement) => this.renderSelectDropDown(container),\n\t\t\tlayout: () => this.layoutSelectDropDown(),\n\t\t\tonHide: () => {\n\t\t\t\tdom.toggleClass(this.selectDropDownContainer, 'visible', false);\n\t\t\t\tdom.toggleClass(this.selectElement, 'synthetic-focus', false);\n\t\t\t},\n\t\t\tanchorPosition: this._dropDownPosition\n\t\t});\n\n\t\t// Track initial selection the case user escape, blur\n\t\tthis._currentSelection = this.selected;\n\t\tthis._isVisible = true;\n\t}\n\n\tprivate hideSelectDropDown(focusSelect: boolean) {\n\t\tif (!this.contextViewProvider || !this._isVisible) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._isVisible = false;\n\n\t\tif (focusSelect) {\n\t\t\tthis.selectElement.focus();\n\t\t}\n\n\t\tthis.contextViewProvider.hideContextView();\n\t}\n\n\tprivate renderSelectDropDown(container: HTMLElement, preLayoutPosition?: boolean): IDisposable {\n\t\tcontainer.appendChild(this.selectDropDownContainer);\n\n\t\t// Pre-Layout allows us to change position\n\t\tthis.layoutSelectDropDown(preLayoutPosition);\n\n\t\treturn {\n\t\t\tdispose: () => {\n\t\t\t\t// contextView will dispose itself if moving from one View to another\n\t\t\t\ttry {\n\t\t\t\t\tcontainer.removeChild(this.selectDropDownContainer); // remove to take out the CSS rules we add\n\t\t\t\t}\n\t\t\t\tcatch (error) {\n\t\t\t\t\t// Ignore, removed already by change of focus\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t// Iterate over detailed descriptions, find max height\n\tprivate measureMaxDetailsHeight(): number {\n\n\t\tif (!this.detailsProvider) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tlet maxDetailsPaneHeight = 0;\n\t\tlet description = { details: '', isMarkdown: false };\n\n\t\tthis.options.forEach((option, index) => {\n\n\t\t\tthis.selectionDetailsPane.innerText = '';\n\n\t\t\tdescription = this.detailsProvider ? this.detailsProvider(index) : { details: '', isMarkdown: false };\n\t\t\tif (description.details) {\n\t\t\t\tif (description.isMarkdown) {\n\t\t\t\t\tthis.selectionDetailsPane.appendChild(this.renderDescriptionMarkdown(description.details));\n\t\t\t\t} else {\n\t\t\t\t\tthis.selectionDetailsPane.innerText = description.details;\n\t\t\t\t}\n\t\t\t\tthis.selectionDetailsPane.style.display = 'block';\n\t\t\t} else {\n\t\t\t\tthis.selectionDetailsPane.style.display = 'none';\n\t\t\t}\n\n\t\t\tif (this.selectionDetailsPane.offsetHeight > maxDetailsPaneHeight) {\n\t\t\t\tmaxDetailsPaneHeight = this.selectionDetailsPane.offsetHeight;\n\t\t\t}\n\t\t});\n\n\t\t// Reset description to selected\n\t\tdescription = this.detailsProvider ? this.detailsProvider(this.selected) : { details: '', isMarkdown: false };\n\t\tthis.selectionDetailsPane.innerText = '';\n\n\t\tif (description.details) {\n\t\t\tif (description.isMarkdown) {\n\t\t\t\tthis.selectionDetailsPane.appendChild(this.renderDescriptionMarkdown(description.details));\n\t\t\t} else {\n\t\t\t\tthis.selectionDetailsPane.innerText = description.details;\n\t\t\t}\n\t\t\tthis.selectionDetailsPane.style.display = 'block';\n\t\t}\n\n\t\treturn maxDetailsPaneHeight;\n\t}\n\n\tprivate layoutSelectDropDown(preLayoutPosition?: boolean): boolean {\n\n\t\t// Avoid recursion from layout called in onListFocus\n\t\tif (this._skipLayout) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Layout ContextView drop down select list and container\n\t\t// Have to manage our vertical overflow, sizing, position below or above\n\t\t// Position has to be determined and set prior to contextView instantiation\n\n\t\tif (this.selectList) {\n\n\t\t\t// Make visible to enable measurements\n\t\t\tdom.toggleClass(this.selectDropDownContainer, 'visible', true);\n\n\t\t\tconst selectPosition = dom.getDomNodePagePosition(this.selectElement);\n\t\t\tconst styles = getComputedStyle(this.selectElement);\n\t\t\tconst verticalPadding = parseFloat(styles.getPropertyValue('--dropdown-padding-top')) + parseFloat(styles.getPropertyValue('--dropdown-padding-bottom'));\n\t\t\tconst maxSelectDropDownHeightBelow = (window.innerHeight - selectPosition.top - selectPosition.height - this.selectBoxOptions.minBottomMargin);\n\t\t\tconst maxSelectDropDownHeightAbove = (selectPosition.top - SelectBoxList.DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN);\n\n\t\t\t// Determine optimal width - min(longest option), opt(parent select, excluding margins), max(ContextView controlled)\n\t\t\tconst selectWidth = this.selectElement.offsetWidth;\n\t\t\tconst selectMinWidth = this.setWidthControlElement(this.widthControlElement);\n\t\t\tconst selectOptimalWidth = Math.max(selectMinWidth, Math.round(selectWidth)).toString() + 'px';\n\n\t\t\tthis.selectDropDownContainer.style.width = selectOptimalWidth;\n\n\t\t\t// Get initial list height and determine space ab1you knowove and below\n\t\t\tthis.selectList.layout();\n\t\t\tlet listHeight = this.selectList.contentHeight;\n\n\t\t\tconst maxDetailsPaneHeight = this.measureMaxDetailsHeight();\n\n\t\t\tconst minRequiredDropDownHeight = listHeight + verticalPadding + maxDetailsPaneHeight;\n\t\t\tconst maxVisibleOptionsBelow = ((Math.floor((maxSelectDropDownHeightBelow - verticalPadding - maxDetailsPaneHeight) / this.getHeight())));\n\t\t\tconst maxVisibleOptionsAbove = ((Math.floor((maxSelectDropDownHeightAbove - verticalPadding - maxDetailsPaneHeight) / this.getHeight())));\n\n\t\t\t// If we are only doing pre-layout check/adjust position only\n\t\t\t// Calculate vertical space available, flip up if insufficient\n\t\t\t// Use reflected padding on parent select, ContextView style\n\t\t\t// properties not available before DOM attachment\n\n\t\t\tif (preLayoutPosition) {\n\n\t\t\t\t// Check if select moved out of viewport , do not open\n\t\t\t\t// If at least one option cannot be shown, don't open the drop-down or hide/remove if open\n\n\t\t\t\tif ((selectPosition.top + selectPosition.height) > (window.innerHeight - 22)\n\t\t\t\t\t|| selectPosition.top < SelectBoxList.DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN\n\t\t\t\t\t|| ((maxVisibleOptionsBelow < 1) && (maxVisibleOptionsAbove < 1))) {\n\t\t\t\t\t// Indicate we cannot open\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Determine if we have to flip up\n\t\t\t\t// Always show complete list items - never more than Max available vertical height\n\t\t\t\tif (maxVisibleOptionsBelow < SelectBoxList.DEFAULT_MINIMUM_VISIBLE_OPTIONS\n\t\t\t\t\t&& maxVisibleOptionsAbove > maxVisibleOptionsBelow\n\t\t\t\t\t&& this.options.length > maxVisibleOptionsBelow\n\t\t\t\t) {\n\t\t\t\t\tthis._dropDownPosition = AnchorPosition.ABOVE;\n\t\t\t\t\tthis.selectDropDownContainer.removeChild(this.selectDropDownListContainer);\n\t\t\t\t\tthis.selectDropDownContainer.removeChild(this.selectionDetailsPane);\n\t\t\t\t\tthis.selectDropDownContainer.appendChild(this.selectionDetailsPane);\n\t\t\t\t\tthis.selectDropDownContainer.appendChild(this.selectDropDownListContainer);\n\n\t\t\t\t\tdom.removeClass(this.selectionDetailsPane, 'border-top');\n\t\t\t\t\tdom.addClass(this.selectionDetailsPane, 'border-bottom');\n\n\t\t\t\t} else {\n\t\t\t\t\tthis._dropDownPosition = AnchorPosition.BELOW;\n\t\t\t\t\tthis.selectDropDownContainer.removeChild(this.selectDropDownListContainer);\n\t\t\t\t\tthis.selectDropDownContainer.removeChild(this.selectionDetailsPane);\n\t\t\t\t\tthis.selectDropDownContainer.appendChild(this.selectDropDownListContainer);\n\t\t\t\t\tthis.selectDropDownContainer.appendChild(this.selectionDetailsPane);\n\n\t\t\t\t\tdom.removeClass(this.selectionDetailsPane, 'border-bottom');\n\t\t\t\t\tdom.addClass(this.selectionDetailsPane, 'border-top');\n\t\t\t\t}\n\t\t\t\t// Do full layout on showSelectDropDown only\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// Check if select out of viewport or cutting into status bar\n\t\t\tif ((selectPosition.top + selectPosition.height) > (window.innerHeight - 22)\n\t\t\t\t|| selectPosition.top < SelectBoxList.DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN\n\t\t\t\t|| (this._dropDownPosition === AnchorPosition.BELOW && maxVisibleOptionsBelow < 1)\n\t\t\t\t|| (this._dropDownPosition === AnchorPosition.ABOVE && maxVisibleOptionsAbove < 1)) {\n\t\t\t\t// Cannot properly layout, close and hide\n\t\t\t\tthis.hideSelectDropDown(true);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// SetUp list dimensions and layout - account for container padding\n\t\t\t// Use position to check above or below available space\n\t\t\tif (this._dropDownPosition === AnchorPosition.BELOW) {\n\t\t\t\tif (this._isVisible && maxVisibleOptionsBelow + maxVisibleOptionsAbove < 1) {\n\t\t\t\t\t// If drop-down is visible, must be doing a DOM re-layout, hide since we don't fit\n\t\t\t\t\t// Hide drop-down, hide contextview, focus on parent select\n\t\t\t\t\tthis.hideSelectDropDown(true);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Adjust list height to max from select bottom to margin (default/minBottomMargin)\n\t\t\t\tif (minRequiredDropDownHeight > maxSelectDropDownHeightBelow) {\n\t\t\t\t\tlistHeight = (maxVisibleOptionsBelow * this.getHeight());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (minRequiredDropDownHeight > maxSelectDropDownHeightAbove) {\n\t\t\t\t\tlistHeight = (maxVisibleOptionsAbove * this.getHeight());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set adjusted list height and relayout\n\t\t\tthis.selectList.layout(listHeight);\n\t\t\tthis.selectList.domFocus();\n\n\t\t\t// Finally set focus on selected item\n\t\t\tif (this.selectList.length > 0) {\n\t\t\t\tthis.selectList.setFocus([this.selected || 0]);\n\t\t\t\tthis.selectList.reveal(this.selectList.getFocus()[0] || 0);\n\t\t\t}\n\n\t\t\tif (this.detailsProvider) {\n\t\t\t\t// Leave the selectDropDownContainer to size itself according to children (list + details) - #57447\n\t\t\t\tthis.selectList.getHTMLElement().style.height = (listHeight + verticalPadding) + 'px';\n\t\t\t} else {\n\t\t\t\tthis.selectDropDownContainer.style.height = (listHeight + verticalPadding) + 'px';\n\t\t\t}\n\n\t\t\tthis.selectDropDownContainer.style.width = selectOptimalWidth;\n\n\t\t\t// Maintain focus outline on parent select as well as list container - tabindex for focus\n\t\t\tthis.selectDropDownListContainer.setAttribute('tabindex', '0');\n\t\t\tdom.toggleClass(this.selectElement, 'synthetic-focus', true);\n\t\t\tdom.toggleClass(this.selectDropDownContainer, 'synthetic-focus', true);\n\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate setWidthControlElement(container: HTMLElement): number {\n\t\tlet elementWidth = 0;\n\n\t\tif (container && !!this.options) {\n\t\t\tlet longest = 0;\n\n\t\t\tfor (let index = 0; index < this.options.length; index++) {\n\t\t\t\tif (this.options[index].length > this.options[longest].length) {\n\t\t\t\t\tlongest = index;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcontainer.innerHTML = this.options[longest];\n\t\t\telementWidth = dom.getTotalWidth(container);\n\t\t}\n\n\t\treturn elementWidth;\n\t}\n\n\tprivate cloneElementFont(source: HTMLElement, target: HTMLElement) {\n\t\tconst fontSize = window.getComputedStyle(source, null).getPropertyValue('font-size');\n\t\tconst fontFamily = window.getComputedStyle(source, null).getPropertyValue('font-family');\n\t\ttarget.style.fontFamily = fontFamily;\n\t\ttarget.style.fontSize = fontSize;\n\t}\n\n\tprivate createSelectList(parent: HTMLElement): void {\n\n\t\t// If we have already constructive list on open, skip\n\t\tif (this.selectList) {\n\t\t\treturn;\n\t\t}\n\n\t\t// SetUp container for list\n\t\tthis.selectDropDownListContainer = dom.append(parent, $('.select-box-dropdown-list-container'));\n\n\t\tthis.listRenderer = new SelectListRenderer();\n\n\t\tthis.selectList = new List(this.selectDropDownListContainer, this, [this.listRenderer], {\n\t\t\tariaLabel: this.selectBoxOptions.ariaLabel,\n\t\t\tuseShadows: false,\n\t\t\tselectOnMouseDown: false,\n\t\t\tverticalScrollMode: ScrollbarVisibility.Visible,\n\t\t\tkeyboardSupport: false,\n\t\t\tmouseSupport: false\n\t\t});\n\n\t\t// SetUp list keyboard controller - control navigation, disabled items, focus\n\t\tconst onSelectDropDownKeyDown = chain(domEvent(this.selectDropDownListContainer, 'keydown'))\n\t\t\t.filter(() => this.selectList.length > 0)\n\t\t\t.map(e => new StandardKeyboardEvent(e));\n\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.Enter).on(e => this.onEnter(e), this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.Escape).on(e => this.onEscape(e), this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.UpArrow).on(this.onUpArrow, this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.DownArrow).on(this.onDownArrow, this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.PageDown).on(this.onPageDown, this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.PageUp).on(this.onPageUp, this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.Home).on(this.onHome, this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.End).on(this.onEnd, this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => (e.keyCode >= KeyCode.KEY_0 && e.keyCode <= KeyCode.KEY_Z) || (e.keyCode >= KeyCode.US_SEMICOLON && e.keyCode <= KeyCode.NUMPAD_DIVIDE)).on(this.onCharacter, this, this.toDispose);\n\n\t\t// SetUp list mouse controller - control navigation, disabled items, focus\n\n\t\tchain(domEvent(this.selectList.getHTMLElement(), 'mouseup'))\n\t\t\t.filter(() => this.selectList.length > 0)\n\t\t\t.on(e => this.onMouseUp(e), this, this.toDispose);\n\n\t\tthis.toDispose.push(\n\t\t\tthis.selectList.onDidBlur(e => this.onListBlur()),\n\t\t\tthis.selectList.onMouseOver(e => this.selectList.setFocus([e.index])),\n\t\t\tthis.selectList.onFocusChange(e => this.onListFocus(e))\n\t\t);\n\n\t\tthis.selectList.getHTMLElement().setAttribute('aria-label', this.selectBoxOptions.ariaLabel);\n\t\tthis.selectList.getHTMLElement().setAttribute('aria-expanded', 'true');\n\n\t\tthis.styleList();\n\t}\n\n\t// List methods\n\n\t// List mouse controller - active exit, select option, fire onDidSelect if change, return focus to parent select\n\tprivate onMouseUp(e: MouseEvent): void {\n\n\t\tdom.EventHelper.stop(e);\n\n\t\t// Check our mouse event is on an option (not scrollbar)\n\t\tif (!e.toElement.classList.contains('option-text')) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst listRowElement = e.toElement.parentElement;\n\t\tconst index = Number(listRowElement.getAttribute('data-index'));\n\t\tconst disabled = listRowElement.classList.contains('option-disabled');\n\n\t\t// Ignore mouse selection of disabled options\n\t\tif (index >= 0 && index < this.options.length && !disabled) {\n\t\t\tthis.selected = index;\n\t\t\tthis.select(this.selected);\n\n\t\t\tthis.selectList.setFocus([this.selected]);\n\t\t\tthis.selectList.reveal(this.selectList.getFocus()[0]);\n\n\t\t\t// Only fire if selection change\n\t\t\tif (this.selected !== this._currentSelection) {\n\t\t\t\t// Set current = selected\n\t\t\t\tthis._currentSelection = this.selected;\n\n\t\t\t\tthis._onDidSelect.fire({\n\t\t\t\t\tindex: this.selectElement.selectedIndex,\n\t\t\t\t\tselected: this.selectElement.title\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthis.hideSelectDropDown(true);\n\t\t}\n\t}\n\n\t// List Exit - passive - implicit no selection change, hide drop-down\n\tprivate onListBlur(): void {\n\t\tif (this._sticky) { return; }\n\t\tif (this.selected !== this._currentSelection) {\n\t\t\t// Reset selected to current if no change\n\t\t\tthis.select(this._currentSelection);\n\t\t}\n\n\t\tthis.hideSelectDropDown(false);\n\t}\n\n\n\tprivate renderDescriptionMarkdown(text: string): HTMLElement {\n\t\tconst cleanRenderedMarkdown = (element: Node) => {\n\t\t\tfor (let i = 0; i < element.childNodes.length; i++) {\n\t\t\t\tconst child = element.childNodes.item(i);\n\n\t\t\t\tconst tagName = (<Element>child).tagName && (<Element>child).tagName.toLowerCase();\n\t\t\t\tif (tagName === 'img') {\n\t\t\t\t\telement.removeChild(child);\n\t\t\t\t} else {\n\t\t\t\t\tcleanRenderedMarkdown(child);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tconst renderedMarkdown = renderMarkdown({ value: text }, {\n\t\t\tactionHandler: this.selectBoxOptions.markdownActionHandler\n\t\t});\n\n\t\trenderedMarkdown.classList.add('select-box-description-markdown');\n\t\tcleanRenderedMarkdown(renderedMarkdown);\n\n\t\treturn renderedMarkdown;\n\t}\n\n\t// List Focus Change - passive - update details pane with newly focused element's data\n\tprivate onListFocus(e: IListEvent<ISelectOptionItem>) {\n\t\t// Skip during initial layout\n\t\tif (!this._isVisible) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.selectionDetailsPane.innerText = '';\n\t\tconst selectedIndex = e.indexes[0];\n\t\tlet description = this.detailsProvider ? this.detailsProvider(selectedIndex) : { details: '', isMarkdown: false };\n\t\tif (description.details) {\n\t\t\tif (description.isMarkdown) {\n\t\t\t\tthis.selectionDetailsPane.appendChild(this.renderDescriptionMarkdown(description.details));\n\t\t\t} else {\n\t\t\t\tthis.selectionDetailsPane.innerText = description.details;\n\t\t\t}\n\t\t\tthis.selectionDetailsPane.style.display = 'block';\n\t\t} else {\n\t\t\tthis.selectionDetailsPane.style.display = 'none';\n\t\t}\n\n\t\t// Avoid recursion\n\t\tthis._skipLayout = true;\n\t\tthis.contextViewProvider.layout();\n\t\tthis._skipLayout = false;\n\n\t}\n\n\t// List keyboard controller\n\n\t// List exit - active - hide ContextView dropdown, reset selection, return focus to parent select\n\tprivate onEscape(e: StandardKeyboardEvent): void {\n\t\tdom.EventHelper.stop(e);\n\n\t\t// Reset selection to value when opened\n\t\tthis.select(this._currentSelection);\n\t\tthis.hideSelectDropDown(true);\n\t}\n\n\t// List exit - active - hide ContextView dropdown, return focus to parent select, fire onDidSelect if change\n\tprivate onEnter(e: StandardKeyboardEvent): void {\n\t\tdom.EventHelper.stop(e);\n\n\t\t// Only fire if selection change\n\t\tif (this.selected !== this._currentSelection) {\n\t\t\tthis._currentSelection = this.selected;\n\t\t\tthis._onDidSelect.fire({\n\t\t\t\tindex: this.selectElement.selectedIndex,\n\t\t\t\tselected: this.selectElement.title\n\t\t\t});\n\t\t}\n\n\t\tthis.hideSelectDropDown(true);\n\t}\n\n\t// List navigation - have to handle a disabled option (jump over)\n\tprivate onDownArrow(): void {\n\t\tif (this.selected < this.options.length - 1) {\n\t\t\t// Skip disabled options\n\t\t\tif ((this.selected + 1) === this.disabledOptionIndex && this.options.length > this.selected + 2) {\n\t\t\t\tthis.selected += 2;\n\t\t\t} else {\n\t\t\t\tthis.selected++;\n\t\t\t}\n\t\t\t// Set focus/selection - only fire event when closing drop-down or on blur\n\t\t\tthis.select(this.selected);\n\t\t\tthis.selectList.setFocus([this.selected]);\n\t\t\tthis.selectList.reveal(this.selectList.getFocus()[0]);\n\t\t}\n\t}\n\n\tprivate onUpArrow(): void {\n\t\tif (this.selected > 0) {\n\t\t\t// Skip disabled options\n\t\t\tif ((this.selected - 1) === this.disabledOptionIndex && this.selected > 1) {\n\t\t\t\tthis.selected -= 2;\n\t\t\t} else {\n\t\t\t\tthis.selected--;\n\t\t\t}\n\t\t\t// Set focus/selection - only fire event when closing drop-down or on blur\n\t\t\tthis.select(this.selected);\n\t\t\tthis.selectList.setFocus([this.selected]);\n\t\t\tthis.selectList.reveal(this.selectList.getFocus()[0]);\n\t\t}\n\t}\n\n\tprivate onPageUp(e: StandardKeyboardEvent): void {\n\t\tdom.EventHelper.stop(e);\n\n\t\tthis.selectList.focusPreviousPage();\n\n\t\t// Allow scrolling to settle\n\t\tsetTimeout(() => {\n\t\t\tthis.selected = this.selectList.getFocus()[0];\n\n\t\t\t// Shift selection down if we land on a disabled option\n\t\t\tif (this.selected === this.disabledOptionIndex && this.selected < this.options.length - 1) {\n\t\t\t\tthis.selected++;\n\t\t\t\tthis.selectList.setFocus([this.selected]);\n\t\t\t}\n\t\t\tthis.selectList.reveal(this.selected);\n\t\t\tthis.select(this.selected);\n\t\t}, 1);\n\t}\n\n\tprivate onPageDown(e: StandardKeyboardEvent): void {\n\t\tdom.EventHelper.stop(e);\n\n\t\tthis.selectList.focusNextPage();\n\n\t\t// Allow scrolling to settle\n\t\tsetTimeout(() => {\n\t\t\tthis.selected = this.selectList.getFocus()[0];\n\n\t\t\t// Shift selection up if we land on a disabled option\n\t\t\tif (this.selected === this.disabledOptionIndex && this.selected > 0) {\n\t\t\t\tthis.selected--;\n\t\t\t\tthis.selectList.setFocus([this.selected]);\n\t\t\t}\n\t\t\tthis.selectList.reveal(this.selected);\n\t\t\tthis.select(this.selected);\n\t\t}, 1);\n\t}\n\n\tprivate onHome(e: StandardKeyboardEvent): void {\n\t\tdom.EventHelper.stop(e);\n\n\t\tif (this.options.length < 2) {\n\t\t\treturn;\n\t\t}\n\t\tthis.selected = 0;\n\t\tif (this.selected === this.disabledOptionIndex && this.selected > 1) {\n\t\t\tthis.selected++;\n\t\t}\n\t\tthis.selectList.setFocus([this.selected]);\n\t\tthis.selectList.reveal(this.selected);\n\t\tthis.select(this.selected);\n\t}\n\n\tprivate onEnd(e: StandardKeyboardEvent): void {\n\t\tdom.EventHelper.stop(e);\n\n\t\tif (this.options.length < 2) {\n\t\t\treturn;\n\t\t}\n\t\tthis.selected = this.options.length - 1;\n\t\tif (this.selected === this.disabledOptionIndex && this.selected > 1) {\n\t\t\tthis.selected--;\n\t\t}\n\t\tthis.selectList.setFocus([this.selected]);\n\t\tthis.selectList.reveal(this.selected);\n\t\tthis.select(this.selected);\n\t}\n\n\t// Mimic option first character navigation of native select\n\tprivate onCharacter(e: StandardKeyboardEvent): void {\n\t\tconst ch = KeyCodeUtils.toString(e.keyCode);\n\t\tlet optionIndex = -1;\n\n\t\tfor (let i = 0; i < this.options.length - 1; i++) {\n\t\t\toptionIndex = (i + this.selected + 1) % this.options.length;\n\t\t\tif (this.options[optionIndex].charAt(0).toUpperCase() === ch) {\n\t\t\t\tthis.select(optionIndex);\n\t\t\t\tthis.selectList.setFocus([optionIndex]);\n\t\t\t\tthis.selectList.reveal(this.selectList.getFocus()[0]);\n\t\t\t\tdom.EventHelper.stop(e);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic dispose(): void {\n\t\tthis.hideSelectDropDown(false);\n\t\tthis.toDispose = dispose(this.toDispose);\n\t}\n}\n",
            "linguagem": "ts",
            "total_linhas": 1046
        },
        "solucao_humana": {
            "patch_diff": "@@ -150,7 +150,6 @@ export class SelectBoxList implements ISelectBoxDelegate, IVirtualDelegate<ISele\n \n \t\tthis.selected = selected || 0;\n \n-\t\t// CDL check\n \t\tif (options) {\n \t\t\tthis.setOptions(options, selected);\n \t\t}\n@@ -260,13 +259,19 @@ export class SelectBoxList implements ISelectBoxDelegate, IVirtualDelegate<ISele\n \t\t\tthis.options.forEach((option) => {\n \t\t\t\tthis.selectElement.add(this.createOption(option, i, disabled === i++));\n \t\t\t});\n-\t\t}\n \n-\t\tif (selected !== undefined) {\n-\t\t\tthis.select(selected);\n-\t\t\t// Set current = selected since this is not necessarily a user exit\n-\t\t\tthis._currentSelection = this.selected;\n+\t\t\tif (selected !== undefined) {\n+\t\t\t\tthis.select(selected);\n+\t\t\t\t// Set current = selected since this is not necessarily a user exit\n+\t\t\t\tthis._currentSelection = this.selected;\n+\t\t\t}\n+\n+\t\t\tif (disabled !== undefined) {\n+\t\t\t\tthis.disabledOptionIndex = disabled;\n+\t\t\t}\n \t\t}\n+\n+\n \t}\n \n \n@@ -928,6 +933,8 @@ export class SelectBoxList implements ISelectBoxDelegate, IVirtualDelegate<ISele\n \t\t\t// Skip disabled options\n \t\t\tif ((this.selected + 1) === this.disabledOptionIndex && this.options.length > this.selected + 2) {\n \t\t\t\tthis.selected += 2;\n+\t\t\t} else if ((this.selected + 1) === this.disabledOptionIndex) {\n+\t\t\t\treturn;\n \t\t\t} else {\n \t\t\t\tthis.selected++;\n \t\t\t}",
            "apenas_linhas_adicionadas": [
                "\t\t\tif (selected !== undefined) {",
                "\t\t\t\tthis.select(selected);",
                "\t\t\t\t// Set current = selected since this is not necessarily a user exit",
                "\t\t\t\tthis._currentSelection = this.selected;",
                "\t\t\t}",
                "",
                "\t\t\tif (disabled !== undefined) {",
                "\t\t\t\tthis.disabledOptionIndex = disabled;",
                "\t\t\t}",
                "",
                "",
                "\t\t\t} else if ((this.selected + 1) === this.disabledOptionIndex) {",
                "\t\t\t\treturn;"
            ]
        }
    },
    {
        "id": 61412,
        "url": "https://github.com/microsoft/vscode/pull/61412",
        "arquivo_caminho": "src/vs/base/browser/ui/selectBox/selectBoxCustom.ts",
        "descricao_bug": "- Electron 2.x incorrectly exposes select as role=menuItem \r\n- Screen readers do not read aria-label\r\n- Remove \"title\" attribute on select , avoids duplicate reading\r\n\r\n- Explicit role should not be required under Electron 3",
        "contexto": {
            "codigo_completo_bugado": "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport 'vs/css!./selectBoxCustom';\n\nimport { IDisposable, dispose } from 'vs/base/common/lifecycle';\nimport { Event, Emitter, chain } from 'vs/base/common/event';\nimport { KeyCode, KeyCodeUtils } from 'vs/base/common/keyCodes';\nimport { StandardKeyboardEvent } from 'vs/base/browser/keyboardEvent';\nimport * as dom from 'vs/base/browser/dom';\nimport * as arrays from 'vs/base/common/arrays';\nimport { IContextViewProvider, AnchorPosition } from 'vs/base/browser/ui/contextview/contextview';\nimport { List } from 'vs/base/browser/ui/list/listWidget';\nimport { IListVirtualDelegate, IListRenderer, IListEvent } from 'vs/base/browser/ui/list/list';\nimport { domEvent } from 'vs/base/browser/event';\nimport { ScrollbarVisibility } from 'vs/base/common/scrollable';\nimport { ISelectBoxDelegate, ISelectBoxOptions, ISelectBoxStyles, ISelectData } from 'vs/base/browser/ui/selectBox/selectBox';\nimport { isMacintosh } from 'vs/base/common/platform';\nimport { renderMarkdown } from 'vs/base/browser/htmlContentRenderer';\n\nconst $ = dom.$;\n\nconst SELECT_OPTION_ENTRY_TEMPLATE_ID = 'selectOption.entry.template';\n\nexport interface ISelectOptionItem {\n\toptionText: string;\n\toptionDescriptionText?: string;\n\toptionDisabled: boolean;\n}\n\ninterface ISelectListTemplateData {\n\troot: HTMLElement;\n\toptionText: HTMLElement;\n\toptionDescriptionText: HTMLElement;\n\tdisposables: IDisposable[];\n}\n\nclass SelectListRenderer implements IListRenderer<ISelectOptionItem, ISelectListTemplateData> {\n\n\tget templateId(): string { return SELECT_OPTION_ENTRY_TEMPLATE_ID; }\n\n\tconstructor() { }\n\n\trenderTemplate(container: HTMLElement): any {\n\t\tconst data = <ISelectListTemplateData>Object.create(null);\n\t\tdata.disposables = [];\n\t\tdata.root = container;\n\t\tdata.optionText = dom.append(container, $('.option-text'));\n\t\tdata.optionDescriptionText = dom.append(container, $('.option-text-description'));\n\t\tdom.addClass(data.optionDescriptionText, 'visually-hidden');\n\n\t\treturn data;\n\t}\n\n\trenderElement(element: ISelectOptionItem, index: number, templateData: ISelectListTemplateData): void {\n\t\tconst data = <ISelectListTemplateData>templateData;\n\t\tconst optionText = (<ISelectOptionItem>element).optionText;\n\t\tconst optionDisabled = (<ISelectOptionItem>element).optionDisabled;\n\n\t\tdata.optionText.textContent = optionText;\n\n\t\tif (typeof element.optionDescriptionText === 'string') {\n\t\t\tconst optionDescriptionId = (optionText.replace(/ /g, '_').toLowerCase() + '_description_' + data.root.id);\n\t\t\tdata.optionText.setAttribute('aria-describedby', optionDescriptionId);\n\t\t\tdata.optionDescriptionText.id = optionDescriptionId;\n\t\t\tdata.optionDescriptionText.innerText = element.optionDescriptionText;\n\t\t}\n\n\t\t// pseudo-select disabled option\n\t\tif (optionDisabled) {\n\t\t\tdom.addClass((<HTMLElement>data.root), 'option-disabled');\n\t\t} else {\n\t\t\t// Make sure we do class removal from prior template rendering\n\t\t\tdom.removeClass((<HTMLElement>data.root), 'option-disabled');\n\t\t}\n\t}\n\n\tdisposeElement(): void {\n\t\t// noop\n\t}\n\n\tdisposeTemplate(templateData: ISelectListTemplateData): void {\n\t\ttemplateData.disposables = dispose(templateData.disposables);\n\t}\n}\n\nexport class SelectBoxList implements ISelectBoxDelegate, IListVirtualDelegate<ISelectOptionItem> {\n\n\tprivate static readonly DEFAULT_DROPDOWN_MINIMUM_BOTTOM_MARGIN = 32;\n\tprivate static readonly DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN = 2;\n\tprivate static readonly DEFAULT_MINIMUM_VISIBLE_OPTIONS = 3;\n\n\tprivate _isVisible: boolean;\n\tprivate selectBoxOptions: ISelectBoxOptions;\n\tprivate selectElement: HTMLSelectElement;\n\tprivate options: string[];\n\tprivate selected: number;\n\tprivate disabledOptionIndex: number;\n\tprivate readonly _onDidSelect: Emitter<ISelectData>;\n\tprivate toDispose: IDisposable[];\n\tprivate styles: ISelectBoxStyles;\n\tprivate listRenderer: SelectListRenderer;\n\tprivate contextViewProvider: IContextViewProvider;\n\tprivate selectDropDownContainer: HTMLElement;\n\tprivate styleElement: HTMLStyleElement;\n\tprivate selectList: List<ISelectOptionItem>;\n\tprivate selectDropDownListContainer: HTMLElement;\n\tprivate widthControlElement: HTMLElement;\n\tprivate _currentSelection: number;\n\tprivate _dropDownPosition: AnchorPosition;\n\tprivate detailsProvider: (index: number) => { details: string, isMarkdown: boolean };\n\tprivate selectionDetailsPane: HTMLElement;\n\tprivate _skipLayout: boolean = false;\n\n\tprivate _sticky: boolean = false; // for dev purposes only\n\n\tconstructor(options: string[], selected: number, contextViewProvider: IContextViewProvider, styles: ISelectBoxStyles, selectBoxOptions?: ISelectBoxOptions) {\n\n\t\tthis.toDispose = [];\n\t\tthis._isVisible = false;\n\t\tthis.selectBoxOptions = selectBoxOptions || Object.create(null);\n\n\t\tif (typeof this.selectBoxOptions.minBottomMargin !== 'number') {\n\t\t\tthis.selectBoxOptions.minBottomMargin = SelectBoxList.DEFAULT_DROPDOWN_MINIMUM_BOTTOM_MARGIN;\n\t\t} else if (this.selectBoxOptions.minBottomMargin < 0) {\n\t\t\tthis.selectBoxOptions.minBottomMargin = 0;\n\t\t}\n\n\t\tthis.selectElement = document.createElement('select');\n\t\t// Use custom CSS vars for padding calculation\n\t\tthis.selectElement.className = 'monaco-select-box monaco-select-box-dropdown-padding';\n\n\t\tif (typeof this.selectBoxOptions.ariaLabel === 'string') {\n\t\t\tthis.selectElement.setAttribute('aria-label', this.selectBoxOptions.ariaLabel);\n\t\t}\n\n\t\tthis._onDidSelect = new Emitter<ISelectData>();\n\t\tthis.toDispose.push(this._onDidSelect);\n\n\t\tthis.styles = styles;\n\n\t\tthis.registerListeners();\n\t\tthis.constructSelectDropDown(contextViewProvider);\n\n\t\tthis.selected = selected || 0;\n\n\t\tif (options) {\n\t\t\tthis.setOptions(options, selected);\n\t\t}\n\n\t}\n\n\t// IDelegate - List renderer\n\n\tgetHeight(): number {\n\t\treturn 18;\n\t}\n\n\tgetTemplateId(): string {\n\t\treturn SELECT_OPTION_ENTRY_TEMPLATE_ID;\n\t}\n\n\tprivate constructSelectDropDown(contextViewProvider: IContextViewProvider) {\n\n\t\t// SetUp ContextView container to hold select Dropdown\n\t\tthis.contextViewProvider = contextViewProvider;\n\t\tthis.selectDropDownContainer = dom.$('.monaco-select-box-dropdown-container');\n\t\t// Use custom CSS vars for padding calculation (shared with parent select)\n\t\tdom.addClass(this.selectDropDownContainer, 'monaco-select-box-dropdown-padding');\n\n\t\t// Setup container for select option details\n\t\tthis.selectionDetailsPane = dom.append(this.selectDropDownContainer, $('.select-box-details-pane'));\n\n\t\t// Create span flex box item/div we can measure and control\n\t\tlet widthControlOuterDiv = dom.append(this.selectDropDownContainer, $('.select-box-dropdown-container-width-control'));\n\t\tlet widthControlInnerDiv = dom.append(widthControlOuterDiv, $('.width-control-div'));\n\t\tthis.widthControlElement = document.createElement('span');\n\t\tthis.widthControlElement.className = 'option-text-width-control';\n\t\tdom.append(widthControlInnerDiv, this.widthControlElement);\n\n\t\t// Always default to below position\n\t\tthis._dropDownPosition = AnchorPosition.BELOW;\n\n\t\t// Inline stylesheet for themes\n\t\tthis.styleElement = dom.createStyleSheet(this.selectDropDownContainer);\n\t}\n\n\tprivate registerListeners() {\n\n\t\t// Parent native select keyboard listeners\n\n\t\tthis.toDispose.push(dom.addStandardDisposableListener(this.selectElement, 'change', (e) => {\n\t\t\tthis.selectElement.title = e.target.value;\n\t\t\tthis.selected = e.target.selectedIndex;\n\t\t\tthis._onDidSelect.fire({\n\t\t\t\tindex: e.target.selectedIndex,\n\t\t\t\tselected: e.target.value\n\t\t\t});\n\t\t}));\n\n\t\t// Have to implement both keyboard and mouse controllers to handle disabled options\n\t\t// Intercept mouse events to override normal select actions on parents\n\n\t\tthis.toDispose.push(dom.addDisposableListener(this.selectElement, dom.EventType.CLICK, (e) => {\n\t\t\tdom.EventHelper.stop(e);\n\n\t\t\tif (this._isVisible) {\n\t\t\t\tthis.hideSelectDropDown(true);\n\t\t\t} else {\n\t\t\t\tthis.showSelectDropDown();\n\t\t\t}\n\t\t}));\n\n\t\tthis.toDispose.push(dom.addDisposableListener(this.selectElement, dom.EventType.MOUSE_DOWN, (e) => {\n\t\t\tdom.EventHelper.stop(e);\n\t\t}));\n\n\t\t// Intercept keyboard handling\n\n\t\tthis.toDispose.push(dom.addDisposableListener(this.selectElement, dom.EventType.KEY_DOWN, (e: KeyboardEvent) => {\n\t\t\tconst event = new StandardKeyboardEvent(e);\n\t\t\tlet showDropDown = false;\n\n\t\t\t// Create and drop down select list on keyboard select\n\t\t\tif (isMacintosh) {\n\t\t\t\tif (event.keyCode === KeyCode.DownArrow || event.keyCode === KeyCode.UpArrow || event.keyCode === KeyCode.Space || event.keyCode === KeyCode.Enter) {\n\t\t\t\t\tshowDropDown = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (event.keyCode === KeyCode.DownArrow && event.altKey || event.keyCode === KeyCode.UpArrow && event.altKey || event.keyCode === KeyCode.Space || event.keyCode === KeyCode.Enter) {\n\t\t\t\t\tshowDropDown = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (showDropDown) {\n\t\t\t\tthis.showSelectDropDown();\n\t\t\t\tdom.EventHelper.stop(e);\n\t\t\t}\n\t\t}));\n\t}\n\n\tpublic get onDidSelect(): Event<ISelectData> {\n\t\treturn this._onDidSelect.event;\n\t}\n\n\tpublic setOptions(options: string[], selected?: number, disabled?: number): void {\n\t\tif (!this.options || !arrays.equals(this.options, options)) {\n\t\t\tthis.options = options;\n\t\t\tthis.selectElement.options.length = 0;\n\n\t\t\tlet i = 0;\n\t\t\tthis.options.forEach((option) => {\n\t\t\t\tthis.selectElement.add(this.createOption(option, i, disabled === i++));\n\t\t\t});\n\n\t\t\tif (disabled !== undefined) {\n\t\t\t\tthis.disabledOptionIndex = disabled;\n\t\t\t}\n\t\t}\n\n\t\tif (selected !== undefined) {\n\t\t\tthis.select(selected);\n\t\t\t// Set current = selected since this is not necessarily a user exit\n\t\t\tthis._currentSelection = this.selected;\n\t\t}\n\t}\n\n\n\tprivate setOptionsList() {\n\n\t\t// Mirror options in drop-down\n\t\t// Populate select list for non-native select mode\n\t\tif (this.selectList && !!this.options) {\n\t\t\tlet listEntries: ISelectOptionItem[];\n\t\t\tlistEntries = [];\n\n\t\t\tfor (let index = 0; index < this.options.length; index++) {\n\t\t\t\tconst element = this.options[index];\n\t\t\t\tlet optionDisabled: boolean;\n\t\t\t\tindex === this.disabledOptionIndex ? optionDisabled = true : optionDisabled = false;\n\t\t\t\tconst optionDescription = this.detailsProvider ? this.detailsProvider(index) : { details: null, isMarkdown: false };\n\n\t\t\t\tlistEntries.push({ optionText: element, optionDisabled: optionDisabled, optionDescriptionText: optionDescription.details });\n\t\t\t}\n\t\t\tthis.selectList.splice(0, this.selectList.length, listEntries);\n\t\t}\n\t}\n\n\tpublic select(index: number): void {\n\n\t\tif (index >= 0 && index < this.options.length) {\n\t\t\tthis.selected = index;\n\t\t} else if (index > this.options.length - 1) {\n\t\t\t// Adjust index to end of list\n\t\t\t// This could make client out of sync with the select\n\t\t\tthis.select(this.options.length - 1);\n\t\t} else if (this.selected < 0) {\n\t\t\tthis.selected = 0;\n\t\t}\n\n\t\tthis.selectElement.selectedIndex = this.selected;\n\t\tthis.selectElement.title = this.options[this.selected];\n\t}\n\n\tpublic setAriaLabel(label: string): void {\n\t\tthis.selectBoxOptions.ariaLabel = label;\n\t\tthis.selectElement.setAttribute('aria-label', this.selectBoxOptions.ariaLabel);\n\t}\n\n\tpublic setDetailsProvider(provider: (index: number) => { details: string, isMarkdown: boolean }): void {\n\t\tthis.detailsProvider = provider;\n\t}\n\n\tpublic focus(): void {\n\t\tif (this.selectElement) {\n\t\t\tthis.selectElement.focus();\n\t\t}\n\t}\n\n\tpublic blur(): void {\n\t\tif (this.selectElement) {\n\t\t\tthis.selectElement.blur();\n\t\t}\n\t}\n\n\tpublic render(container: HTMLElement): void {\n\t\tdom.addClass(container, 'select-container');\n\t\tcontainer.appendChild(this.selectElement);\n\t\tthis.applyStyles();\n\t}\n\n\tpublic style(styles: ISelectBoxStyles): void {\n\n\t\tconst content: string[] = [];\n\n\t\tthis.styles = styles;\n\n\t\t// Style non-native select mode\n\n\t\tif (this.styles.listFocusBackground) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.focused { background-color: ${this.styles.listFocusBackground} !important; }`);\n\t\t}\n\n\t\tif (this.styles.listFocusForeground) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.focused:not(:hover) { color: ${this.styles.listFocusForeground} !important; }`);\n\t\t}\n\n\t\tif (!this.styles.selectBorder.equals(this.styles.selectBackground)) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container { border: 1px solid ${this.styles.selectBorder} } `);\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-details-pane.border-top { border-top: 1px solid ${this.styles.selectBorder} } `);\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-details-pane.border-bottom { border-bottom: 1px solid ${this.styles.selectBorder} } `);\n\n\t\t}\n\t\telse if (this.styles.selectListBorder) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-details-pane.border-top { border-top: 1px solid ${this.styles.selectListBorder} } `);\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-details-pane.border-bottom { border-bottom: 1px solid ${this.styles.selectListBorder} } `);\n\t\t}\n\n\t\t// Hover foreground - ignore for disabled options\n\t\tif (this.styles.listHoverForeground) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:hover { color: ${this.styles.listHoverForeground} !important; }`);\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.option-disabled:hover { background-color: ${this.styles.listActiveSelectionForeground} !important; }`);\n\t\t}\n\n\t\t// Hover background - ignore for disabled options\n\t\tif (this.styles.listHoverBackground) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:not(.option-disabled):not(.focused):hover { background-color: ${this.styles.listHoverBackground} !important; }`);\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.option-disabled:hover { background-color: ${this.styles.selectBackground} !important; }`);\n\t\t}\n\n\t\t// Match quickOpen outline styles - ignore for disabled options\n\t\tif (this.styles.listFocusOutline) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.focused { outline: 1.6px dotted ${this.styles.listFocusOutline} !important; outline-offset: -1.6px !important; }`);\n\n\t\t}\n\n\t\tif (this.styles.listHoverOutline) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:hover:not(.focused) { outline: 1.6px dashed ${this.styles.listHoverOutline} !important; outline-offset: -1.6px !important; }`);\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.option-disabled:hover { outline: none !important; }`);\n\t\t}\n\n\t\tthis.styleElement.innerHTML = content.join('\\n');\n\n\t\tthis.applyStyles();\n\t}\n\n\tpublic applyStyles(): void {\n\n\t\t// Style parent select\n\n\t\tlet background = null;\n\n\t\tif (this.selectElement) {\n\t\t\tbackground = this.styles.selectBackground ? this.styles.selectBackground.toString() : null;\n\t\t\tconst foreground = this.styles.selectForeground ? this.styles.selectForeground.toString() : null;\n\t\t\tconst border = this.styles.selectBorder ? this.styles.selectBorder.toString() : null;\n\n\t\t\tthis.selectElement.style.backgroundColor = background;\n\t\t\tthis.selectElement.style.color = foreground;\n\t\t\tthis.selectElement.style.borderColor = border;\n\t\t}\n\n\t\t// Style drop down select list (non-native mode only)\n\n\t\tif (this.selectList) {\n\t\t\tthis.styleList();\n\t\t}\n\t}\n\n\tprivate styleList() {\n\n\t\tif (this.selectList) {\n\t\t\tlet background = null;\n\t\t\tbackground = this.styles.selectBackground ? this.styles.selectBackground.toString() : null;\n\t\t\tthis.selectList.style({});\n\n\t\t\tlet listBackground = this.styles.selectListBackground ? this.styles.selectListBackground.toString() : background;\n\t\t\tthis.selectDropDownListContainer.style.backgroundColor = listBackground;\n\t\t\tthis.selectionDetailsPane.style.backgroundColor = listBackground;\n\t\t\tconst optionsBorder = this.styles.focusBorder ? this.styles.focusBorder.toString() : null;\n\t\t\tthis.selectDropDownContainer.style.outlineColor = optionsBorder;\n\t\t\tthis.selectDropDownContainer.style.outlineOffset = '-1px';\n\t\t}\n\t}\n\n\tprivate createOption(value: string, index: number, disabled?: boolean): HTMLOptionElement {\n\t\tlet option = document.createElement('option');\n\t\toption.value = value;\n\t\toption.text = value;\n\t\toption.disabled = disabled;\n\n\t\treturn option;\n\t}\n\n\t// ContextView dropdown methods\n\n\tprivate showSelectDropDown() {\n\n\t\tif (!this.contextViewProvider || this._isVisible) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Lazily create and populate list only at open, moved from constructor\n\t\tthis.createSelectList(this.selectDropDownContainer);\n\t\tthis.setOptionsList();\n\n\t\tthis.cloneElementFont(this.selectElement, this.selectDropDownContainer);\n\n\t\t// This allows us to flip the position based on measurement\n\t\t// Set drop-down position above/below from required height and margins\n\t\t// If pre-layout cannot fit at least one option do not show drop-down\n\n\t\tthis.contextViewProvider.showContextView({\n\t\t\tgetAnchor: () => this.selectElement,\n\t\t\trender: (container: HTMLElement) => this.renderSelectDropDown(container, true),\n\t\t\tlayout: () => {\n\t\t\t\tthis.layoutSelectDropDown();\n\t\t\t},\n\t\t\tonHide: () => {\n\t\t\t\tdom.toggleClass(this.selectDropDownContainer, 'visible', false);\n\t\t\t\tdom.toggleClass(this.selectElement, 'synthetic-focus', false);\n\t\t\t},\n\t\t\tanchorPosition: this._dropDownPosition\n\t\t});\n\n\t\t// Hide so we can relay out\n\t\tthis._isVisible = true;\n\t\tthis.hideSelectDropDown(false);\n\n\t\tthis.contextViewProvider.showContextView({\n\t\t\tgetAnchor: () => this.selectElement,\n\t\t\trender: (container: HTMLElement) => this.renderSelectDropDown(container),\n\t\t\tlayout: () => this.layoutSelectDropDown(),\n\t\t\tonHide: () => {\n\t\t\t\tdom.toggleClass(this.selectDropDownContainer, 'visible', false);\n\t\t\t\tdom.toggleClass(this.selectElement, 'synthetic-focus', false);\n\t\t\t},\n\t\t\tanchorPosition: this._dropDownPosition\n\t\t});\n\n\t\t// Track initial selection the case user escape, blur\n\t\tthis._currentSelection = this.selected;\n\t\tthis._isVisible = true;\n\t}\n\n\tprivate hideSelectDropDown(focusSelect: boolean) {\n\t\tif (!this.contextViewProvider || !this._isVisible) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._isVisible = false;\n\n\t\tif (focusSelect) {\n\t\t\tthis.selectElement.focus();\n\t\t}\n\n\t\tthis.contextViewProvider.hideContextView();\n\t}\n\n\tprivate renderSelectDropDown(container: HTMLElement, preLayoutPosition?: boolean): IDisposable {\n\t\tcontainer.appendChild(this.selectDropDownContainer);\n\n\t\t// Pre-Layout allows us to change position\n\t\tthis.layoutSelectDropDown(preLayoutPosition);\n\n\t\treturn {\n\t\t\tdispose: () => {\n\t\t\t\t// contextView will dispose itself if moving from one View to another\n\t\t\t\ttry {\n\t\t\t\t\tcontainer.removeChild(this.selectDropDownContainer); // remove to take out the CSS rules we add\n\t\t\t\t}\n\t\t\t\tcatch (error) {\n\t\t\t\t\t// Ignore, removed already by change of focus\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t// Iterate over detailed descriptions, find max height\n\tprivate measureMaxDetailsHeight(): number {\n\n\t\tif (!this.detailsProvider) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tlet maxDetailsPaneHeight = 0;\n\t\tlet description = { details: '', isMarkdown: false };\n\n\t\tthis.options.forEach((option, index) => {\n\n\t\t\tthis.selectionDetailsPane.innerText = '';\n\n\t\t\tdescription = this.detailsProvider ? this.detailsProvider(index) : { details: '', isMarkdown: false };\n\t\t\tif (description.details) {\n\t\t\t\tif (description.isMarkdown) {\n\t\t\t\t\tthis.selectionDetailsPane.appendChild(this.renderDescriptionMarkdown(description.details));\n\t\t\t\t} else {\n\t\t\t\t\tthis.selectionDetailsPane.innerText = description.details;\n\t\t\t\t}\n\t\t\t\tthis.selectionDetailsPane.style.display = 'block';\n\t\t\t} else {\n\t\t\t\tthis.selectionDetailsPane.style.display = 'none';\n\t\t\t}\n\n\t\t\tif (this.selectionDetailsPane.offsetHeight > maxDetailsPaneHeight) {\n\t\t\t\tmaxDetailsPaneHeight = this.selectionDetailsPane.offsetHeight;\n\t\t\t}\n\t\t});\n\n\t\t// Reset description to selected\n\t\tdescription = this.detailsProvider ? this.detailsProvider(this.selected) : { details: '', isMarkdown: false };\n\t\tthis.selectionDetailsPane.innerText = '';\n\n\t\tif (description.details) {\n\t\t\tif (description.isMarkdown) {\n\t\t\t\tthis.selectionDetailsPane.appendChild(this.renderDescriptionMarkdown(description.details));\n\t\t\t} else {\n\t\t\t\tthis.selectionDetailsPane.innerText = description.details;\n\t\t\t}\n\t\t\tthis.selectionDetailsPane.style.display = 'block';\n\t\t}\n\n\t\treturn maxDetailsPaneHeight;\n\t}\n\n\tprivate layoutSelectDropDown(preLayoutPosition?: boolean): boolean {\n\n\t\t// Avoid recursion from layout called in onListFocus\n\t\tif (this._skipLayout) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Layout ContextView drop down select list and container\n\t\t// Have to manage our vertical overflow, sizing, position below or above\n\t\t// Position has to be determined and set prior to contextView instantiation\n\n\t\tif (this.selectList) {\n\n\t\t\t// Make visible to enable measurements\n\t\t\tdom.toggleClass(this.selectDropDownContainer, 'visible', true);\n\n\t\t\tconst selectPosition = dom.getDomNodePagePosition(this.selectElement);\n\t\t\tconst styles = getComputedStyle(this.selectElement);\n\t\t\tconst verticalPadding = parseFloat(styles.getPropertyValue('--dropdown-padding-top')) + parseFloat(styles.getPropertyValue('--dropdown-padding-bottom'));\n\t\t\tconst maxSelectDropDownHeightBelow = (window.innerHeight - selectPosition.top - selectPosition.height - this.selectBoxOptions.minBottomMargin);\n\t\t\tconst maxSelectDropDownHeightAbove = (selectPosition.top - SelectBoxList.DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN);\n\n\t\t\t// Determine optimal width - min(longest option), opt(parent select, excluding margins), max(ContextView controlled)\n\t\t\tconst selectWidth = this.selectElement.offsetWidth;\n\t\t\tconst selectMinWidth = this.setWidthControlElement(this.widthControlElement);\n\t\t\tconst selectOptimalWidth = Math.max(selectMinWidth, Math.round(selectWidth)).toString() + 'px';\n\n\t\t\tthis.selectDropDownContainer.style.width = selectOptimalWidth;\n\n\t\t\t// Get initial list height and determine space ab1you knowove and below\n\t\t\tthis.selectList.layout();\n\t\t\tlet listHeight = this.selectList.contentHeight;\n\n\t\t\tconst maxDetailsPaneHeight = this.measureMaxDetailsHeight();\n\n\t\t\tconst minRequiredDropDownHeight = listHeight + verticalPadding + maxDetailsPaneHeight;\n\t\t\tconst maxVisibleOptionsBelow = ((Math.floor((maxSelectDropDownHeightBelow - verticalPadding - maxDetailsPaneHeight) / this.getHeight())));\n\t\t\tconst maxVisibleOptionsAbove = ((Math.floor((maxSelectDropDownHeightAbove - verticalPadding - maxDetailsPaneHeight) / this.getHeight())));\n\n\t\t\t// If we are only doing pre-layout check/adjust position only\n\t\t\t// Calculate vertical space available, flip up if insufficient\n\t\t\t// Use reflected padding on parent select, ContextView style\n\t\t\t// properties not available before DOM attachment\n\n\t\t\tif (preLayoutPosition) {\n\n\t\t\t\t// Check if select moved out of viewport , do not open\n\t\t\t\t// If at least one option cannot be shown, don't open the drop-down or hide/remove if open\n\n\t\t\t\tif ((selectPosition.top + selectPosition.height) > (window.innerHeight - 22)\n\t\t\t\t\t|| selectPosition.top < SelectBoxList.DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN\n\t\t\t\t\t|| ((maxVisibleOptionsBelow < 1) && (maxVisibleOptionsAbove < 1))) {\n\t\t\t\t\t// Indicate we cannot open\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Determine if we have to flip up\n\t\t\t\t// Always show complete list items - never more than Max available vertical height\n\t\t\t\tif (maxVisibleOptionsBelow < SelectBoxList.DEFAULT_MINIMUM_VISIBLE_OPTIONS\n\t\t\t\t\t&& maxVisibleOptionsAbove > maxVisibleOptionsBelow\n\t\t\t\t\t&& this.options.length > maxVisibleOptionsBelow\n\t\t\t\t) {\n\t\t\t\t\tthis._dropDownPosition = AnchorPosition.ABOVE;\n\t\t\t\t\tthis.selectDropDownContainer.removeChild(this.selectDropDownListContainer);\n\t\t\t\t\tthis.selectDropDownContainer.removeChild(this.selectionDetailsPane);\n\t\t\t\t\tthis.selectDropDownContainer.appendChild(this.selectionDetailsPane);\n\t\t\t\t\tthis.selectDropDownContainer.appendChild(this.selectDropDownListContainer);\n\n\t\t\t\t\tdom.removeClass(this.selectionDetailsPane, 'border-top');\n\t\t\t\t\tdom.addClass(this.selectionDetailsPane, 'border-bottom');\n\n\t\t\t\t} else {\n\t\t\t\t\tthis._dropDownPosition = AnchorPosition.BELOW;\n\t\t\t\t\tthis.selectDropDownContainer.removeChild(this.selectDropDownListContainer);\n\t\t\t\t\tthis.selectDropDownContainer.removeChild(this.selectionDetailsPane);\n\t\t\t\t\tthis.selectDropDownContainer.appendChild(this.selectDropDownListContainer);\n\t\t\t\t\tthis.selectDropDownContainer.appendChild(this.selectionDetailsPane);\n\n\t\t\t\t\tdom.removeClass(this.selectionDetailsPane, 'border-bottom');\n\t\t\t\t\tdom.addClass(this.selectionDetailsPane, 'border-top');\n\t\t\t\t}\n\t\t\t\t// Do full layout on showSelectDropDown only\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// Check if select out of viewport or cutting into status bar\n\t\t\tif ((selectPosition.top + selectPosition.height) > (window.innerHeight - 22)\n\t\t\t\t|| selectPosition.top < SelectBoxList.DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN\n\t\t\t\t|| (this._dropDownPosition === AnchorPosition.BELOW && maxVisibleOptionsBelow < 1)\n\t\t\t\t|| (this._dropDownPosition === AnchorPosition.ABOVE && maxVisibleOptionsAbove < 1)) {\n\t\t\t\t// Cannot properly layout, close and hide\n\t\t\t\tthis.hideSelectDropDown(true);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// SetUp list dimensions and layout - account for container padding\n\t\t\t// Use position to check above or below available space\n\t\t\tif (this._dropDownPosition === AnchorPosition.BELOW) {\n\t\t\t\tif (this._isVisible && maxVisibleOptionsBelow + maxVisibleOptionsAbove < 1) {\n\t\t\t\t\t// If drop-down is visible, must be doing a DOM re-layout, hide since we don't fit\n\t\t\t\t\t// Hide drop-down, hide contextview, focus on parent select\n\t\t\t\t\tthis.hideSelectDropDown(true);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Adjust list height to max from select bottom to margin (default/minBottomMargin)\n\t\t\t\tif (minRequiredDropDownHeight > maxSelectDropDownHeightBelow) {\n\t\t\t\t\tlistHeight = (maxVisibleOptionsBelow * this.getHeight());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (minRequiredDropDownHeight > maxSelectDropDownHeightAbove) {\n\t\t\t\t\tlistHeight = (maxVisibleOptionsAbove * this.getHeight());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set adjusted list height and relayout\n\t\t\tthis.selectList.layout(listHeight);\n\t\t\tthis.selectList.domFocus();\n\n\t\t\t// Finally set focus on selected item\n\t\t\tif (this.selectList.length > 0) {\n\t\t\t\tthis.selectList.setFocus([this.selected || 0]);\n\t\t\t\tthis.selectList.reveal(this.selectList.getFocus()[0] || 0);\n\t\t\t}\n\n\t\t\tif (this.detailsProvider) {\n\t\t\t\t// Leave the selectDropDownContainer to size itself according to children (list + details) - #57447\n\t\t\t\tthis.selectList.getHTMLElement().style.height = (listHeight + verticalPadding) + 'px';\n\t\t\t} else {\n\t\t\t\tthis.selectDropDownContainer.style.height = (listHeight + verticalPadding) + 'px';\n\t\t\t}\n\n\t\t\tthis.selectDropDownContainer.style.width = selectOptimalWidth;\n\n\t\t\t// Maintain focus outline on parent select as well as list container - tabindex for focus\n\t\t\tthis.selectDropDownListContainer.setAttribute('tabindex', '0');\n\t\t\tdom.toggleClass(this.selectElement, 'synthetic-focus', true);\n\t\t\tdom.toggleClass(this.selectDropDownContainer, 'synthetic-focus', true);\n\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate setWidthControlElement(container: HTMLElement): number {\n\t\tlet elementWidth = 0;\n\n\t\tif (container && !!this.options) {\n\t\t\tlet longest = 0;\n\n\t\t\tfor (let index = 0; index < this.options.length; index++) {\n\t\t\t\tif (this.options[index].length > this.options[longest].length) {\n\t\t\t\t\tlongest = index;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcontainer.innerHTML = this.options[longest];\n\t\t\telementWidth = dom.getTotalWidth(container);\n\t\t}\n\n\t\treturn elementWidth;\n\t}\n\n\tprivate cloneElementFont(source: HTMLElement, target: HTMLElement) {\n\t\tconst fontSize = window.getComputedStyle(source, null).getPropertyValue('font-size');\n\t\tconst fontFamily = window.getComputedStyle(source, null).getPropertyValue('font-family');\n\t\ttarget.style.fontFamily = fontFamily;\n\t\ttarget.style.fontSize = fontSize;\n\t}\n\n\tprivate createSelectList(parent: HTMLElement): void {\n\n\t\t// If we have already constructive list on open, skip\n\t\tif (this.selectList) {\n\t\t\treturn;\n\t\t}\n\n\t\t// SetUp container for list\n\t\tthis.selectDropDownListContainer = dom.append(parent, $('.select-box-dropdown-list-container'));\n\n\t\tthis.listRenderer = new SelectListRenderer();\n\n\t\tthis.selectList = new List(this.selectDropDownListContainer, this, [this.listRenderer], {\n\t\t\tariaLabel: this.selectBoxOptions.ariaLabel,\n\t\t\tuseShadows: false,\n\t\t\tselectOnMouseDown: false,\n\t\t\tverticalScrollMode: ScrollbarVisibility.Visible,\n\t\t\tkeyboardSupport: false,\n\t\t\tmouseSupport: false\n\t\t});\n\n\t\t// SetUp list keyboard controller - control navigation, disabled items, focus\n\t\tconst onSelectDropDownKeyDown = chain(domEvent(this.selectDropDownListContainer, 'keydown'))\n\t\t\t.filter(() => this.selectList.length > 0)\n\t\t\t.map(e => new StandardKeyboardEvent(e));\n\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.Enter).on(e => this.onEnter(e), this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.Escape).on(e => this.onEscape(e), this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.UpArrow).on(this.onUpArrow, this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.DownArrow).on(this.onDownArrow, this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.PageDown).on(this.onPageDown, this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.PageUp).on(this.onPageUp, this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.Home).on(this.onHome, this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.End).on(this.onEnd, this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => (e.keyCode >= KeyCode.KEY_0 && e.keyCode <= KeyCode.KEY_Z) || (e.keyCode >= KeyCode.US_SEMICOLON && e.keyCode <= KeyCode.NUMPAD_DIVIDE)).on(this.onCharacter, this, this.toDispose);\n\n\t\t// SetUp list mouse controller - control navigation, disabled items, focus\n\n\t\tchain(domEvent(this.selectList.getHTMLElement(), 'mouseup'))\n\t\t\t.filter(() => this.selectList.length > 0)\n\t\t\t.on(e => this.onMouseUp(e), this, this.toDispose);\n\n\t\tthis.toDispose.push(\n\t\t\tthis.selectList.onDidBlur(e => this.onListBlur()),\n\t\t\tthis.selectList.onMouseOver(e => this.selectList.setFocus([e.index])),\n\t\t\tthis.selectList.onFocusChange(e => this.onListFocus(e))\n\t\t);\n\n\t\tthis.selectList.getHTMLElement().setAttribute('aria-label', this.selectBoxOptions.ariaLabel);\n\t\tthis.selectList.getHTMLElement().setAttribute('aria-expanded', 'true');\n\n\t\tthis.styleList();\n\t}\n\n\t// List methods\n\n\t// List mouse controller - active exit, select option, fire onDidSelect if change, return focus to parent select\n\tprivate onMouseUp(e: MouseEvent): void {\n\n\t\tdom.EventHelper.stop(e);\n\n\t\t// Check our mouse event is on an option (not scrollbar)\n\t\tif (!e.toElement.classList.contains('option-text')) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst listRowElement = e.toElement.parentElement;\n\t\tconst index = Number(listRowElement.getAttribute('data-index'));\n\t\tconst disabled = listRowElement.classList.contains('option-disabled');\n\n\t\t// Ignore mouse selection of disabled options\n\t\tif (index >= 0 && index < this.options.length && !disabled) {\n\t\t\tthis.selected = index;\n\t\t\tthis.select(this.selected);\n\n\t\t\tthis.selectList.setFocus([this.selected]);\n\t\t\tthis.selectList.reveal(this.selectList.getFocus()[0]);\n\n\t\t\t// Only fire if selection change\n\t\t\tif (this.selected !== this._currentSelection) {\n\t\t\t\t// Set current = selected\n\t\t\t\tthis._currentSelection = this.selected;\n\n\t\t\t\tthis._onDidSelect.fire({\n\t\t\t\t\tindex: this.selectElement.selectedIndex,\n\t\t\t\t\tselected: this.selectElement.title\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthis.hideSelectDropDown(true);\n\t\t}\n\t}\n\n\t// List Exit - passive - implicit no selection change, hide drop-down\n\tprivate onListBlur(): void {\n\t\tif (this._sticky) { return; }\n\t\tif (this.selected !== this._currentSelection) {\n\t\t\t// Reset selected to current if no change\n\t\t\tthis.select(this._currentSelection);\n\t\t}\n\n\t\tthis.hideSelectDropDown(false);\n\t}\n\n\n\tprivate renderDescriptionMarkdown(text: string): HTMLElement {\n\t\tconst cleanRenderedMarkdown = (element: Node) => {\n\t\t\tfor (let i = 0; i < element.childNodes.length; i++) {\n\t\t\t\tconst child = element.childNodes.item(i);\n\n\t\t\t\tconst tagName = (<Element>child).tagName && (<Element>child).tagName.toLowerCase();\n\t\t\t\tif (tagName === 'img') {\n\t\t\t\t\telement.removeChild(child);\n\t\t\t\t} else {\n\t\t\t\t\tcleanRenderedMarkdown(child);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tconst renderedMarkdown = renderMarkdown({ value: text }, {\n\t\t\tactionHandler: this.selectBoxOptions.markdownActionHandler\n\t\t});\n\n\t\trenderedMarkdown.classList.add('select-box-description-markdown');\n\t\tcleanRenderedMarkdown(renderedMarkdown);\n\n\t\treturn renderedMarkdown;\n\t}\n\n\t// List Focus Change - passive - update details pane with newly focused element's data\n\tprivate onListFocus(e: IListEvent<ISelectOptionItem>) {\n\t\t// Skip during initial layout\n\t\tif (!this._isVisible) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.selectionDetailsPane.innerText = '';\n\t\tconst selectedIndex = e.indexes[0];\n\t\tlet description = this.detailsProvider ? this.detailsProvider(selectedIndex) : { details: '', isMarkdown: false };\n\t\tif (description.details) {\n\t\t\tif (description.isMarkdown) {\n\t\t\t\tthis.selectionDetailsPane.appendChild(this.renderDescriptionMarkdown(description.details));\n\t\t\t} else {\n\t\t\t\tthis.selectionDetailsPane.innerText = description.details;\n\t\t\t}\n\t\t\tthis.selectionDetailsPane.style.display = 'block';\n\t\t} else {\n\t\t\tthis.selectionDetailsPane.style.display = 'none';\n\t\t}\n\n\t\t// Avoid recursion\n\t\tthis._skipLayout = true;\n\t\tthis.contextViewProvider.layout();\n\t\tthis._skipLayout = false;\n\n\t}\n\n\t// List keyboard controller\n\n\t// List exit - active - hide ContextView dropdown, reset selection, return focus to parent select\n\tprivate onEscape(e: StandardKeyboardEvent): void {\n\t\tdom.EventHelper.stop(e);\n\n\t\t// Reset selection to value when opened\n\t\tthis.select(this._currentSelection);\n\t\tthis.hideSelectDropDown(true);\n\t}\n\n\t// List exit - active - hide ContextView dropdown, return focus to parent select, fire onDidSelect if change\n\tprivate onEnter(e: StandardKeyboardEvent): void {\n\t\tdom.EventHelper.stop(e);\n\n\t\t// Only fire if selection change\n\t\tif (this.selected !== this._currentSelection) {\n\t\t\tthis._currentSelection = this.selected;\n\t\t\tthis._onDidSelect.fire({\n\t\t\t\tindex: this.selectElement.selectedIndex,\n\t\t\t\tselected: this.selectElement.title\n\t\t\t});\n\t\t}\n\n\t\tthis.hideSelectDropDown(true);\n\t}\n\n\t// List navigation - have to handle a disabled option (jump over)\n\tprivate onDownArrow(): void {\n\t\tif (this.selected < this.options.length - 1) {\n\t\t\t// Skip disabled options\n\t\t\tif ((this.selected + 1) === this.disabledOptionIndex && this.options.length > this.selected + 2) {\n\t\t\t\tthis.selected += 2;\n\t\t\t} else if ((this.selected + 1) === this.disabledOptionIndex) {\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tthis.selected++;\n\t\t\t}\n\t\t\t// Set focus/selection - only fire event when closing drop-down or on blur\n\t\t\tthis.select(this.selected);\n\t\t\tthis.selectList.setFocus([this.selected]);\n\t\t\tthis.selectList.reveal(this.selectList.getFocus()[0]);\n\t\t}\n\t}\n\n\tprivate onUpArrow(): void {\n\t\tif (this.selected > 0) {\n\t\t\t// Skip disabled options\n\t\t\tif ((this.selected - 1) === this.disabledOptionIndex && this.selected > 1) {\n\t\t\t\tthis.selected -= 2;\n\t\t\t} else {\n\t\t\t\tthis.selected--;\n\t\t\t}\n\t\t\t// Set focus/selection - only fire event when closing drop-down or on blur\n\t\t\tthis.select(this.selected);\n\t\t\tthis.selectList.setFocus([this.selected]);\n\t\t\tthis.selectList.reveal(this.selectList.getFocus()[0]);\n\t\t}\n\t}\n\n\tprivate onPageUp(e: StandardKeyboardEvent): void {\n\t\tdom.EventHelper.stop(e);\n\n\t\tthis.selectList.focusPreviousPage();\n\n\t\t// Allow scrolling to settle\n\t\tsetTimeout(() => {\n\t\t\tthis.selected = this.selectList.getFocus()[0];\n\n\t\t\t// Shift selection down if we land on a disabled option\n\t\t\tif (this.selected === this.disabledOptionIndex && this.selected < this.options.length - 1) {\n\t\t\t\tthis.selected++;\n\t\t\t\tthis.selectList.setFocus([this.selected]);\n\t\t\t}\n\t\t\tthis.selectList.reveal(this.selected);\n\t\t\tthis.select(this.selected);\n\t\t}, 1);\n\t}\n\n\tprivate onPageDown(e: StandardKeyboardEvent): void {\n\t\tdom.EventHelper.stop(e);\n\n\t\tthis.selectList.focusNextPage();\n\n\t\t// Allow scrolling to settle\n\t\tsetTimeout(() => {\n\t\t\tthis.selected = this.selectList.getFocus()[0];\n\n\t\t\t// Shift selection up if we land on a disabled option\n\t\t\tif (this.selected === this.disabledOptionIndex && this.selected > 0) {\n\t\t\t\tthis.selected--;\n\t\t\t\tthis.selectList.setFocus([this.selected]);\n\t\t\t}\n\t\t\tthis.selectList.reveal(this.selected);\n\t\t\tthis.select(this.selected);\n\t\t}, 1);\n\t}\n\n\tprivate onHome(e: StandardKeyboardEvent): void {\n\t\tdom.EventHelper.stop(e);\n\n\t\tif (this.options.length < 2) {\n\t\t\treturn;\n\t\t}\n\t\tthis.selected = 0;\n\t\tif (this.selected === this.disabledOptionIndex && this.selected > 1) {\n\t\t\tthis.selected++;\n\t\t}\n\t\tthis.selectList.setFocus([this.selected]);\n\t\tthis.selectList.reveal(this.selected);\n\t\tthis.select(this.selected);\n\t}\n\n\tprivate onEnd(e: StandardKeyboardEvent): void {\n\t\tdom.EventHelper.stop(e);\n\n\t\tif (this.options.length < 2) {\n\t\t\treturn;\n\t\t}\n\t\tthis.selected = this.options.length - 1;\n\t\tif (this.selected === this.disabledOptionIndex && this.selected > 1) {\n\t\t\tthis.selected--;\n\t\t}\n\t\tthis.selectList.setFocus([this.selected]);\n\t\tthis.selectList.reveal(this.selected);\n\t\tthis.select(this.selected);\n\t}\n\n\t// Mimic option first character navigation of native select\n\tprivate onCharacter(e: StandardKeyboardEvent): void {\n\t\tconst ch = KeyCodeUtils.toString(e.keyCode);\n\t\tlet optionIndex = -1;\n\n\t\tfor (let i = 0; i < this.options.length - 1; i++) {\n\t\t\toptionIndex = (i + this.selected + 1) % this.options.length;\n\t\t\tif (this.options[optionIndex].charAt(0).toUpperCase() === ch) {\n\t\t\t\tthis.select(optionIndex);\n\t\t\t\tthis.selectList.setFocus([optionIndex]);\n\t\t\t\tthis.selectList.reveal(this.selectList.getFocus()[0]);\n\t\t\t\tdom.EventHelper.stop(e);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic dispose(): void {\n\t\tthis.hideSelectDropDown(false);\n\t\tthis.toDispose = dispose(this.toDispose);\n\t}\n}\n",
            "linguagem": "ts",
            "total_linhas": 1046
        },
        "solucao_humana": {
            "patch_diff": "@@ -129,6 +129,13 @@ export class SelectBoxList implements ISelectBoxDelegate, IListVirtualDelegate<I\n \t\t}\n \n \t\tthis.selectElement = document.createElement('select');\n+\n+\t\t// Workaround for Electron 2.x\n+\t\t// Native select should not require explicit role attribute, however, Electron 2.x\n+\t\t// incorrectly exposes select as menuItem which interferes with labeling and results\n+\t\t// in the unlabeled not been read.  Electron 3 appears to fix.\n+\t\tthis.selectElement.setAttribute('role', 'combobox');\n+\n \t\t// Use custom CSS vars for padding calculation\n \t\tthis.selectElement.className = 'monaco-select-box monaco-select-box-dropdown-padding';\n \n@@ -192,7 +199,6 @@ export class SelectBoxList implements ISelectBoxDelegate, IListVirtualDelegate<I\n \t\t// Parent native select keyboard listeners\n \n \t\tthis.toDispose.push(dom.addStandardDisposableListener(this.selectElement, 'change', (e) => {\n-\t\t\tthis.selectElement.title = e.target.value;\n \t\t\tthis.selected = e.target.selectedIndex;\n \t\t\tthis._onDidSelect.fire({\n \t\t\t\tindex: e.target.selectedIndex,\n@@ -301,7 +307,6 @@ export class SelectBoxList implements ISelectBoxDelegate, IListVirtualDelegate<I\n \t\t}\n \n \t\tthis.selectElement.selectedIndex = this.selected;\n-\t\tthis.selectElement.title = this.options[this.selected];\n \t}\n \n \tpublic setAriaLabel(label: string): void {\n@@ -821,7 +826,7 @@ export class SelectBoxList implements ISelectBoxDelegate, IListVirtualDelegate<I\n \n \t\t\t\tthis._onDidSelect.fire({\n \t\t\t\t\tindex: this.selectElement.selectedIndex,\n-\t\t\t\t\tselected: this.selectElement.title\n+\t\t\t\t\tselected: this.options[this.selected]\n \t\t\t\t});\n \t\t\t}\n \n@@ -913,7 +918,7 @@ export class SelectBoxList implements ISelectBoxDelegate, IListVirtualDelegate<I\n \t\t\tthis._currentSelection = this.selected;\n \t\t\tthis._onDidSelect.fire({\n \t\t\t\tindex: this.selectElement.selectedIndex,\n-\t\t\t\tselected: this.selectElement.title\n+\t\t\t\tselected: this.options[this.selected]\n \t\t\t});\n \t\t}\n ",
            "apenas_linhas_adicionadas": [
                "",
                "\t\t// Workaround for Electron 2.x",
                "\t\t// Native select should not require explicit role attribute, however, Electron 2.x",
                "\t\t// incorrectly exposes select as menuItem which interferes with labeling and results",
                "\t\t// in the unlabeled not been read.  Electron 3 appears to fix.",
                "\t\tthis.selectElement.setAttribute('role', 'combobox');",
                "",
                "\t\t\t\t\tselected: this.options[this.selected]",
                "\t\t\t\tselected: this.options[this.selected]"
            ]
        }
    },
    {
        "id": 62504,
        "url": "https://github.com/microsoft/vscode/pull/62504",
        "arquivo_caminho": "src/vs/base/browser/ui/selectBox/selectBoxNative.ts",
        "descricao_bug": "@chrmarti - thanks again for catching\r\n@isidorn \r\n@Tyriar \r\nIf anyone of you can review and merge, I am following new procedures not merging myself as non-MS team member.\r\nThanks!\r\n\r\n\r\n\r\n- Assign explicit role=combobox to native select box (select)\r\n- Electron 2.x incorrect assignment issue\r\n- Voiceover also affected\r\n- Equally addresses same issue with Debug Configurations label\r\n- Does not affect SelectBox within new settings , already addressed there\r\n\r\nSee: #60929\r\n\r\n![image](https://user-images.githubusercontent.com/25272315/47939923-4f93b480-debf-11e8-945a-2c938e635ba9.png)\r\n",
        "contexto": {
            "codigo_completo_bugado": "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IDisposable, dispose } from 'vs/base/common/lifecycle';\nimport { Event, Emitter } from 'vs/base/common/event';\nimport { KeyCode } from 'vs/base/common/keyCodes';\nimport * as dom from 'vs/base/browser/dom';\nimport * as arrays from 'vs/base/common/arrays';\nimport { ISelectBoxDelegate, ISelectBoxOptions, ISelectBoxStyles, ISelectData } from 'vs/base/browser/ui/selectBox/selectBox';\nimport { isMacintosh } from 'vs/base/common/platform';\n\nexport class SelectBoxNative implements ISelectBoxDelegate {\n\n\tprivate selectElement: HTMLSelectElement;\n\tprivate selectBoxOptions: ISelectBoxOptions;\n\tprivate options: string[];\n\tprivate selected: number;\n\tprivate readonly _onDidSelect: Emitter<ISelectData>;\n\tprivate toDispose: IDisposable[];\n\tprivate styles: ISelectBoxStyles;\n\n\tconstructor(options: string[], selected: number, styles: ISelectBoxStyles, selectBoxOptions?: ISelectBoxOptions) {\n\n\t\tthis.toDispose = [];\n\t\tthis.selectBoxOptions = selectBoxOptions || Object.create(null);\n\n\t\tthis.selectElement = document.createElement('select');\n\t\tthis.selectElement.className = 'monaco-select-box';\n\n\t\tif (typeof this.selectBoxOptions.ariaLabel === 'string') {\n\t\t\tthis.selectElement.setAttribute('aria-label', this.selectBoxOptions.ariaLabel);\n\t\t}\n\n\t\tthis._onDidSelect = new Emitter<ISelectData>();\n\t\tthis.toDispose.push(this._onDidSelect);\n\n\t\tthis.styles = styles;\n\n\t\tthis.registerListeners();\n\t\tthis.setOptions(options, selected);\n\t}\n\n\tprivate registerListeners() {\n\n\t\tthis.toDispose.push(dom.addStandardDisposableListener(this.selectElement, 'change', (e) => {\n\t\t\tthis.selectElement.title = e.target.value;\n\t\t\tthis._onDidSelect.fire({\n\t\t\t\tindex: e.target.selectedIndex,\n\t\t\t\tselected: e.target.value\n\t\t\t});\n\t\t}));\n\n\t\tthis.toDispose.push(dom.addStandardDisposableListener(this.selectElement, 'keydown', (e) => {\n\t\t\tlet showSelect = false;\n\n\t\t\tif (isMacintosh) {\n\t\t\t\tif (e.keyCode === KeyCode.DownArrow || e.keyCode === KeyCode.UpArrow || e.keyCode === KeyCode.Space) {\n\t\t\t\t\tshowSelect = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (e.keyCode === KeyCode.DownArrow && e.altKey || e.keyCode === KeyCode.Space || e.keyCode === KeyCode.Enter) {\n\t\t\t\t\tshowSelect = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (showSelect) {\n\t\t\t\t// Space, Enter, is used to expand select box, do not propagate it (prevent action bar action run)\n\t\t\t\te.stopPropagation();\n\t\t\t}\n\t\t}));\n\t}\n\n\tpublic get onDidSelect(): Event<ISelectData> {\n\t\treturn this._onDidSelect.event;\n\t}\n\n\tpublic setOptions(options: string[], selected?: number, disabled?: number): void {\n\n\t\tif (!this.options || !arrays.equals(this.options, options)) {\n\t\t\tthis.options = options;\n\t\t\tthis.selectElement.options.length = 0;\n\n\t\t\tlet i = 0;\n\t\t\tthis.options.forEach((option) => {\n\t\t\t\tthis.selectElement.add(this.createOption(option, i, disabled === i++));\n\t\t\t});\n\n\t\t}\n\n\t\tif (selected !== undefined) {\n\t\t\tthis.select(selected);\n\t\t}\n\t}\n\n\tpublic select(index: number): void {\n\t\tif (index >= 0 && index < this.options.length) {\n\t\t\tthis.selected = index;\n\t\t} else if (index > this.options.length - 1) {\n\t\t\t// Adjust index to end of list\n\t\t\t// This could make client out of sync with the select\n\t\t\tthis.select(this.options.length - 1);\n\t\t} else if (this.selected < 0) {\n\t\t\tthis.selected = 0;\n\t\t}\n\n\t\tthis.selectElement.selectedIndex = this.selected;\n\t\tthis.selectElement.title = this.options[this.selected];\n\t}\n\n\tpublic setAriaLabel(label: string): void {\n\t\tthis.selectBoxOptions.ariaLabel = label;\n\t\tthis.selectElement.setAttribute('aria-label', label);\n\t}\n\n\tpublic setDetailsProvider(provider: any): void {\n\t\tconsole.error('details are not available for native select boxes');\n\t}\n\n\tpublic focus(): void {\n\t\tif (this.selectElement) {\n\t\t\tthis.selectElement.focus();\n\t\t}\n\t}\n\n\tpublic blur(): void {\n\t\tif (this.selectElement) {\n\t\t\tthis.selectElement.blur();\n\t\t}\n\t}\n\n\tpublic render(container: HTMLElement): void {\n\t\tdom.addClass(container, 'select-container');\n\t\tcontainer.appendChild(this.selectElement);\n\t\tthis.setOptions(this.options, this.selected);\n\t\tthis.applyStyles();\n\t}\n\n\tpublic style(styles: ISelectBoxStyles): void {\n\t\tthis.styles = styles;\n\t\tthis.applyStyles();\n\t}\n\n\tpublic applyStyles(): void {\n\n\t\t// Style native select\n\t\tif (this.selectElement) {\n\t\t\tconst background = this.styles.selectBackground ? this.styles.selectBackground.toString() : null;\n\t\t\tconst foreground = this.styles.selectForeground ? this.styles.selectForeground.toString() : null;\n\t\t\tconst border = this.styles.selectBorder ? this.styles.selectBorder.toString() : null;\n\n\t\t\tthis.selectElement.style.backgroundColor = background;\n\t\t\tthis.selectElement.style.color = foreground;\n\t\t\tthis.selectElement.style.borderColor = border;\n\t\t}\n\n\t}\n\n\tprivate createOption(value: string, index: number, disabled?: boolean): HTMLOptionElement {\n\t\tlet option = document.createElement('option');\n\t\toption.value = value;\n\t\toption.text = value;\n\t\toption.disabled = disabled;\n\n\t\treturn option;\n\t}\n\n\tpublic dispose(): void {\n\t\tthis.toDispose = dispose(this.toDispose);\n\t}\n}\n",
            "linguagem": "ts",
            "total_linhas": 173
        },
        "solucao_humana": {
            "patch_diff": "@@ -27,6 +27,13 @@ export class SelectBoxNative implements ISelectBoxDelegate {\n \t\tthis.selectBoxOptions = selectBoxOptions || Object.create(null);\n \n \t\tthis.selectElement = document.createElement('select');\n+\n+\t\t// Workaround for Electron 2.x\n+\t\t// Native select should not require explicit role attribute, however, Electron 2.x\n+\t\t// incorrectly exposes select as menuItem which interferes with labeling and results\n+\t\t// in the unlabeled not been read.  Electron 3 appears to fix.\n+\t\tthis.selectElement.setAttribute('role', 'combobox');\n+\n \t\tthis.selectElement.className = 'monaco-select-box';\n \n \t\tif (typeof this.selectBoxOptions.ariaLabel === 'string') {",
            "apenas_linhas_adicionadas": [
                "",
                "\t\t// Workaround for Electron 2.x",
                "\t\t// Native select should not require explicit role attribute, however, Electron 2.x",
                "\t\t// incorrectly exposes select as menuItem which interferes with labeling and results",
                "\t\t// in the unlabeled not been read.  Electron 3 appears to fix.",
                "\t\tthis.selectElement.setAttribute('role', 'combobox');",
                ""
            ]
        }
    },
    {
        "id": 64271,
        "url": "https://github.com/microsoft/vscode/pull/64271",
        "arquivo_caminho": "src/vs/base/browser/ui/selectBox/selectBoxCustom.ts",
        "descricao_bug": "Fixes: #64265 - assuming unintentional\r\n\r\nReset _sticky flag to false - true prevents dropdown from closing on loss of focus- debugging flag\r\n\r\n",
        "contexto": {
            "codigo_completo_bugado": "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport 'vs/css!./selectBoxCustom';\n\nimport { IDisposable, dispose } from 'vs/base/common/lifecycle';\nimport { Event, Emitter, chain } from 'vs/base/common/event';\nimport { KeyCode, KeyCodeUtils } from 'vs/base/common/keyCodes';\nimport { StandardKeyboardEvent } from 'vs/base/browser/keyboardEvent';\nimport * as dom from 'vs/base/browser/dom';\nimport * as arrays from 'vs/base/common/arrays';\nimport { IContextViewProvider, AnchorPosition } from 'vs/base/browser/ui/contextview/contextview';\nimport { List } from 'vs/base/browser/ui/list/listWidget';\nimport { IListVirtualDelegate, IListRenderer, IListEvent } from 'vs/base/browser/ui/list/list';\nimport { domEvent } from 'vs/base/browser/event';\nimport { ScrollbarVisibility } from 'vs/base/common/scrollable';\nimport { ISelectBoxDelegate, ISelectBoxOptions, ISelectBoxStyles, ISelectData } from 'vs/base/browser/ui/selectBox/selectBox';\nimport { isMacintosh } from 'vs/base/common/platform';\nimport { renderMarkdown } from 'vs/base/browser/htmlContentRenderer';\n\nconst $ = dom.$;\n\nconst SELECT_OPTION_ENTRY_TEMPLATE_ID = 'selectOption.entry.template';\n\nexport interface ISelectOptionItem {\n\toptionText: string;\n\toptionDescriptionText?: string;\n\toptionDisabled: boolean;\n}\n\ninterface ISelectListTemplateData {\n\troot: HTMLElement;\n\toptionText: HTMLElement;\n\toptionDescriptionText: HTMLElement;\n\tdisposables: IDisposable[];\n}\n\nclass SelectListRenderer implements IListRenderer<ISelectOptionItem, ISelectListTemplateData> {\n\n\tget templateId(): string { return SELECT_OPTION_ENTRY_TEMPLATE_ID; }\n\n\tconstructor() { }\n\n\trenderTemplate(container: HTMLElement): any {\n\t\tconst data = <ISelectListTemplateData>Object.create(null);\n\t\tdata.disposables = [];\n\t\tdata.root = container;\n\t\tdata.optionText = dom.append(container, $('.option-text'));\n\t\tdata.optionDescriptionText = dom.append(container, $('.option-text-description'));\n\t\tdom.addClass(data.optionDescriptionText, 'visually-hidden');\n\n\t\treturn data;\n\t}\n\n\trenderElement(element: ISelectOptionItem, index: number, templateData: ISelectListTemplateData): void {\n\t\tconst data = <ISelectListTemplateData>templateData;\n\t\tconst optionText = (<ISelectOptionItem>element).optionText;\n\t\tconst optionDisabled = (<ISelectOptionItem>element).optionDisabled;\n\n\t\tdata.optionText.textContent = optionText;\n\n\t\tif (typeof element.optionDescriptionText === 'string') {\n\t\t\tconst optionDescriptionId = (optionText.replace(/ /g, '_').toLowerCase() + '_description_' + data.root.id);\n\t\t\tdata.optionText.setAttribute('aria-describedby', optionDescriptionId);\n\t\t\tdata.optionDescriptionText.id = optionDescriptionId;\n\t\t\tdata.optionDescriptionText.innerText = element.optionDescriptionText;\n\t\t}\n\n\t\t// pseudo-select disabled option\n\t\tif (optionDisabled) {\n\t\t\tdom.addClass((<HTMLElement>data.root), 'option-disabled');\n\t\t} else {\n\t\t\t// Make sure we do class removal from prior template rendering\n\t\t\tdom.removeClass((<HTMLElement>data.root), 'option-disabled');\n\t\t}\n\t}\n\n\tdisposeElement(): void {\n\t\t// noop\n\t}\n\n\tdisposeTemplate(templateData: ISelectListTemplateData): void {\n\t\ttemplateData.disposables = dispose(templateData.disposables);\n\t}\n}\n\nexport class SelectBoxList implements ISelectBoxDelegate, IListVirtualDelegate<ISelectOptionItem> {\n\n\tprivate static readonly DEFAULT_DROPDOWN_MINIMUM_BOTTOM_MARGIN = 32;\n\tprivate static readonly DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN = 2;\n\tprivate static readonly DEFAULT_MINIMUM_VISIBLE_OPTIONS = 3;\n\n\tprivate _isVisible: boolean;\n\tprivate selectBoxOptions: ISelectBoxOptions;\n\tprivate selectElement: HTMLSelectElement;\n\tprivate options: string[];\n\tprivate selected: number;\n\tprivate disabledOptionIndex: number;\n\tprivate readonly _onDidSelect: Emitter<ISelectData>;\n\tprivate toDispose: IDisposable[];\n\tprivate styles: ISelectBoxStyles;\n\tprivate listRenderer: SelectListRenderer;\n\tprivate contextViewProvider: IContextViewProvider;\n\tprivate selectDropDownContainer: HTMLElement;\n\tprivate styleElement: HTMLStyleElement;\n\tprivate selectList: List<ISelectOptionItem>;\n\tprivate selectDropDownListContainer: HTMLElement;\n\tprivate widthControlElement: HTMLElement;\n\tprivate _currentSelection: number;\n\tprivate _dropDownPosition: AnchorPosition;\n\tprivate detailsProvider: (index: number) => { details: string, isMarkdown: boolean };\n\tprivate selectionDetailsPane: HTMLElement;\n\tprivate _skipLayout: boolean = false;\n\n\tprivate _sticky: boolean = true; // for dev purposes only\n\n\tconstructor(options: string[], selected: number, contextViewProvider: IContextViewProvider, styles: ISelectBoxStyles, selectBoxOptions?: ISelectBoxOptions) {\n\n\t\tthis.toDispose = [];\n\t\tthis._isVisible = false;\n\t\tthis.selectBoxOptions = selectBoxOptions || Object.create(null);\n\n\t\tif (typeof this.selectBoxOptions.minBottomMargin !== 'number') {\n\t\t\tthis.selectBoxOptions.minBottomMargin = SelectBoxList.DEFAULT_DROPDOWN_MINIMUM_BOTTOM_MARGIN;\n\t\t} else if (this.selectBoxOptions.minBottomMargin < 0) {\n\t\t\tthis.selectBoxOptions.minBottomMargin = 0;\n\t\t}\n\n\t\tthis.selectElement = document.createElement('select');\n\n\t\t// Workaround for Electron 2.x\n\t\t// Native select should not require explicit role attribute, however, Electron 2.x\n\t\t// incorrectly exposes select as menuItem which interferes with labeling and results\n\t\t// in the unlabeled not been read.  Electron 3 appears to fix.\n\t\tthis.selectElement.setAttribute('role', 'combobox');\n\n\t\t// Use custom CSS vars for padding calculation\n\t\tthis.selectElement.className = 'monaco-select-box monaco-select-box-dropdown-padding';\n\n\t\tif (typeof this.selectBoxOptions.ariaLabel === 'string') {\n\t\t\tthis.selectElement.setAttribute('aria-label', this.selectBoxOptions.ariaLabel);\n\t\t}\n\n\t\tthis._onDidSelect = new Emitter<ISelectData>();\n\t\tthis.toDispose.push(this._onDidSelect);\n\n\t\tthis.styles = styles;\n\n\t\tthis.registerListeners();\n\t\tthis.constructSelectDropDown(contextViewProvider);\n\n\t\tthis.selected = selected || 0;\n\n\t\tif (options) {\n\t\t\tthis.setOptions(options, selected);\n\t\t}\n\n\t}\n\n\t// IDelegate - List renderer\n\n\tgetHeight(): number {\n\t\treturn 18;\n\t}\n\n\tgetTemplateId(): string {\n\t\treturn SELECT_OPTION_ENTRY_TEMPLATE_ID;\n\t}\n\n\tprivate constructSelectDropDown(contextViewProvider: IContextViewProvider) {\n\n\t\t// SetUp ContextView container to hold select Dropdown\n\t\tthis.contextViewProvider = contextViewProvider;\n\t\tthis.selectDropDownContainer = dom.$('.monaco-select-box-dropdown-container');\n\t\t// Use custom CSS vars for padding calculation (shared with parent select)\n\t\tdom.addClass(this.selectDropDownContainer, 'monaco-select-box-dropdown-padding');\n\n\t\t// Setup container for select option details\n\t\tthis.selectionDetailsPane = dom.append(this.selectDropDownContainer, $('.select-box-details-pane'));\n\n\t\t// Create span flex box item/div we can measure and control\n\t\tlet widthControlOuterDiv = dom.append(this.selectDropDownContainer, $('.select-box-dropdown-container-width-control'));\n\t\tlet widthControlInnerDiv = dom.append(widthControlOuterDiv, $('.width-control-div'));\n\t\tthis.widthControlElement = document.createElement('span');\n\t\tthis.widthControlElement.className = 'option-text-width-control';\n\t\tdom.append(widthControlInnerDiv, this.widthControlElement);\n\n\t\t// Always default to below position\n\t\tthis._dropDownPosition = AnchorPosition.BELOW;\n\n\t\t// Inline stylesheet for themes\n\t\tthis.styleElement = dom.createStyleSheet(this.selectDropDownContainer);\n\t}\n\n\tprivate registerListeners() {\n\n\t\t// Parent native select keyboard listeners\n\n\t\tthis.toDispose.push(dom.addStandardDisposableListener(this.selectElement, 'change', (e) => {\n\t\t\tthis.selected = e.target.selectedIndex;\n\t\t\tthis._onDidSelect.fire({\n\t\t\t\tindex: e.target.selectedIndex,\n\t\t\t\tselected: e.target.value\n\t\t\t});\n\t\t}));\n\n\t\t// Have to implement both keyboard and mouse controllers to handle disabled options\n\t\t// Intercept mouse events to override normal select actions on parents\n\n\t\tthis.toDispose.push(dom.addDisposableListener(this.selectElement, dom.EventType.CLICK, (e) => {\n\t\t\tdom.EventHelper.stop(e);\n\n\t\t\tif (this._isVisible) {\n\t\t\t\tthis.hideSelectDropDown(true);\n\t\t\t} else {\n\t\t\t\tthis.showSelectDropDown();\n\t\t\t}\n\t\t}));\n\n\t\tthis.toDispose.push(dom.addDisposableListener(this.selectElement, dom.EventType.MOUSE_DOWN, (e) => {\n\t\t\tdom.EventHelper.stop(e);\n\t\t}));\n\n\t\t// Intercept keyboard handling\n\n\t\tthis.toDispose.push(dom.addDisposableListener(this.selectElement, dom.EventType.KEY_DOWN, (e: KeyboardEvent) => {\n\t\t\tconst event = new StandardKeyboardEvent(e);\n\t\t\tlet showDropDown = false;\n\n\t\t\t// Create and drop down select list on keyboard select\n\t\t\tif (isMacintosh) {\n\t\t\t\tif (event.keyCode === KeyCode.DownArrow || event.keyCode === KeyCode.UpArrow || event.keyCode === KeyCode.Space || event.keyCode === KeyCode.Enter) {\n\t\t\t\t\tshowDropDown = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (event.keyCode === KeyCode.DownArrow && event.altKey || event.keyCode === KeyCode.UpArrow && event.altKey || event.keyCode === KeyCode.Space || event.keyCode === KeyCode.Enter) {\n\t\t\t\t\tshowDropDown = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (showDropDown) {\n\t\t\t\tthis.showSelectDropDown();\n\t\t\t\tdom.EventHelper.stop(e);\n\t\t\t}\n\t\t}));\n\t}\n\n\tpublic get onDidSelect(): Event<ISelectData> {\n\t\treturn this._onDidSelect.event;\n\t}\n\n\tpublic setOptions(options: string[], selected?: number, disabled?: number): void {\n\t\tif (!this.options || !arrays.equals(this.options, options)) {\n\t\t\tthis.options = options;\n\t\t\tthis.selectElement.options.length = 0;\n\n\t\t\tlet i = 0;\n\t\t\tthis.options.forEach((option) => {\n\t\t\t\tthis.selectElement.add(this.createOption(option, i, disabled === i++));\n\t\t\t});\n\n\t\t\tif (disabled !== undefined) {\n\t\t\t\tthis.disabledOptionIndex = disabled;\n\t\t\t}\n\t\t}\n\n\t\tif (selected !== undefined) {\n\t\t\tthis.select(selected);\n\t\t\t// Set current = selected since this is not necessarily a user exit\n\t\t\tthis._currentSelection = this.selected;\n\t\t}\n\t}\n\n\n\tprivate setOptionsList() {\n\n\t\t// Mirror options in drop-down\n\t\t// Populate select list for non-native select mode\n\t\tif (this.selectList && !!this.options) {\n\t\t\tlet listEntries: ISelectOptionItem[];\n\t\t\tlistEntries = [];\n\n\t\t\tfor (let index = 0; index < this.options.length; index++) {\n\t\t\t\tconst element = this.options[index];\n\t\t\t\tlet optionDisabled: boolean;\n\t\t\t\tindex === this.disabledOptionIndex ? optionDisabled = true : optionDisabled = false;\n\t\t\t\tconst optionDescription = this.detailsProvider ? this.detailsProvider(index) : { details: undefined, isMarkdown: false };\n\n\t\t\t\tlistEntries.push({ optionText: element, optionDisabled: optionDisabled, optionDescriptionText: optionDescription.details });\n\t\t\t}\n\t\t\tthis.selectList.splice(0, this.selectList.length, listEntries);\n\t\t}\n\t}\n\n\tpublic select(index: number): void {\n\n\t\tif (index >= 0 && index < this.options.length) {\n\t\t\tthis.selected = index;\n\t\t} else if (index > this.options.length - 1) {\n\t\t\t// Adjust index to end of list\n\t\t\t// This could make client out of sync with the select\n\t\t\tthis.select(this.options.length - 1);\n\t\t} else if (this.selected < 0) {\n\t\t\tthis.selected = 0;\n\t\t}\n\n\t\tthis.selectElement.selectedIndex = this.selected;\n\t}\n\n\tpublic setAriaLabel(label: string): void {\n\t\tthis.selectBoxOptions.ariaLabel = label;\n\t\tthis.selectElement.setAttribute('aria-label', this.selectBoxOptions.ariaLabel);\n\t}\n\n\tpublic setDetailsProvider(provider: (index: number) => { details: string, isMarkdown: boolean }): void {\n\t\tthis.detailsProvider = provider;\n\t}\n\n\tpublic focus(): void {\n\t\tif (this.selectElement) {\n\t\t\tthis.selectElement.focus();\n\t\t}\n\t}\n\n\tpublic blur(): void {\n\t\tif (this.selectElement) {\n\t\t\tthis.selectElement.blur();\n\t\t}\n\t}\n\n\tpublic render(container: HTMLElement): void {\n\t\tdom.addClass(container, 'select-container');\n\t\tcontainer.appendChild(this.selectElement);\n\t\tthis.applyStyles();\n\t}\n\n\tpublic style(styles: ISelectBoxStyles): void {\n\n\t\tconst content: string[] = [];\n\n\t\tthis.styles = styles;\n\n\t\t// Style non-native select mode\n\n\t\tif (this.styles.listFocusBackground) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.focused { background-color: ${this.styles.listFocusBackground} !important; }`);\n\t\t}\n\n\t\tif (this.styles.listFocusForeground) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.focused:not(:hover) { color: ${this.styles.listFocusForeground} !important; }`);\n\t\t}\n\n\t\tif (this.styles.selectBackground && this.styles.selectBorder && !this.styles.selectBorder.equals(this.styles.selectBackground)) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container { border: 1px solid ${this.styles.selectBorder} } `);\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-details-pane.border-top { border-top: 1px solid ${this.styles.selectBorder} } `);\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-details-pane.border-bottom { border-bottom: 1px solid ${this.styles.selectBorder} } `);\n\n\t\t}\n\t\telse if (this.styles.selectListBorder) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-details-pane.border-top { border-top: 1px solid ${this.styles.selectListBorder} } `);\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-details-pane.border-bottom { border-bottom: 1px solid ${this.styles.selectListBorder} } `);\n\t\t}\n\n\t\t// Hover foreground - ignore for disabled options\n\t\tif (this.styles.listHoverForeground) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:hover { color: ${this.styles.listHoverForeground} !important; }`);\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.option-disabled:hover { background-color: ${this.styles.listActiveSelectionForeground} !important; }`);\n\t\t}\n\n\t\t// Hover background - ignore for disabled options\n\t\tif (this.styles.listHoverBackground) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:not(.option-disabled):not(.focused):hover { background-color: ${this.styles.listHoverBackground} !important; }`);\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.option-disabled:hover { background-color: ${this.styles.selectBackground} !important; }`);\n\t\t}\n\n\t\t// Match quickOpen outline styles - ignore for disabled options\n\t\tif (this.styles.listFocusOutline) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.focused { outline: 1.6px dotted ${this.styles.listFocusOutline} !important; outline-offset: -1.6px !important; }`);\n\n\t\t}\n\n\t\tif (this.styles.listHoverOutline) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:hover:not(.focused) { outline: 1.6px dashed ${this.styles.listHoverOutline} !important; outline-offset: -1.6px !important; }`);\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.option-disabled:hover { outline: none !important; }`);\n\t\t}\n\n\t\tthis.styleElement.innerHTML = content.join('\\n');\n\n\t\tthis.applyStyles();\n\t}\n\n\tpublic applyStyles(): void {\n\n\t\t// Style parent select\n\n\t\tif (this.selectElement) {\n\t\t\tconst background = this.styles.selectBackground ? this.styles.selectBackground.toString() : null;\n\t\t\tconst foreground = this.styles.selectForeground ? this.styles.selectForeground.toString() : null;\n\t\t\tconst border = this.styles.selectBorder ? this.styles.selectBorder.toString() : null;\n\n\t\t\tthis.selectElement.style.backgroundColor = background;\n\t\t\tthis.selectElement.style.color = foreground;\n\t\t\tthis.selectElement.style.borderColor = border;\n\t\t}\n\n\t\t// Style drop down select list (non-native mode only)\n\n\t\tif (this.selectList) {\n\t\t\tthis.styleList();\n\t\t}\n\t}\n\n\tprivate styleList() {\n\t\tif (this.selectList) {\n\t\t\tlet background = this.styles.selectBackground ? this.styles.selectBackground.toString() : null;\n\t\t\tthis.selectList.style({});\n\n\t\t\tlet listBackground = this.styles.selectListBackground ? this.styles.selectListBackground.toString() : background;\n\t\t\tthis.selectDropDownListContainer.style.backgroundColor = listBackground;\n\t\t\tthis.selectionDetailsPane.style.backgroundColor = listBackground;\n\t\t\tconst optionsBorder = this.styles.focusBorder ? this.styles.focusBorder.toString() : null;\n\t\t\tthis.selectDropDownContainer.style.outlineColor = optionsBorder;\n\t\t\tthis.selectDropDownContainer.style.outlineOffset = '-1px';\n\t\t}\n\t}\n\n\tprivate createOption(value: string, index: number, disabled?: boolean): HTMLOptionElement {\n\t\tlet option = document.createElement('option');\n\t\toption.value = value;\n\t\toption.text = value;\n\t\toption.disabled = !!disabled;\n\n\t\treturn option;\n\t}\n\n\t// ContextView dropdown methods\n\n\tprivate showSelectDropDown() {\n\n\t\tif (!this.contextViewProvider || this._isVisible) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Lazily create and populate list only at open, moved from constructor\n\t\tthis.createSelectList(this.selectDropDownContainer);\n\t\tthis.setOptionsList();\n\n\t\tthis.cloneElementFont(this.selectElement, this.selectDropDownContainer);\n\n\t\t// This allows us to flip the position based on measurement\n\t\t// Set drop-down position above/below from required height and margins\n\t\t// If pre-layout cannot fit at least one option do not show drop-down\n\n\t\tthis.contextViewProvider.showContextView({\n\t\t\tgetAnchor: () => this.selectElement,\n\t\t\trender: (container: HTMLElement) => this.renderSelectDropDown(container, true),\n\t\t\tlayout: () => {\n\t\t\t\tthis.layoutSelectDropDown();\n\t\t\t},\n\t\t\tonHide: () => {\n\t\t\t\tdom.toggleClass(this.selectDropDownContainer, 'visible', false);\n\t\t\t\tdom.toggleClass(this.selectElement, 'synthetic-focus', false);\n\t\t\t},\n\t\t\tanchorPosition: this._dropDownPosition\n\t\t});\n\n\t\t// Hide so we can relay out\n\t\tthis._isVisible = true;\n\t\tthis.hideSelectDropDown(false);\n\n\t\tthis.contextViewProvider.showContextView({\n\t\t\tgetAnchor: () => this.selectElement,\n\t\t\trender: (container: HTMLElement) => this.renderSelectDropDown(container),\n\t\t\tlayout: () => this.layoutSelectDropDown(),\n\t\t\tonHide: () => {\n\t\t\t\tdom.toggleClass(this.selectDropDownContainer, 'visible', false);\n\t\t\t\tdom.toggleClass(this.selectElement, 'synthetic-focus', false);\n\t\t\t},\n\t\t\tanchorPosition: this._dropDownPosition\n\t\t});\n\n\t\t// Track initial selection the case user escape, blur\n\t\tthis._currentSelection = this.selected;\n\t\tthis._isVisible = true;\n\t}\n\n\tprivate hideSelectDropDown(focusSelect: boolean) {\n\t\tif (!this.contextViewProvider || !this._isVisible) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._isVisible = false;\n\n\t\tif (focusSelect) {\n\t\t\tthis.selectElement.focus();\n\t\t}\n\n\t\tthis.contextViewProvider.hideContextView();\n\t}\n\n\tprivate renderSelectDropDown(container: HTMLElement, preLayoutPosition?: boolean): IDisposable {\n\t\tcontainer.appendChild(this.selectDropDownContainer);\n\n\t\t// Pre-Layout allows us to change position\n\t\tthis.layoutSelectDropDown(preLayoutPosition);\n\n\t\treturn {\n\t\t\tdispose: () => {\n\t\t\t\t// contextView will dispose itself if moving from one View to another\n\t\t\t\ttry {\n\t\t\t\t\tcontainer.removeChild(this.selectDropDownContainer); // remove to take out the CSS rules we add\n\t\t\t\t}\n\t\t\t\tcatch (error) {\n\t\t\t\t\t// Ignore, removed already by change of focus\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t// Iterate over detailed descriptions, find max height\n\tprivate measureMaxDetailsHeight(): number {\n\n\t\tif (!this.detailsProvider) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tlet maxDetailsPaneHeight = 0;\n\t\tlet description = { details: '', isMarkdown: false };\n\n\t\tthis.options.forEach((option, index) => {\n\n\t\t\tthis.selectionDetailsPane.innerText = '';\n\n\t\t\tdescription = this.detailsProvider ? this.detailsProvider(index) : { details: '', isMarkdown: false };\n\t\t\tif (description.details) {\n\t\t\t\tif (description.isMarkdown) {\n\t\t\t\t\tthis.selectionDetailsPane.appendChild(this.renderDescriptionMarkdown(description.details));\n\t\t\t\t} else {\n\t\t\t\t\tthis.selectionDetailsPane.innerText = description.details;\n\t\t\t\t}\n\t\t\t\tthis.selectionDetailsPane.style.display = 'block';\n\t\t\t} else {\n\t\t\t\tthis.selectionDetailsPane.style.display = 'none';\n\t\t\t}\n\n\t\t\tif (this.selectionDetailsPane.offsetHeight > maxDetailsPaneHeight) {\n\t\t\t\tmaxDetailsPaneHeight = this.selectionDetailsPane.offsetHeight;\n\t\t\t}\n\t\t});\n\n\t\t// Reset description to selected\n\t\tdescription = this.detailsProvider ? this.detailsProvider(this.selected) : { details: '', isMarkdown: false };\n\t\tthis.selectionDetailsPane.innerText = '';\n\n\t\tif (description.details) {\n\t\t\tif (description.isMarkdown) {\n\t\t\t\tthis.selectionDetailsPane.appendChild(this.renderDescriptionMarkdown(description.details));\n\t\t\t} else {\n\t\t\t\tthis.selectionDetailsPane.innerText = description.details;\n\t\t\t}\n\t\t\tthis.selectionDetailsPane.style.display = 'block';\n\t\t}\n\n\t\treturn maxDetailsPaneHeight;\n\t}\n\n\tprivate layoutSelectDropDown(preLayoutPosition?: boolean): boolean {\n\n\t\t// Avoid recursion from layout called in onListFocus\n\t\tif (this._skipLayout) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Layout ContextView drop down select list and container\n\t\t// Have to manage our vertical overflow, sizing, position below or above\n\t\t// Position has to be determined and set prior to contextView instantiation\n\n\t\tif (this.selectList) {\n\n\t\t\t// Make visible to enable measurements\n\t\t\tdom.toggleClass(this.selectDropDownContainer, 'visible', true);\n\n\t\t\tconst selectPosition = dom.getDomNodePagePosition(this.selectElement);\n\t\t\tconst styles = getComputedStyle(this.selectElement);\n\t\t\tconst verticalPadding = parseFloat(styles.getPropertyValue('--dropdown-padding-top')) + parseFloat(styles.getPropertyValue('--dropdown-padding-bottom'));\n\t\t\tconst maxSelectDropDownHeightBelow = (window.innerHeight - selectPosition.top - selectPosition.height - (this.selectBoxOptions.minBottomMargin || 0));\n\t\t\tconst maxSelectDropDownHeightAbove = (selectPosition.top - SelectBoxList.DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN);\n\n\t\t\t// Determine optimal width - min(longest option), opt(parent select, excluding margins), max(ContextView controlled)\n\t\t\tconst selectWidth = this.selectElement.offsetWidth;\n\t\t\tconst selectMinWidth = this.setWidthControlElement(this.widthControlElement);\n\t\t\tconst selectOptimalWidth = Math.max(selectMinWidth, Math.round(selectWidth)).toString() + 'px';\n\n\t\t\tthis.selectDropDownContainer.style.width = selectOptimalWidth;\n\n\t\t\t// Get initial list height and determine space ab1you knowove and below\n\t\t\tthis.selectList.layout();\n\t\t\tlet listHeight = this.selectList.contentHeight;\n\n\t\t\tconst maxDetailsPaneHeight = this.measureMaxDetailsHeight();\n\n\t\t\tconst minRequiredDropDownHeight = listHeight + verticalPadding + maxDetailsPaneHeight;\n\t\t\tconst maxVisibleOptionsBelow = ((Math.floor((maxSelectDropDownHeightBelow - verticalPadding - maxDetailsPaneHeight) / this.getHeight())));\n\t\t\tconst maxVisibleOptionsAbove = ((Math.floor((maxSelectDropDownHeightAbove - verticalPadding - maxDetailsPaneHeight) / this.getHeight())));\n\n\t\t\t// If we are only doing pre-layout check/adjust position only\n\t\t\t// Calculate vertical space available, flip up if insufficient\n\t\t\t// Use reflected padding on parent select, ContextView style\n\t\t\t// properties not available before DOM attachment\n\n\t\t\tif (preLayoutPosition) {\n\n\t\t\t\t// Check if select moved out of viewport , do not open\n\t\t\t\t// If at least one option cannot be shown, don't open the drop-down or hide/remove if open\n\n\t\t\t\tif ((selectPosition.top + selectPosition.height) > (window.innerHeight - 22)\n\t\t\t\t\t|| selectPosition.top < SelectBoxList.DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN\n\t\t\t\t\t|| ((maxVisibleOptionsBelow < 1) && (maxVisibleOptionsAbove < 1))) {\n\t\t\t\t\t// Indicate we cannot open\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Determine if we have to flip up\n\t\t\t\t// Always show complete list items - never more than Max available vertical height\n\t\t\t\tif (maxVisibleOptionsBelow < SelectBoxList.DEFAULT_MINIMUM_VISIBLE_OPTIONS\n\t\t\t\t\t&& maxVisibleOptionsAbove > maxVisibleOptionsBelow\n\t\t\t\t\t&& this.options.length > maxVisibleOptionsBelow\n\t\t\t\t) {\n\t\t\t\t\tthis._dropDownPosition = AnchorPosition.ABOVE;\n\t\t\t\t\tthis.selectDropDownContainer.removeChild(this.selectDropDownListContainer);\n\t\t\t\t\tthis.selectDropDownContainer.removeChild(this.selectionDetailsPane);\n\t\t\t\t\tthis.selectDropDownContainer.appendChild(this.selectionDetailsPane);\n\t\t\t\t\tthis.selectDropDownContainer.appendChild(this.selectDropDownListContainer);\n\n\t\t\t\t\tdom.removeClass(this.selectionDetailsPane, 'border-top');\n\t\t\t\t\tdom.addClass(this.selectionDetailsPane, 'border-bottom');\n\n\t\t\t\t} else {\n\t\t\t\t\tthis._dropDownPosition = AnchorPosition.BELOW;\n\t\t\t\t\tthis.selectDropDownContainer.removeChild(this.selectDropDownListContainer);\n\t\t\t\t\tthis.selectDropDownContainer.removeChild(this.selectionDetailsPane);\n\t\t\t\t\tthis.selectDropDownContainer.appendChild(this.selectDropDownListContainer);\n\t\t\t\t\tthis.selectDropDownContainer.appendChild(this.selectionDetailsPane);\n\n\t\t\t\t\tdom.removeClass(this.selectionDetailsPane, 'border-bottom');\n\t\t\t\t\tdom.addClass(this.selectionDetailsPane, 'border-top');\n\t\t\t\t}\n\t\t\t\t// Do full layout on showSelectDropDown only\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// Check if select out of viewport or cutting into status bar\n\t\t\tif ((selectPosition.top + selectPosition.height) > (window.innerHeight - 22)\n\t\t\t\t|| selectPosition.top < SelectBoxList.DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN\n\t\t\t\t|| (this._dropDownPosition === AnchorPosition.BELOW && maxVisibleOptionsBelow < 1)\n\t\t\t\t|| (this._dropDownPosition === AnchorPosition.ABOVE && maxVisibleOptionsAbove < 1)) {\n\t\t\t\t// Cannot properly layout, close and hide\n\t\t\t\tthis.hideSelectDropDown(true);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// SetUp list dimensions and layout - account for container padding\n\t\t\t// Use position to check above or below available space\n\t\t\tif (this._dropDownPosition === AnchorPosition.BELOW) {\n\t\t\t\tif (this._isVisible && maxVisibleOptionsBelow + maxVisibleOptionsAbove < 1) {\n\t\t\t\t\t// If drop-down is visible, must be doing a DOM re-layout, hide since we don't fit\n\t\t\t\t\t// Hide drop-down, hide contextview, focus on parent select\n\t\t\t\t\tthis.hideSelectDropDown(true);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Adjust list height to max from select bottom to margin (default/minBottomMargin)\n\t\t\t\tif (minRequiredDropDownHeight > maxSelectDropDownHeightBelow) {\n\t\t\t\t\tlistHeight = (maxVisibleOptionsBelow * this.getHeight());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (minRequiredDropDownHeight > maxSelectDropDownHeightAbove) {\n\t\t\t\t\tlistHeight = (maxVisibleOptionsAbove * this.getHeight());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set adjusted list height and relayout\n\t\t\tthis.selectList.layout(listHeight);\n\t\t\tthis.selectList.domFocus();\n\n\t\t\t// Finally set focus on selected item\n\t\t\tif (this.selectList.length > 0) {\n\t\t\t\tthis.selectList.setFocus([this.selected || 0]);\n\t\t\t\tthis.selectList.reveal(this.selectList.getFocus()[0] || 0);\n\t\t\t}\n\n\t\t\tif (this.detailsProvider) {\n\t\t\t\t// Leave the selectDropDownContainer to size itself according to children (list + details) - #57447\n\t\t\t\tthis.selectList.getHTMLElement().style.height = (listHeight + verticalPadding) + 'px';\n\t\t\t} else {\n\t\t\t\tthis.selectDropDownContainer.style.height = (listHeight + verticalPadding) + 'px';\n\t\t\t}\n\n\t\t\tthis.selectDropDownContainer.style.width = selectOptimalWidth;\n\n\t\t\t// Maintain focus outline on parent select as well as list container - tabindex for focus\n\t\t\tthis.selectDropDownListContainer.setAttribute('tabindex', '0');\n\t\t\tdom.toggleClass(this.selectElement, 'synthetic-focus', true);\n\t\t\tdom.toggleClass(this.selectDropDownContainer, 'synthetic-focus', true);\n\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate setWidthControlElement(container: HTMLElement): number {\n\t\tlet elementWidth = 0;\n\n\t\tif (container && !!this.options) {\n\t\t\tlet longest = 0;\n\n\t\t\tfor (let index = 0; index < this.options.length; index++) {\n\t\t\t\tif (this.options[index].length > this.options[longest].length) {\n\t\t\t\t\tlongest = index;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcontainer.innerHTML = this.options[longest];\n\t\t\telementWidth = dom.getTotalWidth(container);\n\t\t}\n\n\t\treturn elementWidth;\n\t}\n\n\tprivate cloneElementFont(source: HTMLElement, target: HTMLElement) {\n\t\tconst fontSize = window.getComputedStyle(source, null).getPropertyValue('font-size');\n\t\tconst fontFamily = window.getComputedStyle(source, null).getPropertyValue('font-family');\n\t\ttarget.style.fontFamily = fontFamily;\n\t\ttarget.style.fontSize = fontSize;\n\t}\n\n\tprivate createSelectList(parent: HTMLElement): void {\n\n\t\t// If we have already constructive list on open, skip\n\t\tif (this.selectList) {\n\t\t\treturn;\n\t\t}\n\n\t\t// SetUp container for list\n\t\tthis.selectDropDownListContainer = dom.append(parent, $('.select-box-dropdown-list-container'));\n\n\t\tthis.listRenderer = new SelectListRenderer();\n\n\t\tthis.selectList = new List(this.selectDropDownListContainer, this, [this.listRenderer], {\n\t\t\tariaLabel: this.selectBoxOptions.ariaLabel,\n\t\t\tuseShadows: false,\n\t\t\tselectOnMouseDown: false,\n\t\t\tverticalScrollMode: ScrollbarVisibility.Visible,\n\t\t\tkeyboardSupport: false,\n\t\t\tmouseSupport: false\n\t\t});\n\n\t\t// SetUp list keyboard controller - control navigation, disabled items, focus\n\t\tconst onSelectDropDownKeyDown = chain(domEvent(this.selectDropDownListContainer, 'keydown'))\n\t\t\t.filter(() => this.selectList.length > 0)\n\t\t\t.map(e => new StandardKeyboardEvent(e));\n\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.Enter).on(e => this.onEnter(e), this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.Escape).on(e => this.onEscape(e), this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.UpArrow).on(this.onUpArrow, this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.DownArrow).on(this.onDownArrow, this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.PageDown).on(this.onPageDown, this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.PageUp).on(this.onPageUp, this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.Home).on(this.onHome, this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.End).on(this.onEnd, this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => (e.keyCode >= KeyCode.KEY_0 && e.keyCode <= KeyCode.KEY_Z) || (e.keyCode >= KeyCode.US_SEMICOLON && e.keyCode <= KeyCode.NUMPAD_DIVIDE)).on(this.onCharacter, this, this.toDispose);\n\n\t\t// SetUp list mouse controller - control navigation, disabled items, focus\n\n\t\tchain(domEvent(this.selectList.getHTMLElement(), 'mouseup'))\n\t\t\t.filter(() => this.selectList.length > 0)\n\t\t\t.on(e => this.onMouseUp(e), this, this.toDispose);\n\n\t\tthis.toDispose.push(\n\t\t\tthis.selectList.onDidBlur(_ => this.onListBlur()),\n\t\t\tthis.selectList.onMouseOver(e => typeof e.index !== 'undefined' && this.selectList.setFocus([e.index])),\n\t\t\tthis.selectList.onFocusChange(e => this.onListFocus(e))\n\t\t);\n\n\t\tthis.selectList.getHTMLElement().setAttribute('aria-label', this.selectBoxOptions.ariaLabel || '');\n\t\tthis.selectList.getHTMLElement().setAttribute('aria-expanded', 'true');\n\n\t\tthis.styleList();\n\t}\n\n\t// List methods\n\n\t// List mouse controller - active exit, select option, fire onDidSelect if change, return focus to parent select\n\tprivate onMouseUp(e: MouseEvent): void {\n\n\t\tdom.EventHelper.stop(e);\n\n\t\t// Check our mouse event is on an option (not scrollbar)\n\t\tif (!e.toElement.classList.contains('option-text')) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst listRowElement = e.toElement.parentElement;\n\t\tif (!listRowElement) {\n\t\t\treturn;\n\t\t}\n\t\tconst index = Number(listRowElement.getAttribute('data-index'));\n\t\tconst disabled = listRowElement.classList.contains('option-disabled');\n\n\t\t// Ignore mouse selection of disabled options\n\t\tif (index >= 0 && index < this.options.length && !disabled) {\n\t\t\tthis.selected = index;\n\t\t\tthis.select(this.selected);\n\n\t\t\tthis.selectList.setFocus([this.selected]);\n\t\t\tthis.selectList.reveal(this.selectList.getFocus()[0]);\n\n\t\t\t// Only fire if selection change\n\t\t\tif (this.selected !== this._currentSelection) {\n\t\t\t\t// Set current = selected\n\t\t\t\tthis._currentSelection = this.selected;\n\n\t\t\t\tthis._onDidSelect.fire({\n\t\t\t\t\tindex: this.selectElement.selectedIndex,\n\t\t\t\t\tselected: this.options[this.selected]\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthis.hideSelectDropDown(true);\n\t\t}\n\t}\n\n\t// List Exit - passive - implicit no selection change, hide drop-down\n\tprivate onListBlur(): void {\n\t\tif (this._sticky) { return; }\n\t\tif (this.selected !== this._currentSelection) {\n\t\t\t// Reset selected to current if no change\n\t\t\tthis.select(this._currentSelection);\n\t\t}\n\n\t\tthis.hideSelectDropDown(false);\n\t}\n\n\n\tprivate renderDescriptionMarkdown(text: string): HTMLElement {\n\t\tconst cleanRenderedMarkdown = (element: Node) => {\n\t\t\tfor (let i = 0; i < element.childNodes.length; i++) {\n\t\t\t\tconst child = element.childNodes.item(i);\n\n\t\t\t\tconst tagName = (<Element>child).tagName && (<Element>child).tagName.toLowerCase();\n\t\t\t\tif (tagName === 'img') {\n\t\t\t\t\telement.removeChild(child);\n\t\t\t\t} else {\n\t\t\t\t\tcleanRenderedMarkdown(child);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tconst renderedMarkdown = renderMarkdown({ value: text }, {\n\t\t\tactionHandler: this.selectBoxOptions.markdownActionHandler\n\t\t});\n\n\t\trenderedMarkdown.classList.add('select-box-description-markdown');\n\t\tcleanRenderedMarkdown(renderedMarkdown);\n\n\t\treturn renderedMarkdown;\n\t}\n\n\t// List Focus Change - passive - update details pane with newly focused element's data\n\tprivate onListFocus(e: IListEvent<ISelectOptionItem>) {\n\t\t// Skip during initial layout\n\t\tif (!this._isVisible) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.selectionDetailsPane.innerText = '';\n\t\tconst selectedIndex = e.indexes[0];\n\t\tlet description = this.detailsProvider ? this.detailsProvider(selectedIndex) : { details: '', isMarkdown: false };\n\t\tif (description.details) {\n\t\t\tif (description.isMarkdown) {\n\t\t\t\tthis.selectionDetailsPane.appendChild(this.renderDescriptionMarkdown(description.details));\n\t\t\t} else {\n\t\t\t\tthis.selectionDetailsPane.innerText = description.details;\n\t\t\t}\n\t\t\tthis.selectionDetailsPane.style.display = 'block';\n\t\t} else {\n\t\t\tthis.selectionDetailsPane.style.display = 'none';\n\t\t}\n\n\t\t// Avoid recursion\n\t\tthis._skipLayout = true;\n\t\tthis.contextViewProvider.layout();\n\t\tthis._skipLayout = false;\n\n\t}\n\n\t// List keyboard controller\n\n\t// List exit - active - hide ContextView dropdown, reset selection, return focus to parent select\n\tprivate onEscape(e: StandardKeyboardEvent): void {\n\t\tdom.EventHelper.stop(e);\n\n\t\t// Reset selection to value when opened\n\t\tthis.select(this._currentSelection);\n\t\tthis.hideSelectDropDown(true);\n\t}\n\n\t// List exit - active - hide ContextView dropdown, return focus to parent select, fire onDidSelect if change\n\tprivate onEnter(e: StandardKeyboardEvent): void {\n\t\tdom.EventHelper.stop(e);\n\n\t\t// Only fire if selection change\n\t\tif (this.selected !== this._currentSelection) {\n\t\t\tthis._currentSelection = this.selected;\n\t\t\tthis._onDidSelect.fire({\n\t\t\t\tindex: this.selectElement.selectedIndex,\n\t\t\t\tselected: this.options[this.selected]\n\t\t\t});\n\t\t}\n\n\t\tthis.hideSelectDropDown(true);\n\t}\n\n\t// List navigation - have to handle a disabled option (jump over)\n\tprivate onDownArrow(): void {\n\t\tif (this.selected < this.options.length - 1) {\n\t\t\t// Skip disabled options\n\t\t\tif ((this.selected + 1) === this.disabledOptionIndex && this.options.length > this.selected + 2) {\n\t\t\t\tthis.selected += 2;\n\t\t\t} else if ((this.selected + 1) === this.disabledOptionIndex) {\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tthis.selected++;\n\t\t\t}\n\t\t\t// Set focus/selection - only fire event when closing drop-down or on blur\n\t\t\tthis.select(this.selected);\n\t\t\tthis.selectList.setFocus([this.selected]);\n\t\t\tthis.selectList.reveal(this.selectList.getFocus()[0]);\n\t\t}\n\t}\n\n\tprivate onUpArrow(): void {\n\t\tif (this.selected > 0) {\n\t\t\t// Skip disabled options\n\t\t\tif ((this.selected - 1) === this.disabledOptionIndex && this.selected > 1) {\n\t\t\t\tthis.selected -= 2;\n\t\t\t} else {\n\t\t\t\tthis.selected--;\n\t\t\t}\n\t\t\t// Set focus/selection - only fire event when closing drop-down or on blur\n\t\t\tthis.select(this.selected);\n\t\t\tthis.selectList.setFocus([this.selected]);\n\t\t\tthis.selectList.reveal(this.selectList.getFocus()[0]);\n\t\t}\n\t}\n\n\tprivate onPageUp(e: StandardKeyboardEvent): void {\n\t\tdom.EventHelper.stop(e);\n\n\t\tthis.selectList.focusPreviousPage();\n\n\t\t// Allow scrolling to settle\n\t\tsetTimeout(() => {\n\t\t\tthis.selected = this.selectList.getFocus()[0];\n\n\t\t\t// Shift selection down if we land on a disabled option\n\t\t\tif (this.selected === this.disabledOptionIndex && this.selected < this.options.length - 1) {\n\t\t\t\tthis.selected++;\n\t\t\t\tthis.selectList.setFocus([this.selected]);\n\t\t\t}\n\t\t\tthis.selectList.reveal(this.selected);\n\t\t\tthis.select(this.selected);\n\t\t}, 1);\n\t}\n\n\tprivate onPageDown(e: StandardKeyboardEvent): void {\n\t\tdom.EventHelper.stop(e);\n\n\t\tthis.selectList.focusNextPage();\n\n\t\t// Allow scrolling to settle\n\t\tsetTimeout(() => {\n\t\t\tthis.selected = this.selectList.getFocus()[0];\n\n\t\t\t// Shift selection up if we land on a disabled option\n\t\t\tif (this.selected === this.disabledOptionIndex && this.selected > 0) {\n\t\t\t\tthis.selected--;\n\t\t\t\tthis.selectList.setFocus([this.selected]);\n\t\t\t}\n\t\t\tthis.selectList.reveal(this.selected);\n\t\t\tthis.select(this.selected);\n\t\t}, 1);\n\t}\n\n\tprivate onHome(e: StandardKeyboardEvent): void {\n\t\tdom.EventHelper.stop(e);\n\n\t\tif (this.options.length < 2) {\n\t\t\treturn;\n\t\t}\n\t\tthis.selected = 0;\n\t\tif (this.selected === this.disabledOptionIndex && this.selected > 1) {\n\t\t\tthis.selected++;\n\t\t}\n\t\tthis.selectList.setFocus([this.selected]);\n\t\tthis.selectList.reveal(this.selected);\n\t\tthis.select(this.selected);\n\t}\n\n\tprivate onEnd(e: StandardKeyboardEvent): void {\n\t\tdom.EventHelper.stop(e);\n\n\t\tif (this.options.length < 2) {\n\t\t\treturn;\n\t\t}\n\t\tthis.selected = this.options.length - 1;\n\t\tif (this.selected === this.disabledOptionIndex && this.selected > 1) {\n\t\t\tthis.selected--;\n\t\t}\n\t\tthis.selectList.setFocus([this.selected]);\n\t\tthis.selectList.reveal(this.selected);\n\t\tthis.select(this.selected);\n\t}\n\n\t// Mimic option first character navigation of native select\n\tprivate onCharacter(e: StandardKeyboardEvent): void {\n\t\tconst ch = KeyCodeUtils.toString(e.keyCode);\n\t\tlet optionIndex = -1;\n\n\t\tfor (let i = 0; i < this.options.length - 1; i++) {\n\t\t\toptionIndex = (i + this.selected + 1) % this.options.length;\n\t\t\tif (this.options[optionIndex].charAt(0).toUpperCase() === ch) {\n\t\t\t\tthis.select(optionIndex);\n\t\t\t\tthis.selectList.setFocus([optionIndex]);\n\t\t\t\tthis.selectList.reveal(this.selectList.getFocus()[0]);\n\t\t\t\tdom.EventHelper.stop(e);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic dispose(): void {\n\t\tthis.hideSelectDropDown(false);\n\t\tthis.toDispose = dispose(this.toDispose);\n\t}\n}\n",
            "linguagem": "ts",
            "total_linhas": 1050
        },
        "solucao_humana": {
            "patch_diff": "@@ -114,7 +114,7 @@ export class SelectBoxList implements ISelectBoxDelegate, IListVirtualDelegate<I\n \tprivate selectionDetailsPane: HTMLElement;\n \tprivate _skipLayout: boolean = false;\n \n-\tprivate _sticky: boolean = true; // for dev purposes only\n+\tprivate _sticky: boolean = false; // for dev purposes only\n \n \tconstructor(options: string[], selected: number, contextViewProvider: IContextViewProvider, styles: ISelectBoxStyles, selectBoxOptions?: ISelectBoxOptions) {\n ",
            "apenas_linhas_adicionadas": [
                "\tprivate _sticky: boolean = false; // for dev purposes only"
            ]
        }
    },
    {
        "id": 74430,
        "url": "https://github.com/microsoft/vscode/pull/74430",
        "arquivo_caminho": "src/vs/base/browser/ui/selectBox/selectBoxCustom.ts",
        "descricao_bug": "Restores title attribute for custom SelectBox.\r\nFixes: #73844 \r\n\r\nNote: Screen readers will typically announce both the aria-label and the title attribute.\r\nGiven these are always the same it is redundant but, unavoidable without some unknown\r\nmethod to disable reading the title.  \r\n",
        "contexto": {
            "codigo_completo_bugado": "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport 'vs/css!./selectBoxCustom';\n\nimport { IDisposable, dispose } from 'vs/base/common/lifecycle';\nimport { Event, Emitter } from 'vs/base/common/event';\nimport { KeyCode, KeyCodeUtils } from 'vs/base/common/keyCodes';\nimport { StandardKeyboardEvent } from 'vs/base/browser/keyboardEvent';\nimport * as dom from 'vs/base/browser/dom';\nimport * as arrays from 'vs/base/common/arrays';\nimport { IContextViewProvider, AnchorPosition } from 'vs/base/browser/ui/contextview/contextview';\nimport { List } from 'vs/base/browser/ui/list/listWidget';\nimport { IListVirtualDelegate, IListRenderer, IListEvent } from 'vs/base/browser/ui/list/list';\nimport { domEvent } from 'vs/base/browser/event';\nimport { ScrollbarVisibility } from 'vs/base/common/scrollable';\nimport { ISelectBoxDelegate, ISelectOptionItem, ISelectBoxOptions, ISelectBoxStyles, ISelectData } from 'vs/base/browser/ui/selectBox/selectBox';\nimport { isMacintosh } from 'vs/base/common/platform';\nimport { renderMarkdown } from 'vs/base/browser/htmlContentRenderer';\n\nconst $ = dom.$;\n\nconst SELECT_OPTION_ENTRY_TEMPLATE_ID = 'selectOption.entry.template';\n\ninterface ISelectListTemplateData {\n\troot: HTMLElement;\n\ttext: HTMLElement;\n\titemDescription: HTMLElement;\n\tdecoratorRight: HTMLElement;\n\tdisposables: IDisposable[];\n}\n\nclass SelectListRenderer implements IListRenderer<ISelectOptionItem, ISelectListTemplateData> {\n\n\tget templateId(): string { return SELECT_OPTION_ENTRY_TEMPLATE_ID; }\n\n\tconstructor() { }\n\n\trenderTemplate(container: HTMLElement): ISelectListTemplateData {\n\t\tconst data: ISelectListTemplateData = Object.create(null);\n\t\tdata.disposables = [];\n\t\tdata.root = container;\n\t\tdata.text = dom.append(container, $('.option-text'));\n\t\tdata.decoratorRight = dom.append(container, $('.option-decorator-right'));\n\t\tdata.itemDescription = dom.append(container, $('.option-text-description'));\n\t\tdom.addClass(data.itemDescription, 'visually-hidden');\n\n\t\treturn data;\n\t}\n\n\trenderElement(element: ISelectOptionItem, index: number, templateData: ISelectListTemplateData): void {\n\t\tconst data: ISelectListTemplateData = templateData;\n\t\tconst text = element.text;\n\t\tconst decoratorRight = element.decoratorRight;\n\t\tconst isDisabled = element.isDisabled;\n\n\t\tdata.text.textContent = text;\n\t\tdata.decoratorRight.innerText = (!!decoratorRight ? decoratorRight : '');\n\n\t\tif (typeof element.description === 'string') {\n\t\t\tconst itemDescriptionId = (text.replace(/ /g, '_').toLowerCase() + '_description_' + data.root.id);\n\t\t\tdata.text.setAttribute('aria-describedby', itemDescriptionId);\n\t\t\tdata.itemDescription.id = itemDescriptionId;\n\t\t\tdata.itemDescription.innerText = element.description;\n\t\t}\n\n\t\t// pseudo-select disabled option\n\t\tif (isDisabled) {\n\t\t\tdom.addClass(data.root, 'option-disabled');\n\t\t} else {\n\t\t\t// Make sure we do class removal from prior template rendering\n\t\t\tdom.removeClass(data.root, 'option-disabled');\n\t\t}\n\t}\n\n\tdisposeTemplate(templateData: ISelectListTemplateData): void {\n\t\ttemplateData.disposables = dispose(templateData.disposables);\n\t}\n}\n\nexport class SelectBoxList implements ISelectBoxDelegate, IListVirtualDelegate<ISelectOptionItem> {\n\n\tprivate static readonly DEFAULT_DROPDOWN_MINIMUM_BOTTOM_MARGIN = 32;\n\tprivate static readonly DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN = 2;\n\tprivate static readonly DEFAULT_MINIMUM_VISIBLE_OPTIONS = 3;\n\n\tprivate _isVisible: boolean;\n\tprivate selectBoxOptions: ISelectBoxOptions;\n\tprivate selectElement: HTMLSelectElement;\n\tprivate options: ISelectOptionItem[];\n\tprivate selected: number;\n\tprivate readonly _onDidSelect: Emitter<ISelectData>;\n\tprivate toDispose: IDisposable[];\n\tprivate styles: ISelectBoxStyles;\n\tprivate listRenderer: SelectListRenderer;\n\tprivate contextViewProvider: IContextViewProvider;\n\tprivate selectDropDownContainer: HTMLElement;\n\tprivate styleElement: HTMLStyleElement;\n\tprivate selectList: List<ISelectOptionItem>;\n\tprivate selectDropDownListContainer: HTMLElement;\n\tprivate widthControlElement: HTMLElement;\n\tprivate _currentSelection: number;\n\tprivate _dropDownPosition: AnchorPosition;\n\tprivate _hasDetails: boolean = false;\n\tprivate selectionDetailsPane: HTMLElement;\n\tprivate _skipLayout: boolean = false;\n\n\tprivate _sticky: boolean = false; // for dev purposes only\n\n\tconstructor(options: ISelectOptionItem[], selected: number, contextViewProvider: IContextViewProvider, styles: ISelectBoxStyles, selectBoxOptions?: ISelectBoxOptions) {\n\n\t\tthis.toDispose = [];\n\t\tthis._isVisible = false;\n\t\tthis.selectBoxOptions = selectBoxOptions || Object.create(null);\n\n\t\tif (typeof this.selectBoxOptions.minBottomMargin !== 'number') {\n\t\t\tthis.selectBoxOptions.minBottomMargin = SelectBoxList.DEFAULT_DROPDOWN_MINIMUM_BOTTOM_MARGIN;\n\t\t} else if (this.selectBoxOptions.minBottomMargin < 0) {\n\t\t\tthis.selectBoxOptions.minBottomMargin = 0;\n\t\t}\n\n\t\tthis.selectElement = document.createElement('select');\n\n\t\t// Use custom CSS vars for padding calculation\n\t\tthis.selectElement.className = 'monaco-select-box monaco-select-box-dropdown-padding';\n\n\t\tif (typeof this.selectBoxOptions.ariaLabel === 'string') {\n\t\t\tthis.selectElement.setAttribute('aria-label', this.selectBoxOptions.ariaLabel);\n\t\t}\n\n\t\tthis._onDidSelect = new Emitter<ISelectData>();\n\t\tthis.toDispose.push(this._onDidSelect);\n\n\t\tthis.styles = styles;\n\n\t\tthis.registerListeners();\n\t\tthis.constructSelectDropDown(contextViewProvider);\n\n\t\tthis.selected = selected || 0;\n\n\t\tif (options) {\n\t\t\tthis.setOptions(options, selected);\n\t\t}\n\n\t}\n\n\t// IDelegate - List renderer\n\n\tgetHeight(): number {\n\t\treturn 18;\n\t}\n\n\tgetTemplateId(): string {\n\t\treturn SELECT_OPTION_ENTRY_TEMPLATE_ID;\n\t}\n\n\tprivate constructSelectDropDown(contextViewProvider: IContextViewProvider) {\n\n\t\t// SetUp ContextView container to hold select Dropdown\n\t\tthis.contextViewProvider = contextViewProvider;\n\t\tthis.selectDropDownContainer = dom.$('.monaco-select-box-dropdown-container');\n\t\t// Use custom CSS vars for padding calculation (shared with parent select)\n\t\tdom.addClass(this.selectDropDownContainer, 'monaco-select-box-dropdown-padding');\n\n\t\t// Setup container for select option details\n\t\tthis.selectionDetailsPane = dom.append(this.selectDropDownContainer, $('.select-box-details-pane'));\n\n\t\t// Create span flex box item/div we can measure and control\n\t\tlet widthControlOuterDiv = dom.append(this.selectDropDownContainer, $('.select-box-dropdown-container-width-control'));\n\t\tlet widthControlInnerDiv = dom.append(widthControlOuterDiv, $('.width-control-div'));\n\t\tthis.widthControlElement = document.createElement('span');\n\t\tthis.widthControlElement.className = 'option-text-width-control';\n\t\tdom.append(widthControlInnerDiv, this.widthControlElement);\n\n\t\t// Always default to below position\n\t\tthis._dropDownPosition = AnchorPosition.BELOW;\n\n\t\t// Inline stylesheet for themes\n\t\tthis.styleElement = dom.createStyleSheet(this.selectDropDownContainer);\n\t}\n\n\tprivate registerListeners() {\n\n\t\t// Parent native select keyboard listeners\n\n\t\tthis.toDispose.push(dom.addStandardDisposableListener(this.selectElement, 'change', (e) => {\n\t\t\tthis.selected = e.target.selectedIndex;\n\t\t\tthis._onDidSelect.fire({\n\t\t\t\tindex: e.target.selectedIndex,\n\t\t\t\tselected: e.target.value\n\t\t\t});\n\t\t}));\n\n\t\t// Have to implement both keyboard and mouse controllers to handle disabled options\n\t\t// Intercept mouse events to override normal select actions on parents\n\n\t\tthis.toDispose.push(dom.addDisposableListener(this.selectElement, dom.EventType.CLICK, (e) => {\n\t\t\tdom.EventHelper.stop(e);\n\n\t\t\tif (this._isVisible) {\n\t\t\t\tthis.hideSelectDropDown(true);\n\t\t\t} else {\n\t\t\t\tthis.showSelectDropDown();\n\t\t\t}\n\t\t}));\n\n\t\tthis.toDispose.push(dom.addDisposableListener(this.selectElement, dom.EventType.MOUSE_DOWN, (e) => {\n\t\t\tdom.EventHelper.stop(e);\n\t\t}));\n\n\t\t// Intercept keyboard handling\n\n\t\tthis.toDispose.push(dom.addDisposableListener(this.selectElement, dom.EventType.KEY_DOWN, (e: KeyboardEvent) => {\n\t\t\tconst event = new StandardKeyboardEvent(e);\n\t\t\tlet showDropDown = false;\n\n\t\t\t// Create and drop down select list on keyboard select\n\t\t\tif (isMacintosh) {\n\t\t\t\tif (event.keyCode === KeyCode.DownArrow || event.keyCode === KeyCode.UpArrow || event.keyCode === KeyCode.Space || event.keyCode === KeyCode.Enter) {\n\t\t\t\t\tshowDropDown = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (event.keyCode === KeyCode.DownArrow && event.altKey || event.keyCode === KeyCode.UpArrow && event.altKey || event.keyCode === KeyCode.Space || event.keyCode === KeyCode.Enter) {\n\t\t\t\t\tshowDropDown = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (showDropDown) {\n\t\t\t\tthis.showSelectDropDown();\n\t\t\t\tdom.EventHelper.stop(e);\n\t\t\t}\n\t\t}));\n\t}\n\n\tpublic get onDidSelect(): Event<ISelectData> {\n\t\treturn this._onDidSelect.event;\n\t}\n\n\tpublic setOptions(options: ISelectOptionItem[], selected?: number): void {\n\t\tif (!this.options || !arrays.equals(this.options, options)) {\n\t\t\tthis.options = options;\n\t\t\tthis.selectElement.options.length = 0;\n\t\t\tthis._hasDetails = false;\n\n\t\t\tthis.options.forEach((option, index) => {\n\t\t\t\tthis.selectElement.add(this.createOption(option.text, index, option.isDisabled));\n\t\t\t\tif (typeof option.description === 'string') {\n\t\t\t\t\tthis._hasDetails = true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tif (selected !== undefined) {\n\t\t\tthis.select(selected);\n\t\t\t// Set current = selected since this is not necessarily a user exit\n\t\t\tthis._currentSelection = this.selected;\n\t\t}\n\t}\n\n\n\tprivate setOptionsList() {\n\n\t\t// Mirror options in drop-down\n\t\t// Populate select list for non-native select mode\n\t\tif (this.selectList && !!this.options) {\n\t\t\tthis.selectList.splice(0, this.selectList.length, this.options);\n\t\t}\n\t}\n\n\tpublic select(index: number): void {\n\n\t\tif (index >= 0 && index < this.options.length) {\n\t\t\tthis.selected = index;\n\t\t} else if (index > this.options.length - 1) {\n\t\t\t// Adjust index to end of list\n\t\t\t// This could make client out of sync with the select\n\t\t\tthis.select(this.options.length - 1);\n\t\t} else if (this.selected < 0) {\n\t\t\tthis.selected = 0;\n\t\t}\n\n\t\tthis.selectElement.selectedIndex = this.selected;\n\t}\n\n\tpublic setAriaLabel(label: string): void {\n\t\tthis.selectBoxOptions.ariaLabel = label;\n\t\tthis.selectElement.setAttribute('aria-label', this.selectBoxOptions.ariaLabel);\n\t}\n\n\tpublic focus(): void {\n\t\tif (this.selectElement) {\n\t\t\tthis.selectElement.focus();\n\t\t}\n\t}\n\n\tpublic blur(): void {\n\t\tif (this.selectElement) {\n\t\t\tthis.selectElement.blur();\n\t\t}\n\t}\n\n\tpublic render(container: HTMLElement): void {\n\t\tdom.addClass(container, 'select-container');\n\t\tcontainer.appendChild(this.selectElement);\n\t\tthis.applyStyles();\n\t}\n\n\tpublic style(styles: ISelectBoxStyles): void {\n\n\t\tconst content: string[] = [];\n\n\t\tthis.styles = styles;\n\n\t\t// Style non-native select mode\n\n\t\tif (this.styles.listFocusBackground) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.focused { background-color: ${this.styles.listFocusBackground} !important; }`);\n\t\t}\n\n\t\tif (this.styles.listFocusForeground) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.focused:not(:hover) { color: ${this.styles.listFocusForeground} !important; }`);\n\t\t}\n\n\t\tif (this.styles.decoratorRightForeground) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row .option-decorator-right { color: ${this.styles.decoratorRightForeground} !important; }`);\n\t\t}\n\n\t\tif (this.styles.selectBackground && this.styles.selectBorder && !this.styles.selectBorder.equals(this.styles.selectBackground)) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container { border: 1px solid ${this.styles.selectBorder} } `);\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-details-pane.border-top { border-top: 1px solid ${this.styles.selectBorder} } `);\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-details-pane.border-bottom { border-bottom: 1px solid ${this.styles.selectBorder} } `);\n\n\t\t}\n\t\telse if (this.styles.selectListBorder) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-details-pane.border-top { border-top: 1px solid ${this.styles.selectListBorder} } `);\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-details-pane.border-bottom { border-bottom: 1px solid ${this.styles.selectListBorder} } `);\n\t\t}\n\n\t\t// Hover foreground - ignore for disabled options\n\t\tif (this.styles.listHoverForeground) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:hover { color: ${this.styles.listHoverForeground} !important; }`);\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.option-disabled:hover { background-color: ${this.styles.listActiveSelectionForeground} !important; }`);\n\t\t}\n\n\t\t// Hover background - ignore for disabled options\n\t\tif (this.styles.listHoverBackground) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:not(.option-disabled):not(.focused):hover { background-color: ${this.styles.listHoverBackground} !important; }`);\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.option-disabled:hover { background-color: ${this.styles.selectBackground} !important; }`);\n\t\t}\n\n\t\t// Match quickOpen outline styles - ignore for disabled options\n\t\tif (this.styles.listFocusOutline) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.focused { outline: 1.6px dotted ${this.styles.listFocusOutline} !important; outline-offset: -1.6px !important; }`);\n\n\t\t}\n\n\t\tif (this.styles.listHoverOutline) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:hover:not(.focused) { outline: 1.6px dashed ${this.styles.listHoverOutline} !important; outline-offset: -1.6px !important; }`);\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.option-disabled:hover { outline: none !important; }`);\n\t\t}\n\n\t\tthis.styleElement.innerHTML = content.join('\\n');\n\n\t\tthis.applyStyles();\n\t}\n\n\tpublic applyStyles(): void {\n\n\t\t// Style parent select\n\n\t\tif (this.selectElement) {\n\t\t\tconst background = this.styles.selectBackground ? this.styles.selectBackground.toString() : null;\n\t\t\tconst foreground = this.styles.selectForeground ? this.styles.selectForeground.toString() : null;\n\t\t\tconst border = this.styles.selectBorder ? this.styles.selectBorder.toString() : null;\n\n\t\t\tthis.selectElement.style.backgroundColor = background;\n\t\t\tthis.selectElement.style.color = foreground;\n\t\t\tthis.selectElement.style.borderColor = border;\n\t\t}\n\n\t\t// Style drop down select list (non-native mode only)\n\n\t\tif (this.selectList) {\n\t\t\tthis.styleList();\n\t\t}\n\t}\n\n\tprivate styleList() {\n\t\tif (this.selectList) {\n\t\t\tlet background = this.styles.selectBackground ? this.styles.selectBackground.toString() : null;\n\t\t\tthis.selectList.style({});\n\n\t\t\tlet listBackground = this.styles.selectListBackground ? this.styles.selectListBackground.toString() : background;\n\t\t\tthis.selectDropDownListContainer.style.backgroundColor = listBackground;\n\t\t\tthis.selectionDetailsPane.style.backgroundColor = listBackground;\n\t\t\tconst optionsBorder = this.styles.focusBorder ? this.styles.focusBorder.toString() : null;\n\t\t\tthis.selectDropDownContainer.style.outlineColor = optionsBorder;\n\t\t\tthis.selectDropDownContainer.style.outlineOffset = '-1px';\n\t\t}\n\t}\n\n\tprivate createOption(value: string, index: number, disabled?: boolean): HTMLOptionElement {\n\t\tlet option = document.createElement('option');\n\t\toption.value = value;\n\t\toption.text = value;\n\t\toption.disabled = !!disabled;\n\n\t\treturn option;\n\t}\n\n\t// ContextView dropdown methods\n\n\tprivate showSelectDropDown() {\n\t\tthis.selectionDetailsPane.innerText = '';\n\n\t\tif (!this.contextViewProvider || this._isVisible) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Lazily create and populate list only at open, moved from constructor\n\t\tthis.createSelectList(this.selectDropDownContainer);\n\t\tthis.setOptionsList();\n\n\t\t// This allows us to flip the position based on measurement\n\t\t// Set drop-down position above/below from required height and margins\n\t\t// If pre-layout cannot fit at least one option do not show drop-down\n\n\t\tthis.contextViewProvider.showContextView({\n\t\t\tgetAnchor: () => this.selectElement,\n\t\t\trender: (container: HTMLElement) => this.renderSelectDropDown(container, true),\n\t\t\tlayout: () => {\n\t\t\t\tthis.layoutSelectDropDown();\n\t\t\t},\n\t\t\tonHide: () => {\n\t\t\t\tdom.toggleClass(this.selectDropDownContainer, 'visible', false);\n\t\t\t\tdom.toggleClass(this.selectElement, 'synthetic-focus', false);\n\t\t\t},\n\t\t\tanchorPosition: this._dropDownPosition\n\t\t});\n\n\t\t// Hide so we can relay out\n\t\tthis._isVisible = true;\n\t\tthis.hideSelectDropDown(false);\n\n\t\tthis.contextViewProvider.showContextView({\n\t\t\tgetAnchor: () => this.selectElement,\n\t\t\trender: (container: HTMLElement) => this.renderSelectDropDown(container),\n\t\t\tlayout: () => this.layoutSelectDropDown(),\n\t\t\tonHide: () => {\n\t\t\t\tdom.toggleClass(this.selectDropDownContainer, 'visible', false);\n\t\t\t\tdom.toggleClass(this.selectElement, 'synthetic-focus', false);\n\t\t\t},\n\t\t\tanchorPosition: this._dropDownPosition\n\t\t});\n\n\t\t// Track initial selection the case user escape, blur\n\t\tthis._currentSelection = this.selected;\n\t\tthis._isVisible = true;\n\t}\n\n\tprivate hideSelectDropDown(focusSelect: boolean) {\n\t\tif (!this.contextViewProvider || !this._isVisible) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._isVisible = false;\n\n\t\tif (focusSelect) {\n\t\t\tthis.selectElement.focus();\n\t\t}\n\n\t\tthis.contextViewProvider.hideContextView();\n\t}\n\n\tprivate renderSelectDropDown(container: HTMLElement, preLayoutPosition?: boolean): IDisposable {\n\t\tcontainer.appendChild(this.selectDropDownContainer);\n\n\t\t// Pre-Layout allows us to change position\n\t\tthis.layoutSelectDropDown(preLayoutPosition);\n\n\t\treturn {\n\t\t\tdispose: () => {\n\t\t\t\t// contextView will dispose itself if moving from one View to another\n\t\t\t\ttry {\n\t\t\t\t\tcontainer.removeChild(this.selectDropDownContainer); // remove to take out the CSS rules we add\n\t\t\t\t}\n\t\t\t\tcatch (error) {\n\t\t\t\t\t// Ignore, removed already by change of focus\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\t// Iterate over detailed descriptions, find max height\n\tprivate measureMaxDetailsHeight(): number {\n\n\t\tlet maxDetailsPaneHeight = 0;\n\t\tthis.options.forEach((option, index) => {\n\n\t\t\tthis.selectionDetailsPane.innerText = '';\n\n\t\t\tif (option.description) {\n\t\t\t\tif (option.descriptionIsMarkdown) {\n\t\t\t\t\tthis.selectionDetailsPane.appendChild(this.renderDescriptionMarkdown(option.description));\n\t\t\t\t} else {\n\t\t\t\t\tthis.selectionDetailsPane.innerText = option.description;\n\t\t\t\t}\n\t\t\t\tthis.selectionDetailsPane.style.display = 'block';\n\t\t\t} else {\n\t\t\t\tthis.selectionDetailsPane.style.display = 'none';\n\t\t\t}\n\n\t\t\tif (this.selectionDetailsPane.offsetHeight > maxDetailsPaneHeight) {\n\t\t\t\tmaxDetailsPaneHeight = this.selectionDetailsPane.offsetHeight;\n\t\t\t}\n\t\t});\n\n\t\t// Reset description to selected\n\n\t\tthis.selectionDetailsPane.innerText = '';\n\t\tconst description = this.options[this.selected].description || null;\n\t\tconst descriptionIsMarkdown = this.options[this.selected].descriptionIsMarkdown || null;\n\n\t\tif (description) {\n\t\t\tif (descriptionIsMarkdown) {\n\t\t\t\tthis.selectionDetailsPane.appendChild(this.renderDescriptionMarkdown(description));\n\t\t\t} else {\n\t\t\t\tthis.selectionDetailsPane.innerText = description;\n\t\t\t}\n\t\t\tthis.selectionDetailsPane.style.display = 'block';\n\t\t}\n\t\treturn maxDetailsPaneHeight;\n\t}\n\n\tprivate layoutSelectDropDown(preLayoutPosition?: boolean): boolean {\n\n\t\t// Avoid recursion from layout called in onListFocus\n\t\tif (this._skipLayout) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Layout ContextView drop down select list and container\n\t\t// Have to manage our vertical overflow, sizing, position below or above\n\t\t// Position has to be determined and set prior to contextView instantiation\n\n\t\tif (this.selectList) {\n\n\t\t\t// Make visible to enable measurements\n\t\t\tdom.toggleClass(this.selectDropDownContainer, 'visible', true);\n\n\t\t\tconst selectPosition = dom.getDomNodePagePosition(this.selectElement);\n\t\t\tconst styles = getComputedStyle(this.selectElement);\n\t\t\tconst verticalPadding = parseFloat(styles.getPropertyValue('--dropdown-padding-top')) + parseFloat(styles.getPropertyValue('--dropdown-padding-bottom'));\n\t\t\tconst maxSelectDropDownHeightBelow = (window.innerHeight - selectPosition.top - selectPosition.height - (this.selectBoxOptions.minBottomMargin || 0));\n\t\t\tconst maxSelectDropDownHeightAbove = (selectPosition.top - SelectBoxList.DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN);\n\n\t\t\t// Determine optimal width - min(longest option), opt(parent select, excluding margins), max(ContextView controlled)\n\t\t\tconst selectWidth = this.selectElement.offsetWidth;\n\t\t\tconst selectMinWidth = this.setWidthControlElement(this.widthControlElement);\n\t\t\tconst selectOptimalWidth = Math.max(selectMinWidth, Math.round(selectWidth)).toString() + 'px';\n\n\t\t\tthis.selectDropDownContainer.style.width = selectOptimalWidth;\n\n\t\t\t// Get initial list height and determine space above and below\n\t\t\tthis.selectList.getHTMLElement().style.height = '';\n\t\t\tthis.selectList.layout();\n\t\t\tlet listHeight = this.selectList.contentHeight;\n\n\t\t\tconst maxDetailsPaneHeight = this._hasDetails ? this.measureMaxDetailsHeight() : 0;\n\n\t\t\tconst minRequiredDropDownHeight = listHeight + verticalPadding + maxDetailsPaneHeight;\n\t\t\tconst maxVisibleOptionsBelow = ((Math.floor((maxSelectDropDownHeightBelow - verticalPadding - maxDetailsPaneHeight) / this.getHeight())));\n\t\t\tconst maxVisibleOptionsAbove = ((Math.floor((maxSelectDropDownHeightAbove - verticalPadding - maxDetailsPaneHeight) / this.getHeight())));\n\n\t\t\t// If we are only doing pre-layout check/adjust position only\n\t\t\t// Calculate vertical space available, flip up if insufficient\n\t\t\t// Use reflected padding on parent select, ContextView style\n\t\t\t// properties not available before DOM attachment\n\n\t\t\tif (preLayoutPosition) {\n\n\t\t\t\t// Check if select moved out of viewport , do not open\n\t\t\t\t// If at least one option cannot be shown, don't open the drop-down or hide/remove if open\n\n\t\t\t\tif ((selectPosition.top + selectPosition.height) > (window.innerHeight - 22)\n\t\t\t\t\t|| selectPosition.top < SelectBoxList.DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN\n\t\t\t\t\t|| ((maxVisibleOptionsBelow < 1) && (maxVisibleOptionsAbove < 1))) {\n\t\t\t\t\t// Indicate we cannot open\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Determine if we have to flip up\n\t\t\t\t// Always show complete list items - never more than Max available vertical height\n\t\t\t\tif (maxVisibleOptionsBelow < SelectBoxList.DEFAULT_MINIMUM_VISIBLE_OPTIONS\n\t\t\t\t\t&& maxVisibleOptionsAbove > maxVisibleOptionsBelow\n\t\t\t\t\t&& this.options.length > maxVisibleOptionsBelow\n\t\t\t\t) {\n\t\t\t\t\tthis._dropDownPosition = AnchorPosition.ABOVE;\n\t\t\t\t\tthis.selectDropDownContainer.removeChild(this.selectDropDownListContainer);\n\t\t\t\t\tthis.selectDropDownContainer.removeChild(this.selectionDetailsPane);\n\t\t\t\t\tthis.selectDropDownContainer.appendChild(this.selectionDetailsPane);\n\t\t\t\t\tthis.selectDropDownContainer.appendChild(this.selectDropDownListContainer);\n\n\t\t\t\t\tdom.removeClass(this.selectionDetailsPane, 'border-top');\n\t\t\t\t\tdom.addClass(this.selectionDetailsPane, 'border-bottom');\n\n\t\t\t\t} else {\n\t\t\t\t\tthis._dropDownPosition = AnchorPosition.BELOW;\n\t\t\t\t\tthis.selectDropDownContainer.removeChild(this.selectDropDownListContainer);\n\t\t\t\t\tthis.selectDropDownContainer.removeChild(this.selectionDetailsPane);\n\t\t\t\t\tthis.selectDropDownContainer.appendChild(this.selectDropDownListContainer);\n\t\t\t\t\tthis.selectDropDownContainer.appendChild(this.selectionDetailsPane);\n\n\t\t\t\t\tdom.removeClass(this.selectionDetailsPane, 'border-bottom');\n\t\t\t\t\tdom.addClass(this.selectionDetailsPane, 'border-top');\n\t\t\t\t}\n\t\t\t\t// Do full layout on showSelectDropDown only\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// Check if select out of viewport or cutting into status bar\n\t\t\tif ((selectPosition.top + selectPosition.height) > (window.innerHeight - 22)\n\t\t\t\t|| selectPosition.top < SelectBoxList.DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN\n\t\t\t\t|| (this._dropDownPosition === AnchorPosition.BELOW && maxVisibleOptionsBelow < 1)\n\t\t\t\t|| (this._dropDownPosition === AnchorPosition.ABOVE && maxVisibleOptionsAbove < 1)) {\n\t\t\t\t// Cannot properly layout, close and hide\n\t\t\t\tthis.hideSelectDropDown(true);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// SetUp list dimensions and layout - account for container padding\n\t\t\t// Use position to check above or below available space\n\t\t\tif (this._dropDownPosition === AnchorPosition.BELOW) {\n\t\t\t\tif (this._isVisible && maxVisibleOptionsBelow + maxVisibleOptionsAbove < 1) {\n\t\t\t\t\t// If drop-down is visible, must be doing a DOM re-layout, hide since we don't fit\n\t\t\t\t\t// Hide drop-down, hide contextview, focus on parent select\n\t\t\t\t\tthis.hideSelectDropDown(true);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Adjust list height to max from select bottom to margin (default/minBottomMargin)\n\t\t\t\tif (minRequiredDropDownHeight > maxSelectDropDownHeightBelow) {\n\t\t\t\t\tlistHeight = (maxVisibleOptionsBelow * this.getHeight());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (minRequiredDropDownHeight > maxSelectDropDownHeightAbove) {\n\t\t\t\t\tlistHeight = (maxVisibleOptionsAbove * this.getHeight());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set adjusted list height and relayout\n\t\t\tthis.selectList.layout(listHeight);\n\t\t\tthis.selectList.domFocus();\n\n\t\t\t// Finally set focus on selected item\n\t\t\tif (this.selectList.length > 0) {\n\t\t\t\tthis.selectList.setFocus([this.selected || 0]);\n\t\t\t\tthis.selectList.reveal(this.selectList.getFocus()[0] || 0);\n\t\t\t}\n\n\t\t\tif (this._hasDetails) {\n\t\t\t\t// Leave the selectDropDownContainer to size itself according to children (list + details) - #57447\n\t\t\t\tthis.selectList.getHTMLElement().style.height = (listHeight + verticalPadding) + 'px';\n\t\t\t\tthis.selectDropDownContainer.style.height = '';\n\t\t\t} else {\n\t\t\t\tthis.selectDropDownContainer.style.height = (listHeight + verticalPadding) + 'px';\n\t\t\t}\n\n\t\t\tthis.selectDropDownContainer.style.width = selectOptimalWidth;\n\n\t\t\t// Maintain focus outline on parent select as well as list container - tabindex for focus\n\t\t\tthis.selectDropDownListContainer.setAttribute('tabindex', '0');\n\t\t\tdom.toggleClass(this.selectElement, 'synthetic-focus', true);\n\t\t\tdom.toggleClass(this.selectDropDownContainer, 'synthetic-focus', true);\n\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate setWidthControlElement(container: HTMLElement): number {\n\t\tlet elementWidth = 0;\n\n\t\tif (container && !!this.options) {\n\t\t\tlet longest = 0;\n\t\t\tlet longestLength = 0;\n\n\t\t\tthis.options.forEach((option, index) => {\n\t\t\t\tconst len = option.text.length + (!!option.decoratorRight ? option.decoratorRight.length : 0);\n\t\t\t\tif (len > longestLength) {\n\t\t\t\t\tlongest = index;\n\t\t\t\t\tlongestLength = len;\n\t\t\t\t}\n\t\t\t});\n\n\n\t\t\tcontainer.innerHTML = this.options[longest].text + (!!this.options[longest].decoratorRight ? (this.options[longest].decoratorRight + ' ') : '');\n\t\t\telementWidth = dom.getTotalWidth(container);\n\t\t}\n\n\t\treturn elementWidth;\n\t}\n\n\tprivate createSelectList(parent: HTMLElement): void {\n\n\t\t// If we have already constructive list on open, skip\n\t\tif (this.selectList) {\n\t\t\treturn;\n\t\t}\n\n\t\t// SetUp container for list\n\t\tthis.selectDropDownListContainer = dom.append(parent, $('.select-box-dropdown-list-container'));\n\n\t\tthis.listRenderer = new SelectListRenderer();\n\n\t\tthis.selectList = new List(this.selectDropDownListContainer, this, [this.listRenderer], {\n\t\t\tariaLabel: this.selectBoxOptions.ariaLabel,\n\t\t\tuseShadows: false,\n\t\t\tverticalScrollMode: ScrollbarVisibility.Visible,\n\t\t\tkeyboardSupport: false,\n\t\t\tmouseSupport: false\n\t\t});\n\n\t\t// SetUp list keyboard controller - control navigation, disabled items, focus\n\t\tconst onSelectDropDownKeyDown = Event.chain(domEvent(this.selectDropDownListContainer, 'keydown'))\n\t\t\t.filter(() => this.selectList.length > 0)\n\t\t\t.map(e => new StandardKeyboardEvent(e));\n\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.Enter).on(e => this.onEnter(e), this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.Escape).on(e => this.onEscape(e), this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.UpArrow).on(this.onUpArrow, this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.DownArrow).on(this.onDownArrow, this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.PageDown).on(this.onPageDown, this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.PageUp).on(this.onPageUp, this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.Home).on(this.onHome, this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.End).on(this.onEnd, this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => (e.keyCode >= KeyCode.KEY_0 && e.keyCode <= KeyCode.KEY_Z) || (e.keyCode >= KeyCode.US_SEMICOLON && e.keyCode <= KeyCode.NUMPAD_DIVIDE)).on(this.onCharacter, this, this.toDispose);\n\n\t\t// SetUp list mouse controller - control navigation, disabled items, focus\n\n\t\tEvent.chain(domEvent(this.selectList.getHTMLElement(), 'mouseup'))\n\t\t\t.filter(() => this.selectList.length > 0)\n\t\t\t.on(e => this.onMouseUp(e), this, this.toDispose);\n\n\t\tthis.toDispose.push(\n\t\t\tthis.selectList.onDidBlur(_ => this.onListBlur()),\n\t\t\tthis.selectList.onMouseOver(e => typeof e.index !== 'undefined' && this.selectList.setFocus([e.index])),\n\t\t\tthis.selectList.onFocusChange(e => this.onListFocus(e))\n\t\t);\n\n\t\tthis.selectList.getHTMLElement().setAttribute('aria-label', this.selectBoxOptions.ariaLabel || '');\n\t\tthis.selectList.getHTMLElement().setAttribute('aria-expanded', 'true');\n\n\t\tthis.styleList();\n\t}\n\n\t// List methods\n\n\t// List mouse controller - active exit, select option, fire onDidSelect if change, return focus to parent select\n\tprivate onMouseUp(e: MouseEvent): void {\n\n\t\tdom.EventHelper.stop(e);\n\n\t\tconst target = <Element>e.target;\n\t\tif (!target) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Check our mouse event is on an option (not scrollbar)\n\t\tif (!!target.classList.contains('slider')) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst listRowElement = target.closest('.monaco-list-row');\n\n\t\tif (!listRowElement) {\n\t\t\treturn;\n\t\t}\n\t\tconst index = Number(listRowElement.getAttribute('data-index'));\n\t\tconst disabled = listRowElement.classList.contains('option-disabled');\n\n\t\t// Ignore mouse selection of disabled options\n\t\tif (index >= 0 && index < this.options.length && !disabled) {\n\t\t\tthis.selected = index;\n\t\t\tthis.select(this.selected);\n\n\t\t\tthis.selectList.setFocus([this.selected]);\n\t\t\tthis.selectList.reveal(this.selectList.getFocus()[0]);\n\n\t\t\t// Only fire if selection change\n\t\t\tif (this.selected !== this._currentSelection) {\n\t\t\t\t// Set current = selected\n\t\t\t\tthis._currentSelection = this.selected;\n\n\t\t\t\tthis._onDidSelect.fire({\n\t\t\t\t\tindex: this.selectElement.selectedIndex,\n\t\t\t\t\tselected: this.options[this.selected].text\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthis.hideSelectDropDown(true);\n\t\t}\n\t}\n\n\t// List Exit - passive - implicit no selection change, hide drop-down\n\tprivate onListBlur(): void {\n\t\tif (this._sticky) { return; }\n\t\tif (this.selected !== this._currentSelection) {\n\t\t\t// Reset selected to current if no change\n\t\t\tthis.select(this._currentSelection);\n\t\t}\n\n\t\tthis.hideSelectDropDown(false);\n\t}\n\n\n\tprivate renderDescriptionMarkdown(text: string): HTMLElement {\n\t\tconst cleanRenderedMarkdown = (element: Node) => {\n\t\t\tfor (let i = 0; i < element.childNodes.length; i++) {\n\t\t\t\tconst child = <Element>element.childNodes.item(i);\n\n\t\t\t\tconst tagName = child.tagName && child.tagName.toLowerCase();\n\t\t\t\tif (tagName === 'img') {\n\t\t\t\t\telement.removeChild(child);\n\t\t\t\t} else {\n\t\t\t\t\tcleanRenderedMarkdown(child);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tconst renderedMarkdown = renderMarkdown({ value: text });\n\n\t\trenderedMarkdown.classList.add('select-box-description-markdown');\n\t\tcleanRenderedMarkdown(renderedMarkdown);\n\n\t\treturn renderedMarkdown;\n\t}\n\n\t// List Focus Change - passive - update details pane with newly focused element's data\n\tprivate onListFocus(e: IListEvent<ISelectOptionItem>) {\n\t\t// Skip during initial layout\n\t\tif (!this._isVisible || !this._hasDetails) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.selectionDetailsPane.innerText = '';\n\t\tconst selectedIndex = e.indexes[0];\n\t\tconst description = this.options[selectedIndex].description;\n\t\tconst descriptionIsMarkdown = this.options[selectedIndex].descriptionIsMarkdown;\n\n\t\tif (description) {\n\t\t\tif (descriptionIsMarkdown) {\n\t\t\t\tthis.selectionDetailsPane.appendChild(this.renderDescriptionMarkdown(description));\n\t\t\t} else {\n\t\t\t\tthis.selectionDetailsPane.innerText = description;\n\t\t\t}\n\t\t\tthis.selectionDetailsPane.style.display = 'block';\n\t\t} else {\n\t\t\tthis.selectionDetailsPane.style.display = 'none';\n\t\t}\n\n\t\t// Avoid recursion\n\t\tthis._skipLayout = true;\n\t\tthis.contextViewProvider.layout();\n\t\tthis._skipLayout = false;\n\n\t}\n\n\t// List keyboard controller\n\n\t// List exit - active - hide ContextView dropdown, reset selection, return focus to parent select\n\tprivate onEscape(e: StandardKeyboardEvent): void {\n\t\tdom.EventHelper.stop(e);\n\n\t\t// Reset selection to value when opened\n\t\tthis.select(this._currentSelection);\n\t\tthis.hideSelectDropDown(true);\n\t}\n\n\t// List exit - active - hide ContextView dropdown, return focus to parent select, fire onDidSelect if change\n\tprivate onEnter(e: StandardKeyboardEvent): void {\n\t\tdom.EventHelper.stop(e);\n\n\t\t// Only fire if selection change\n\t\tif (this.selected !== this._currentSelection) {\n\t\t\tthis._currentSelection = this.selected;\n\t\t\tthis._onDidSelect.fire({\n\t\t\t\tindex: this.selectElement.selectedIndex,\n\t\t\t\tselected: this.options[this.selected].text\n\t\t\t});\n\t\t}\n\n\t\tthis.hideSelectDropDown(true);\n\t}\n\n\t// List navigation - have to handle a disabled option (jump over)\n\tprivate onDownArrow(): void {\n\t\tif (this.selected < this.options.length - 1) {\n\n\t\t\t// Skip disabled options\n\t\t\tconst nextOptionDisabled = this.options[this.selected + 1].isDisabled;\n\n\t\t\tif (nextOptionDisabled && this.options.length > this.selected + 2) {\n\t\t\t\tthis.selected += 2;\n\t\t\t} else if (nextOptionDisabled) {\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tthis.selected++;\n\t\t\t}\n\n\t\t\t// Set focus/selection - only fire event when closing drop-down or on blur\n\t\t\tthis.select(this.selected);\n\t\t\tthis.selectList.setFocus([this.selected]);\n\t\t\tthis.selectList.reveal(this.selectList.getFocus()[0]);\n\t\t}\n\t}\n\n\tprivate onUpArrow(): void {\n\t\tif (this.selected > 0) {\n\t\t\t// Skip disabled options\n\t\t\tconst previousOptionDisabled = this.options[this.selected - 1].isDisabled;\n\t\t\tif (previousOptionDisabled && this.selected > 1) {\n\t\t\t\tthis.selected -= 2;\n\t\t\t} else {\n\t\t\t\tthis.selected--;\n\t\t\t}\n\t\t\t// Set focus/selection - only fire event when closing drop-down or on blur\n\t\t\tthis.select(this.selected);\n\t\t\tthis.selectList.setFocus([this.selected]);\n\t\t\tthis.selectList.reveal(this.selectList.getFocus()[0]);\n\t\t}\n\t}\n\n\tprivate onPageUp(e: StandardKeyboardEvent): void {\n\t\tdom.EventHelper.stop(e);\n\n\t\tthis.selectList.focusPreviousPage();\n\n\t\t// Allow scrolling to settle\n\t\tsetTimeout(() => {\n\t\t\tthis.selected = this.selectList.getFocus()[0];\n\n\t\t\t// Shift selection down if we land on a disabled option\n\t\t\tif (this.options[this.selected].isDisabled && this.selected < this.options.length - 1) {\n\t\t\t\tthis.selected++;\n\t\t\t\tthis.selectList.setFocus([this.selected]);\n\t\t\t}\n\t\t\tthis.selectList.reveal(this.selected);\n\t\t\tthis.select(this.selected);\n\t\t}, 1);\n\t}\n\n\tprivate onPageDown(e: StandardKeyboardEvent): void {\n\t\tdom.EventHelper.stop(e);\n\n\t\tthis.selectList.focusNextPage();\n\n\t\t// Allow scrolling to settle\n\t\tsetTimeout(() => {\n\t\t\tthis.selected = this.selectList.getFocus()[0];\n\n\t\t\t// Shift selection up if we land on a disabled option\n\t\t\tif (this.options[this.selected].isDisabled && this.selected > 0) {\n\t\t\t\tthis.selected--;\n\t\t\t\tthis.selectList.setFocus([this.selected]);\n\t\t\t}\n\t\t\tthis.selectList.reveal(this.selected);\n\t\t\tthis.select(this.selected);\n\t\t}, 1);\n\t}\n\n\tprivate onHome(e: StandardKeyboardEvent): void {\n\t\tdom.EventHelper.stop(e);\n\n\t\tif (this.options.length < 2) {\n\t\t\treturn;\n\t\t}\n\t\tthis.selected = 0;\n\t\tif (this.options[this.selected].isDisabled && this.selected > 1) {\n\t\t\tthis.selected++;\n\t\t}\n\t\tthis.selectList.setFocus([this.selected]);\n\t\tthis.selectList.reveal(this.selected);\n\t\tthis.select(this.selected);\n\t}\n\n\tprivate onEnd(e: StandardKeyboardEvent): void {\n\t\tdom.EventHelper.stop(e);\n\n\t\tif (this.options.length < 2) {\n\t\t\treturn;\n\t\t}\n\t\tthis.selected = this.options.length - 1;\n\t\tif (this.options[this.selected].isDisabled && this.selected > 1) {\n\t\t\tthis.selected--;\n\t\t}\n\t\tthis.selectList.setFocus([this.selected]);\n\t\tthis.selectList.reveal(this.selected);\n\t\tthis.select(this.selected);\n\t}\n\n\t// Mimic option first character navigation of native select\n\tprivate onCharacter(e: StandardKeyboardEvent): void {\n\t\tconst ch = KeyCodeUtils.toString(e.keyCode);\n\t\tlet optionIndex = -1;\n\n\t\tfor (let i = 0; i < this.options.length - 1; i++) {\n\t\t\toptionIndex = (i + this.selected + 1) % this.options.length;\n\t\t\tif (this.options[optionIndex].text.charAt(0).toUpperCase() === ch && !this.options[optionIndex].isDisabled) {\n\t\t\t\tthis.select(optionIndex);\n\t\t\t\tthis.selectList.setFocus([optionIndex]);\n\t\t\t\tthis.selectList.reveal(this.selectList.getFocus()[0]);\n\t\t\t\tdom.EventHelper.stop(e);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic dispose(): void {\n\t\tthis.hideSelectDropDown(false);\n\t\tthis.toDispose = dispose(this.toDispose);\n\t}\n}\n",
            "linguagem": "ts",
            "total_linhas": 1027
        },
        "solucao_humana": {
            "patch_diff": "@@ -191,6 +191,9 @@ export class SelectBoxList implements ISelectBoxDelegate, IListVirtualDelegate<I\n \t\t\t\tindex: e.target.selectedIndex,\n \t\t\t\tselected: e.target.value\n \t\t\t});\n+\t\t\tif (!!this.options[this.selected] && !!this.options[this.selected].text) {\n+\t\t\t\tthis.selectElement.title = this.options[this.selected].text;\n+\t\t\t}\n \t\t}));\n \n \t\t// Have to implement both keyboard and mouse controllers to handle disabled options\n@@ -282,6 +285,9 @@ export class SelectBoxList implements ISelectBoxDelegate, IListVirtualDelegate<I\n \t\t}\n \n \t\tthis.selectElement.selectedIndex = this.selected;\n+\t\tif (!!this.options[this.selected] && !!this.options[this.selected].text) {\n+\t\t\tthis.selectElement.title = this.options[this.selected].text;\n+\t\t}\n \t}\n \n \tpublic setAriaLabel(label: string): void {\n@@ -395,7 +401,7 @@ export class SelectBoxList implements ISelectBoxDelegate, IListVirtualDelegate<I\n \t\t\tlet listBackground = this.styles.selectListBackground ? this.styles.selectListBackground.toString() : background;\n \t\t\tthis.selectDropDownListContainer.style.backgroundColor = listBackground;\n \t\t\tthis.selectionDetailsPane.style.backgroundColor = listBackground;\n-\t\t\tconst optionsBorder = this.styles.focusBorder ? this.styles.focusBorder.toString() : null;\n+\t\t\tconst optionsBorder = this.styles.focusBorder ? this.styles.focusBorder.toString() : '';\n \t\t\tthis.selectDropDownContainer.style.outlineColor = optionsBorder;\n \t\t\tthis.selectDropDownContainer.style.outlineOffset = '-1px';\n \t\t}\n@@ -798,7 +804,11 @@ export class SelectBoxList implements ISelectBoxDelegate, IListVirtualDelegate<I\n \t\t\t\tthis._onDidSelect.fire({\n \t\t\t\t\tindex: this.selectElement.selectedIndex,\n \t\t\t\t\tselected: this.options[this.selected].text\n+\n \t\t\t\t});\n+\t\t\t\tif (!!this.options[this.selected] && !!this.options[this.selected].text) {\n+\t\t\t\t\tthis.selectElement.title = this.options[this.selected].text;\n+\t\t\t\t}\n \t\t\t}\n \n \t\t\tthis.hideSelectDropDown(true);\n@@ -891,6 +901,9 @@ export class SelectBoxList implements ISelectBoxDelegate, IListVirtualDelegate<I\n \t\t\t\tindex: this.selectElement.selectedIndex,\n \t\t\t\tselected: this.options[this.selected].text\n \t\t\t});\n+\t\t\tif (!!this.options[this.selected] && !!this.options[this.selected].text) {\n+\t\t\t\tthis.selectElement.title = this.options[this.selected].text;\n+\t\t\t}\n \t\t}\n \n \t\tthis.hideSelectDropDown(true);",
            "apenas_linhas_adicionadas": [
                "\t\t\tif (!!this.options[this.selected] && !!this.options[this.selected].text) {",
                "\t\t\t\tthis.selectElement.title = this.options[this.selected].text;",
                "\t\t\t}",
                "\t\tif (!!this.options[this.selected] && !!this.options[this.selected].text) {",
                "\t\t\tthis.selectElement.title = this.options[this.selected].text;",
                "\t\t}",
                "\t\t\tconst optionsBorder = this.styles.focusBorder ? this.styles.focusBorder.toString() : '';",
                "",
                "\t\t\t\tif (!!this.options[this.selected] && !!this.options[this.selected].text) {",
                "\t\t\t\t\tthis.selectElement.title = this.options[this.selected].text;",
                "\t\t\t\t}",
                "\t\t\tif (!!this.options[this.selected] && !!this.options[this.selected].text) {",
                "\t\t\t\tthis.selectElement.title = this.options[this.selected].text;",
                "\t\t\t}"
            ]
        }
    },
    {
        "id": 82150,
        "url": "https://github.com/microsoft/vscode/pull/82150",
        "arquivo_caminho": "src/vs/base/common/resourceTree.ts",
        "descricao_bug": "Fixes #82149\r\n\r\nI simply forgot to update the `delete` method in the `ResourceTree` model in the fix (https://github.com/microsoft/vscode/commit/c850f0716e6193d0a11d48c81b29c8aff6147d1b) for https://github.com/microsoft/vscode/issues/81798.",
        "contexto": {
            "codigo_completo_bugado": "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { memoize } from 'vs/base/common/decorators';\nimport * as paths from 'vs/base/common/path';\nimport { Iterator } from 'vs/base/common/iterator';\nimport { relativePath, joinPath } from 'vs/base/common/resources';\nimport { URI } from 'vs/base/common/uri';\nimport { mapValues } from 'vs/base/common/collections';\nimport { PathIterator } from 'vs/base/common/map';\n\nexport interface ILeafNode<T, C = void> {\n\treadonly uri: URI;\n\treadonly relativePath: string;\n\treadonly name: string;\n\treadonly element: T;\n\treadonly context: C;\n}\n\nexport interface IBranchNode<T, C = void> {\n\treadonly uri: URI;\n\treadonly relativePath: string;\n\treadonly name: string;\n\treadonly size: number;\n\treadonly children: Iterator<INode<T, C>>;\n\treadonly parent: IBranchNode<T, C> | undefined;\n\treadonly context: C;\n\tget(childName: string): INode<T, C> | undefined;\n}\n\nexport type INode<T, C> = IBranchNode<T, C> | ILeafNode<T, C>;\n\n// Internals\n\nclass Node<C> {\n\n\t@memoize\n\tget name(): string { return paths.posix.basename(this.relativePath); }\n\n\tconstructor(readonly uri: URI, readonly relativePath: string, readonly context: C) { }\n}\n\nclass BranchNode<T, C> extends Node<C> implements IBranchNode<T, C> {\n\n\tprivate _children = new Map<string, BranchNode<T, C> | LeafNode<T, C>>();\n\n\tget size(): number {\n\t\treturn this._children.size;\n\t}\n\n\tget children(): Iterator<BranchNode<T, C> | LeafNode<T, C>> {\n\t\treturn Iterator.fromArray(mapValues(this._children));\n\t}\n\n\tconstructor(uri: URI, relativePath: string, context: C, readonly parent: IBranchNode<T, C> | undefined = undefined) {\n\t\tsuper(uri, relativePath, context);\n\t}\n\n\tget(path: string): BranchNode<T, C> | LeafNode<T, C> | undefined {\n\t\treturn this._children.get(path);\n\t}\n\n\tset(path: string, child: BranchNode<T, C> | LeafNode<T, C>): void {\n\t\tthis._children.set(path, child);\n\t}\n\n\tdelete(path: string): void {\n\t\tthis._children.delete(path);\n\t}\n}\n\nclass LeafNode<T, C> extends Node<C> implements ILeafNode<T, C> {\n\n\tconstructor(uri: URI, path: string, context: C, readonly element: T) {\n\t\tsuper(uri, path, context);\n\t}\n}\n\nfunction collect<T, C>(node: INode<T, C>, result: T[]): T[] {\n\tif (ResourceTree.isBranchNode(node)) {\n\t\tIterator.forEach(node.children, child => collect(child, result));\n\t} else {\n\t\tresult.push(node.element);\n\t}\n\n\treturn result;\n}\n\nexport class ResourceTree<T extends NonNullable<any>, C> {\n\n\treadonly root: BranchNode<T, C>;\n\n\tstatic isBranchNode<T, C>(obj: any): obj is IBranchNode<T, C> {\n\t\treturn obj instanceof BranchNode;\n\t}\n\n\tstatic getRoot<T, C>(node: IBranchNode<T, C>): IBranchNode<T, C> {\n\t\twhile (node.parent) {\n\t\t\tnode = node.parent;\n\t\t}\n\n\t\treturn node;\n\t}\n\n\tstatic collect<T, C>(node: INode<T, C>): T[] {\n\t\treturn collect(node, []);\n\t}\n\n\tconstructor(context: C, rootURI: URI = URI.file('/')) {\n\t\tthis.root = new BranchNode(rootURI, '', context);\n\t}\n\n\tadd(uri: URI, element: T): void {\n\t\tconst key = relativePath(this.root.uri, uri) || uri.fsPath;\n\t\tconst iterator = new PathIterator(false).reset(key);\n\t\tlet node = this.root;\n\t\tlet path = '';\n\n\t\twhile (true) {\n\t\t\tconst name = iterator.value();\n\t\t\tpath = path + '/' + name;\n\n\t\t\tlet child = node.get(name);\n\n\t\t\tif (!child) {\n\t\t\t\tif (iterator.hasNext()) {\n\t\t\t\t\tchild = new BranchNode(joinPath(this.root.uri, path), path, this.root.context, node);\n\t\t\t\t\tnode.set(name, child);\n\t\t\t\t} else {\n\t\t\t\t\tchild = new LeafNode(uri, path, this.root.context, element);\n\t\t\t\t\tnode.set(name, child);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!(child instanceof BranchNode)) {\n\t\t\t\tif (iterator.hasNext()) {\n\t\t\t\t\tthrow new Error('Inconsistent tree: can\\'t override leaf with branch.');\n\t\t\t\t}\n\n\t\t\t\t// replace\n\t\t\t\tnode.set(name, new LeafNode(uri, path, this.root.context, element));\n\t\t\t\treturn;\n\t\t\t} else if (!iterator.hasNext()) {\n\t\t\t\tthrow new Error('Inconsistent tree: can\\'t override branch with leaf.');\n\t\t\t}\n\n\t\t\tnode = child;\n\n\t\t\tif (!iterator.hasNext()) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\titerator.next();\n\t\t}\n\t}\n\n\tdelete(uri: URI): T | undefined {\n\t\tconst key = relativePath(this.root.uri, uri) || uri.fsPath;\n\t\tconst parts = key.split(/[\\\\\\/]/).filter(p => !!p);\n\t\treturn this._delete(this.root, parts, 0);\n\t}\n\n\tprivate _delete(node: BranchNode<T, C>, parts: string[], index: number): T | undefined {\n\t\tconst name = parts[index];\n\t\tconst child = node.get(name);\n\n\t\tif (!child) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// not at end\n\t\tif (index < parts.length - 1) {\n\t\t\tif (child instanceof BranchNode) {\n\t\t\t\tconst result = this._delete(child, parts, index + 1);\n\n\t\t\t\tif (typeof result !== 'undefined' && child.size === 0) {\n\t\t\t\t\tnode.delete(name);\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\tthrow new Error('Inconsistent tree: Expected a branch, found a leaf instead.');\n\t\t\t}\n\t\t}\n\n\t\t//at end\n\t\tif (child instanceof BranchNode) {\n\t\t\t// TODO: maybe we can allow this\n\t\t\tthrow new Error('Inconsistent tree: Expected a leaf, found a branch instead.');\n\t\t}\n\n\t\tnode.delete(name);\n\t\treturn child.element;\n\t}\n}\n",
            "linguagem": "ts",
            "total_linhas": 199
        },
        "solucao_humana": {
            "patch_diff": "@@ -159,22 +159,22 @@ export class ResourceTree<T extends NonNullable<any>, C> {\n \n \tdelete(uri: URI): T | undefined {\n \t\tconst key = relativePath(this.root.uri, uri) || uri.fsPath;\n-\t\tconst parts = key.split(/[\\\\\\/]/).filter(p => !!p);\n-\t\treturn this._delete(this.root, parts, 0);\n+\t\tconst iterator = new PathIterator(false).reset(key);\n+\t\treturn this._delete(this.root, iterator);\n \t}\n \n-\tprivate _delete(node: BranchNode<T, C>, parts: string[], index: number): T | undefined {\n-\t\tconst name = parts[index];\n+\tprivate _delete(node: BranchNode<T, C>, iterator: PathIterator): T | undefined {\n+\t\tconst name = iterator.value();\n \t\tconst child = node.get(name);\n \n \t\tif (!child) {\n \t\t\treturn undefined;\n \t\t}\n \n \t\t// not at end\n-\t\tif (index < parts.length - 1) {\n+\t\tif (iterator.hasNext()) {\n \t\t\tif (child instanceof BranchNode) {\n-\t\t\t\tconst result = this._delete(child, parts, index + 1);\n+\t\t\t\tconst result = this._delete(child, iterator.next());\n \n \t\t\t\tif (typeof result !== 'undefined' && child.size === 0) {\n \t\t\t\t\tnode.delete(name);",
            "apenas_linhas_adicionadas": [
                "\t\tconst iterator = new PathIterator(false).reset(key);",
                "\t\treturn this._delete(this.root, iterator);",
                "\tprivate _delete(node: BranchNode<T, C>, iterator: PathIterator): T | undefined {",
                "\t\tconst name = iterator.value();",
                "\t\tif (iterator.hasNext()) {",
                "\t\t\t\tconst result = this._delete(child, iterator.next());"
            ]
        }
    },
    {
        "id": 103349,
        "url": "https://github.com/microsoft/vscode/pull/103349",
        "arquivo_caminho": "src/vs/platform/theme/common/tokenClassificationRegistry.ts",
        "descricao_bug": "Replaces {} with Object.create(null), so that accessing the object can have properties defined that conflict with the prototype names.  `constructor`, `toString` are examples.\r\n\r\nThis PR fixes #103104\r\n",
        "contexto": {
            "codigo_completo_bugado": "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as platform from 'vs/platform/registry/common/platform';\nimport { Color } from 'vs/base/common/color';\nimport { IColorTheme } from 'vs/platform/theme/common/themeService';\nimport * as nls from 'vs/nls';\nimport { Extensions as JSONExtensions, IJSONContributionRegistry } from 'vs/platform/jsonschemas/common/jsonContributionRegistry';\nimport { RunOnceScheduler } from 'vs/base/common/async';\nimport { Event, Emitter } from 'vs/base/common/event';\nimport { IJSONSchema, IJSONSchemaMap } from 'vs/base/common/jsonSchema';\n\nexport const TOKEN_TYPE_WILDCARD = '*';\nexport const TOKEN_CLASSIFIER_LANGUAGE_SEPARATOR = ':';\nexport const CLASSIFIER_MODIFIER_SEPARATOR = '.';\n\n// qualified string [type|*](.modifier)*(/language)!\nexport type TokenClassificationString = string;\n\nexport const idPattern = '\\\\w+[-_\\\\w+]*';\nexport const typeAndModifierIdPattern = `^${idPattern}$`;\n\nexport const selectorPattern = `^(${idPattern}|\\\\*)(\\\\${CLASSIFIER_MODIFIER_SEPARATOR}${idPattern})*(\\\\${TOKEN_CLASSIFIER_LANGUAGE_SEPARATOR}${idPattern})?$`;\n\nexport const fontStylePattern = '^(\\\\s*(italic|bold|underline))*\\\\s*$';\n\nexport interface TokenSelector {\n\tmatch(type: string, modifiers: string[], language: string): number;\n\treadonly id: string;\n}\n\nexport interface TokenTypeOrModifierContribution {\n\treadonly num: number;\n\treadonly id: string;\n\treadonly superType?: string;\n\treadonly description: string;\n\treadonly deprecationMessage?: string;\n}\n\n\nexport interface TokenStyleData {\n\tforeground?: Color;\n\tbold?: boolean;\n\tunderline?: boolean;\n\titalic?: boolean;\n}\n\nexport class TokenStyle implements Readonly<TokenStyleData> {\n\tconstructor(\n\t\tpublic readonly foreground?: Color,\n\t\tpublic readonly bold?: boolean,\n\t\tpublic readonly underline?: boolean,\n\t\tpublic readonly italic?: boolean,\n\t) {\n\t}\n}\n\nexport namespace TokenStyle {\n\texport function toJSONObject(style: TokenStyle): any {\n\t\treturn {\n\t\t\t_foreground: style.foreground === undefined ? null : Color.Format.CSS.formatHexA(style.foreground, true),\n\t\t\t_bold: style.bold === undefined ? null : style.bold,\n\t\t\t_underline: style.underline === undefined ? null : style.underline,\n\t\t\t_italic: style.italic === undefined ? null : style.italic,\n\t\t};\n\t}\n\texport function fromJSONObject(obj: any): TokenStyle | undefined {\n\t\tif (obj) {\n\t\t\tconst boolOrUndef = (b: any) => (typeof b === 'boolean') ? b : undefined;\n\t\t\tconst colorOrUndef = (s: any) => (typeof s === 'string') ? Color.fromHex(s) : undefined;\n\t\t\treturn new TokenStyle(colorOrUndef(obj._foreground), boolOrUndef(obj._bold), boolOrUndef(obj._underline), boolOrUndef(obj._italic));\n\t\t}\n\t\treturn undefined;\n\t}\n\texport function equals(s1: any, s2: any): boolean {\n\t\tif (s1 === s2) {\n\t\t\treturn true;\n\t\t}\n\t\treturn s1 !== undefined && s2 !== undefined\n\t\t\t&& (s1.foreground instanceof Color ? s1.foreground.equals(s2.foreground) : s2.foreground === undefined)\n\t\t\t&& s1.bold === s2.bold\n\t\t\t&& s1.underline === s2.underline\n\t\t\t&& s1.italic === s2.italic;\n\t}\n\texport function is(s: any): s is TokenStyle {\n\t\treturn s instanceof TokenStyle;\n\t}\n\texport function fromData(data: { foreground?: Color, bold?: boolean, underline?: boolean, italic?: boolean }): TokenStyle {\n\t\treturn new TokenStyle(data.foreground, data.bold, data.underline, data.italic);\n\t}\n\texport function fromSettings(foreground: string | undefined, fontStyle: string | undefined, bold?: boolean, underline?: boolean, italic?: boolean): TokenStyle {\n\t\tlet foregroundColor = undefined;\n\t\tif (foreground !== undefined) {\n\t\t\tforegroundColor = Color.fromHex(foreground);\n\t\t}\n\t\tif (fontStyle !== undefined) {\n\t\t\tbold = italic = underline = false;\n\t\t\tconst expression = /italic|bold|underline/g;\n\t\t\tlet match;\n\t\t\twhile ((match = expression.exec(fontStyle))) {\n\t\t\t\tswitch (match[0]) {\n\t\t\t\t\tcase 'bold': bold = true; break;\n\t\t\t\t\tcase 'italic': italic = true; break;\n\t\t\t\t\tcase 'underline': underline = true; break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new TokenStyle(foregroundColor, bold, underline, italic);\n\t}\n}\n\nexport type ProbeScope = string[];\n\nexport interface TokenStyleFunction {\n\t(theme: IColorTheme): TokenStyle | undefined;\n}\n\nexport interface TokenStyleDefaults {\n\tscopesToProbe?: ProbeScope[];\n\tlight?: TokenStyleValue;\n\tdark?: TokenStyleValue;\n\thc?: TokenStyleValue;\n}\n\nexport interface SemanticTokenDefaultRule {\n\tselector: TokenSelector;\n\tdefaults: TokenStyleDefaults;\n}\n\nexport interface SemanticTokenRule {\n\tstyle: TokenStyle;\n\tselector: TokenSelector;\n}\n\nexport namespace SemanticTokenRule {\n\texport function fromJSONObject(registry: ITokenClassificationRegistry, o: any): SemanticTokenRule | undefined {\n\t\tif (o && typeof o._selector === 'string' && o._style) {\n\t\t\tconst style = TokenStyle.fromJSONObject(o._style);\n\t\t\tif (style) {\n\t\t\t\ttry {\n\t\t\t\t\treturn { selector: registry.parseTokenSelector(o._selector), style };\n\t\t\t\t} catch (_ignore) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\texport function toJSONObject(rule: SemanticTokenRule): any {\n\t\treturn {\n\t\t\t_selector: rule.selector.id,\n\t\t\t_style: TokenStyle.toJSONObject(rule.style)\n\t\t};\n\t}\n\texport function equals(r1: SemanticTokenRule | undefined, r2: SemanticTokenRule | undefined) {\n\t\tif (r1 === r2) {\n\t\t\treturn true;\n\t\t}\n\t\treturn r1 !== undefined && r2 !== undefined\n\t\t\t&& r1.selector && r2.selector && r1.selector.id === r2.selector.id\n\t\t\t&& TokenStyle.equals(r1.style, r2.style);\n\t}\n\texport function is(r: any): r is SemanticTokenRule {\n\t\treturn r && r.selector && typeof r.selector.id === 'string' && TokenStyle.is(r.style);\n\t}\n}\n\n/**\n * A TokenStyle Value is either a token style literal, or a TokenClassificationString\n */\nexport type TokenStyleValue = TokenStyle | TokenClassificationString;\n\n// TokenStyle registry\nexport const Extensions = {\n\tTokenClassificationContribution: 'base.contributions.tokenClassification'\n};\n\nexport interface ITokenClassificationRegistry {\n\n\treadonly onDidChangeSchema: Event<void>;\n\n\t/**\n\t * Register a token type to the registry.\n\t * @param id The TokenType id as used in theme description files\n\t * @param description the description\n\t */\n\tregisterTokenType(id: string, description: string, superType?: string, deprecationMessage?: string): void;\n\n\t/**\n\t * Register a token modifier to the registry.\n\t * @param id The TokenModifier id as used in theme description files\n\t * @param description the description\n\t */\n\tregisterTokenModifier(id: string, description: string): void;\n\n\t/**\n\t * Parses a token selector from a selector string.\n\t * @param selectorString selector string in the form (*|type)(.modifier)*\n\t * @param language language to which the selector applies or undefined if the selector is for all languafe\n\t * @returns the parsesd selector\n\t * @throws an error if the string is not a valid selector\n\t */\n\tparseTokenSelector(selectorString: string, language?: string): TokenSelector;\n\n\t/**\n\t * Register a TokenStyle default to the registry.\n\t * @param selector The rule selector\n\t * @param defaults The default values\n\t */\n\tregisterTokenStyleDefault(selector: TokenSelector, defaults: TokenStyleDefaults): void;\n\n\t/**\n\t * Deregister a TokenStyle default to the registry.\n\t * @param selector The rule selector\n\t */\n\tderegisterTokenStyleDefault(selector: TokenSelector): void;\n\n\t/**\n\t * Deregister a TokenType from the registry.\n\t */\n\tderegisterTokenType(id: string): void;\n\n\t/**\n\t * Deregister a TokenModifier from the registry.\n\t */\n\tderegisterTokenModifier(id: string): void;\n\n\t/**\n\t * Get all TokenType contributions\n\t */\n\tgetTokenTypes(): TokenTypeOrModifierContribution[];\n\n\t/**\n\t * Get all TokenModifier contributions\n\t */\n\tgetTokenModifiers(): TokenTypeOrModifierContribution[];\n\n\t/**\n\t * The styling rules to used when a schema does not define any styling rules.\n\t */\n\tgetTokenStylingDefaultRules(): SemanticTokenDefaultRule[];\n\n\t/**\n\t * JSON schema for an object to assign styling to token classifications\n\t */\n\tgetTokenStylingSchema(): IJSONSchema;\n}\n\nclass TokenClassificationRegistry implements ITokenClassificationRegistry {\n\n\tprivate readonly _onDidChangeSchema = new Emitter<void>();\n\treadonly onDidChangeSchema: Event<void> = this._onDidChangeSchema.event;\n\n\tprivate currentTypeNumber = 0;\n\tprivate currentModifierBit = 1;\n\n\tprivate tokenTypeById: { [key: string]: TokenTypeOrModifierContribution };\n\tprivate tokenModifierById: { [key: string]: TokenTypeOrModifierContribution };\n\n\tprivate tokenStylingDefaultRules: SemanticTokenDefaultRule[] = [];\n\n\tprivate typeHierarchy: { [id: string]: string[] };\n\n\tprivate tokenStylingSchema: IJSONSchema & { properties: IJSONSchemaMap, patternProperties: IJSONSchemaMap } = {\n\t\ttype: 'object',\n\t\tproperties: {},\n\t\tpatternProperties: {\n\t\t\t[selectorPattern]: getStylingSchemeEntry()\n\t\t},\n\t\t//errorMessage: nls.localize('schema.token.errors', 'Valid token selectors have the form (*|tokenType)(.tokenModifier)*(:tokenLanguage)?.'),\n\t\tadditionalProperties: false,\n\t\tdefinitions: {\n\t\t\tstyle: {\n\t\t\t\ttype: 'object',\n\t\t\t\tdescription: nls.localize('schema.token.settings', 'Colors and styles for the token.'),\n\t\t\t\tproperties: {\n\t\t\t\t\tforeground: {\n\t\t\t\t\t\ttype: 'string',\n\t\t\t\t\t\tdescription: nls.localize('schema.token.foreground', 'Foreground color for the token.'),\n\t\t\t\t\t\tformat: 'color-hex',\n\t\t\t\t\t\tdefault: '#ff0000'\n\t\t\t\t\t},\n\t\t\t\t\tbackground: {\n\t\t\t\t\t\ttype: 'string',\n\t\t\t\t\t\tdeprecationMessage: nls.localize('schema.token.background.warning', 'Token background colors are currently not supported.')\n\t\t\t\t\t},\n\t\t\t\t\tfontStyle: {\n\t\t\t\t\t\ttype: 'string',\n\t\t\t\t\t\tdescription: nls.localize('schema.token.fontStyle', 'Sets the all font styles of the rule: \\'italic\\', \\'bold\\' or \\'underline\\' or a combination. All styles that are not listed are unset. The empty string unsets all styles.'),\n\t\t\t\t\t\tpattern: fontStylePattern,\n\t\t\t\t\t\tpatternErrorMessage: nls.localize('schema.fontStyle.error', 'Font style must be \\'italic\\', \\'bold\\' or \\'underline\\' or a combination. The empty string unsets all styles.'),\n\t\t\t\t\t\tdefaultSnippets: [{ label: nls.localize('schema.token.fontStyle.none', 'None (clear inherited style)'), bodyText: '\"\"' }, { body: 'italic' }, { body: 'bold' }, { body: 'underline' }, { body: 'italic underline' }, { body: 'bold underline' }, { body: 'italic bold underline' }]\n\t\t\t\t\t},\n\t\t\t\t\tbold: {\n\t\t\t\t\t\ttype: 'boolean',\n\t\t\t\t\t\tdescription: nls.localize('schema.token.bold', 'Sets or unsets the font style to bold. Note, the presence of \\'fontStyle\\' overrides this setting.'),\n\t\t\t\t\t},\n\t\t\t\t\titalic: {\n\t\t\t\t\t\ttype: 'boolean',\n\t\t\t\t\t\tdescription: nls.localize('schema.token.italic', 'Sets or unsets the font style to italic. Note, the presence of \\'fontStyle\\' overrides this setting.'),\n\t\t\t\t\t},\n\t\t\t\t\tunderline: {\n\t\t\t\t\t\ttype: 'boolean',\n\t\t\t\t\t\tdescription: nls.localize('schema.token.underline', 'Sets or unsets the font style to underline. Note, the presence of \\'fontStyle\\' overrides this setting.'),\n\t\t\t\t\t}\n\n\t\t\t\t},\n\t\t\t\tdefaultSnippets: [{ body: { foreground: '${1:#FF0000}', fontStyle: '${2:bold}' } }]\n\t\t\t}\n\t\t}\n\t};\n\n\tconstructor() {\n\t\tthis.tokenTypeById = {};\n\t\tthis.tokenModifierById = {};\n\t\tthis.typeHierarchy = {};\n\t}\n\n\tpublic registerTokenType(id: string, description: string, superType?: string, deprecationMessage?: string): void {\n\t\tif (!id.match(typeAndModifierIdPattern)) {\n\t\t\tthrow new Error('Invalid token type id.');\n\t\t}\n\t\tif (superType && !superType.match(typeAndModifierIdPattern)) {\n\t\t\tthrow new Error('Invalid token super type id.');\n\t\t}\n\n\t\tconst num = this.currentTypeNumber++;\n\t\tlet tokenStyleContribution: TokenTypeOrModifierContribution = { num, id, superType, description, deprecationMessage };\n\t\tthis.tokenTypeById[id] = tokenStyleContribution;\n\n\t\tconst stylingSchemeEntry = getStylingSchemeEntry(description, deprecationMessage);\n\t\tthis.tokenStylingSchema.properties[id] = stylingSchemeEntry;\n\t\tthis.typeHierarchy = {};\n\t}\n\n\tpublic registerTokenModifier(id: string, description: string, deprecationMessage?: string): void {\n\t\tif (!id.match(typeAndModifierIdPattern)) {\n\t\t\tthrow new Error('Invalid token modifier id.');\n\t\t}\n\n\t\tconst num = this.currentModifierBit;\n\t\tthis.currentModifierBit = this.currentModifierBit * 2;\n\t\tlet tokenStyleContribution: TokenTypeOrModifierContribution = { num, id, description, deprecationMessage };\n\t\tthis.tokenModifierById[id] = tokenStyleContribution;\n\n\t\tthis.tokenStylingSchema.properties[`*.${id}`] = getStylingSchemeEntry(description, deprecationMessage);\n\t}\n\n\tpublic parseTokenSelector(selectorString: string, language?: string): TokenSelector {\n\t\tconst selector = parseClassifierString(selectorString, language);\n\n\t\tif (!selector.type) {\n\t\t\treturn {\n\t\t\t\tmatch: () => -1,\n\t\t\t\tid: '$invalid'\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tmatch: (type: string, modifiers: string[], language: string) => {\n\t\t\t\tlet score = 0;\n\t\t\t\tif (selector.language !== undefined) {\n\t\t\t\t\tif (selector.language !== language) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tscore += 10;\n\t\t\t\t}\n\t\t\t\tif (selector.type !== TOKEN_TYPE_WILDCARD) {\n\t\t\t\t\tconst hierarchy = this.getTypeHierarchy(type);\n\t\t\t\t\tconst level = hierarchy.indexOf(selector.type);\n\t\t\t\t\tif (level === -1) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\tscore += (100 - level);\n\t\t\t\t}\n\t\t\t\t// all selector modifiers must be present\n\t\t\t\tfor (const selectorModifier of selector.modifiers) {\n\t\t\t\t\tif (modifiers.indexOf(selectorModifier) === -1) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn score + selector.modifiers.length * 100;\n\t\t\t},\n\t\t\tid: `${[selector.type, ...selector.modifiers.sort()].join('.')}${selector.language !== undefined ? ':' + selector.language : ''}`\n\t\t};\n\t}\n\n\tpublic registerTokenStyleDefault(selector: TokenSelector, defaults: TokenStyleDefaults): void {\n\t\tthis.tokenStylingDefaultRules.push({ selector, defaults });\n\t}\n\n\tpublic deregisterTokenStyleDefault(selector: TokenSelector): void {\n\t\tconst selectorString = selector.id;\n\t\tthis.tokenStylingDefaultRules = this.tokenStylingDefaultRules.filter(r => r.selector.id !== selectorString);\n\t}\n\n\tpublic deregisterTokenType(id: string): void {\n\t\tdelete this.tokenTypeById[id];\n\t\tdelete this.tokenStylingSchema.properties[id];\n\t\tthis.typeHierarchy = {};\n\t}\n\n\tpublic deregisterTokenModifier(id: string): void {\n\t\tdelete this.tokenModifierById[id];\n\t\tdelete this.tokenStylingSchema.properties[`*.${id}`];\n\t}\n\n\tpublic getTokenTypes(): TokenTypeOrModifierContribution[] {\n\t\treturn Object.keys(this.tokenTypeById).map(id => this.tokenTypeById[id]);\n\t}\n\n\tpublic getTokenModifiers(): TokenTypeOrModifierContribution[] {\n\t\treturn Object.keys(this.tokenModifierById).map(id => this.tokenModifierById[id]);\n\t}\n\n\tpublic getTokenStylingSchema(): IJSONSchema {\n\t\treturn this.tokenStylingSchema;\n\t}\n\n\tpublic getTokenStylingDefaultRules(): SemanticTokenDefaultRule[] {\n\t\treturn this.tokenStylingDefaultRules;\n\t}\n\n\tprivate getTypeHierarchy(typeId: string): string[] {\n\t\tlet hierarchy = this.typeHierarchy[typeId];\n\t\tif (!hierarchy) {\n\t\t\tthis.typeHierarchy[typeId] = hierarchy = [typeId];\n\t\t\tlet type = this.tokenTypeById[typeId];\n\t\t\twhile (type && type.superType) {\n\t\t\t\thierarchy.push(type.superType);\n\t\t\t\ttype = this.tokenTypeById[type.superType];\n\t\t\t}\n\t\t}\n\t\treturn hierarchy;\n\t}\n\n\n\tpublic toString() {\n\t\tlet sorter = (a: string, b: string) => {\n\t\t\tlet cat1 = a.indexOf('.') === -1 ? 0 : 1;\n\t\t\tlet cat2 = b.indexOf('.') === -1 ? 0 : 1;\n\t\t\tif (cat1 !== cat2) {\n\t\t\t\treturn cat1 - cat2;\n\t\t\t}\n\t\t\treturn a.localeCompare(b);\n\t\t};\n\n\t\treturn Object.keys(this.tokenTypeById).sort(sorter).map(k => `- \\`${k}\\`: ${this.tokenTypeById[k].description}`).join('\\n');\n\t}\n\n}\n\nconst CHAR_LANGUAGE = TOKEN_CLASSIFIER_LANGUAGE_SEPARATOR.charCodeAt(0);\nconst CHAR_MODIFIER = CLASSIFIER_MODIFIER_SEPARATOR.charCodeAt(0);\n\nexport function parseClassifierString(s: string, defaultLanguage: string): { type: string, modifiers: string[], language: string; };\nexport function parseClassifierString(s: string, defaultLanguage?: string): { type: string, modifiers: string[], language: string | undefined; };\nexport function parseClassifierString(s: string, defaultLanguage: string | undefined): { type: string, modifiers: string[], language: string | undefined; } {\n\tlet k = s.length;\n\tlet language: string | undefined = defaultLanguage;\n\tconst modifiers = [];\n\n\tfor (let i = k - 1; i >= 0; i--) {\n\t\tconst ch = s.charCodeAt(i);\n\t\tif (ch === CHAR_LANGUAGE || ch === CHAR_MODIFIER) {\n\t\t\tconst segment = s.substring(i + 1, k);\n\t\t\tk = i;\n\t\t\tif (ch === CHAR_LANGUAGE) {\n\t\t\t\tlanguage = segment;\n\t\t\t} else {\n\t\t\t\tmodifiers.push(segment);\n\t\t\t}\n\t\t}\n\t}\n\tconst type = s.substring(0, k);\n\treturn { type, modifiers, language };\n}\n\n\nlet tokenClassificationRegistry = createDefaultTokenClassificationRegistry();\nplatform.Registry.add(Extensions.TokenClassificationContribution, tokenClassificationRegistry);\n\n\nfunction createDefaultTokenClassificationRegistry(): TokenClassificationRegistry {\n\n\tconst registry = new TokenClassificationRegistry();\n\n\tfunction registerTokenType(id: string, description: string, scopesToProbe: ProbeScope[] = [], superType?: string, deprecationMessage?: string): string {\n\t\tregistry.registerTokenType(id, description, superType, deprecationMessage);\n\t\tif (scopesToProbe) {\n\t\t\tregisterTokenStyleDefault(id, scopesToProbe);\n\t\t}\n\t\treturn id;\n\t}\n\n\tfunction registerTokenStyleDefault(selectorString: string, scopesToProbe: ProbeScope[]) {\n\t\ttry {\n\t\t\tconst selector = registry.parseTokenSelector(selectorString);\n\t\t\tregistry.registerTokenStyleDefault(selector, { scopesToProbe });\n\t\t} catch (e) {\n\t\t\tconsole.log(e);\n\t\t}\n\t}\n\n\t// default token types\n\n\tregisterTokenType('comment', nls.localize('comment', \"Style for comments.\"), [['comment']]);\n\tregisterTokenType('string', nls.localize('string', \"Style for strings.\"), [['string']]);\n\tregisterTokenType('keyword', nls.localize('keyword', \"Style for keywords.\"), [['keyword.control']]);\n\tregisterTokenType('number', nls.localize('number', \"Style for numbers.\"), [['constant.numeric']]);\n\tregisterTokenType('regexp', nls.localize('regexp', \"Style for expressions.\"), [['constant.regexp']]);\n\tregisterTokenType('operator', nls.localize('operator', \"Style for operators.\"), [['keyword.operator']]);\n\n\tregisterTokenType('namespace', nls.localize('namespace', \"Style for namespaces.\"), [['entity.name.namespace']]);\n\n\tregisterTokenType('type', nls.localize('type', \"Style for types.\"), [['entity.name.type'], ['support.type']]);\n\tregisterTokenType('struct', nls.localize('struct', \"Style for structs.\"), [['entity.name.type.struct']]);\n\tregisterTokenType('class', nls.localize('class', \"Style for classes.\"), [['entity.name.type.class'], ['support.class']]);\n\tregisterTokenType('interface', nls.localize('interface', \"Style for interfaces.\"), [['entity.name.type.interface']]);\n\tregisterTokenType('enum', nls.localize('enum', \"Style for enums.\"), [['entity.name.type.enum']]);\n\tregisterTokenType('typeParameter', nls.localize('typeParameter', \"Style for type parameters.\"), [['entity.name.type.parameter']]);\n\n\tregisterTokenType('function', nls.localize('function', \"Style for functions\"), [['entity.name.function'], ['support.function']]);\n\tregisterTokenType('member', nls.localize('member', \"Style for member\"), [['entity.name.function.member'], ['support.function']]);\n\tregisterTokenType('macro', nls.localize('macro', \"Style for macros.\"), [['entity.name.other.preprocessor.macro']]);\n\n\tregisterTokenType('variable', nls.localize('variable', \"Style for variables.\"), [['variable.other.readwrite'], ['entity.name.variable']]);\n\tregisterTokenType('parameter', nls.localize('parameter', \"Style for parameters.\"), [['variable.parameter']]);\n\tregisterTokenType('property', nls.localize('property', \"Style for properties.\"), [['variable.other.property']]);\n\tregisterTokenType('enumMember', nls.localize('enumMember', \"Style for enum members.\"), [['variable.other.enummember']]);\n\tregisterTokenType('event', nls.localize('event', \"Style for events.\"), [['variable.other.event']]);\n\n\tregisterTokenType('label', nls.localize('labels', \"Style for labels. \"), undefined);\n\n\t// default token modifiers\n\n\tregistry.registerTokenModifier('declaration', nls.localize('declaration', \"Style for all symbol declarations.\"), undefined);\n\tregistry.registerTokenModifier('documentation', nls.localize('documentation', \"Style to use for references in documentation.\"), undefined);\n\tregistry.registerTokenModifier('static', nls.localize('static', \"Style to use for symbols that are static.\"), undefined);\n\tregistry.registerTokenModifier('abstract', nls.localize('abstract', \"Style to use for symbols that are abstract.\"), undefined);\n\tregistry.registerTokenModifier('deprecated', nls.localize('deprecated', \"Style to use for symbols that are deprecated.\"), undefined);\n\tregistry.registerTokenModifier('modification', nls.localize('modification', \"Style to use for write accesses.\"), undefined);\n\tregistry.registerTokenModifier('async', nls.localize('async', \"Style to use for symbols that are async.\"), undefined);\n\tregistry.registerTokenModifier('readonly', nls.localize('readonly', \"Style to use for symbols that are readonly.\"), undefined);\n\n\n\tregisterTokenStyleDefault('variable.readonly', [['variable.other.constant']]);\n\tregisterTokenStyleDefault('property.readonly', [['variable.other.constant.property']]);\n\tregisterTokenStyleDefault('type.defaultLibrary', [['support.type']]);\n\tregisterTokenStyleDefault('class.defaultLibrary', [['support.class']]);\n\tregisterTokenStyleDefault('interface.defaultLibrary', [['support.class']]);\n\tregisterTokenStyleDefault('variable.defaultLibrary', [['support.variable'], ['support.other.variable']]);\n\tregisterTokenStyleDefault('variable.defaultLibrary.readonly', [['support.constant']]);\n\tregisterTokenStyleDefault('property.defaultLibrary', [['support.variable.property']]);\n\tregisterTokenStyleDefault('property.defaultLibrary.readonly', [['support.constant.property']]);\n\tregisterTokenStyleDefault('function.defaultLibrary', [['support.function']]);\n\tregisterTokenStyleDefault('member.defaultLibrary', [['support.function']]);\n\treturn registry;\n}\n\nexport function getTokenClassificationRegistry(): ITokenClassificationRegistry {\n\treturn tokenClassificationRegistry;\n}\n\nfunction getStylingSchemeEntry(description?: string, deprecationMessage?: string): IJSONSchema {\n\treturn {\n\t\tdescription,\n\t\tdeprecationMessage,\n\t\tdefaultSnippets: [{ body: '${1:#ff0000}' }],\n\t\tanyOf: [\n\t\t\t{\n\t\t\t\ttype: 'string',\n\t\t\t\tformat: 'color-hex'\n\t\t\t},\n\t\t\t{\n\t\t\t\t$ref: '#definitions/style'\n\t\t\t}\n\t\t]\n\t};\n}\n\nexport const tokenStylingSchemaId = 'vscode://schemas/token-styling';\n\nlet schemaRegistry = platform.Registry.as<IJSONContributionRegistry>(JSONExtensions.JSONContribution);\nschemaRegistry.registerSchema(tokenStylingSchemaId, tokenClassificationRegistry.getTokenStylingSchema());\n\nconst delayer = new RunOnceScheduler(() => schemaRegistry.notifySchemaChanged(tokenStylingSchemaId), 200);\ntokenClassificationRegistry.onDidChangeSchema(() => {\n\tif (!delayer.isScheduled()) {\n\t\tdelayer.schedule();\n\t}\n});\n",
            "linguagem": "ts",
            "total_linhas": 594
        },
        "solucao_humana": {
            "patch_diff": "@@ -314,7 +314,7 @@ class TokenClassificationRegistry implements ITokenClassificationRegistry {\n \tconstructor() {\n \t\tthis.tokenTypeById = {};\n \t\tthis.tokenModifierById = {};\n-\t\tthis.typeHierarchy = {};\n+\t\tthis.typeHierarchy = Object.create(null);\n \t}\n \n \tpublic registerTokenType(id: string, description: string, superType?: string, deprecationMessage?: string): void {\n@@ -331,7 +331,7 @@ class TokenClassificationRegistry implements ITokenClassificationRegistry {\n \n \t\tconst stylingSchemeEntry = getStylingSchemeEntry(description, deprecationMessage);\n \t\tthis.tokenStylingSchema.properties[id] = stylingSchemeEntry;\n-\t\tthis.typeHierarchy = {};\n+\t\tthis.typeHierarchy = Object.create(null);\n \t}\n \n \tpublic registerTokenModifier(id: string, description: string, deprecationMessage?: string): void {\n@@ -398,7 +398,7 @@ class TokenClassificationRegistry implements ITokenClassificationRegistry {\n \tpublic deregisterTokenType(id: string): void {\n \t\tdelete this.tokenTypeById[id];\n \t\tdelete this.tokenStylingSchema.properties[id];\n-\t\tthis.typeHierarchy = {};\n+\t\tthis.typeHierarchy = Object.create(null);\n \t}\n \n \tpublic deregisterTokenModifier(id: string): void {",
            "apenas_linhas_adicionadas": [
                "\t\tthis.typeHierarchy = Object.create(null);",
                "\t\tthis.typeHierarchy = Object.create(null);",
                "\t\tthis.typeHierarchy = Object.create(null);"
            ]
        }
    },
    {
        "id": 106873,
        "url": "https://github.com/microsoft/vscode/pull/106873",
        "arquivo_caminho": "src/vs/editor/browser/controller/textAreaInput.ts",
        "descricao_bug": "Fixes: https://github.com/microsoft/vscode/issues/106392\r\n\r\nIn Firefox when inserting Emoji's using the macOS emoji input or using the compositor for characters with accents , , , etc. the character is inserted twice. Additionally, when adding an accented character the base character was also inserted.\r\n\r\nExamples:\r\n\r\n inserts \r\n inserts e\r\n\r\nThis change does two things:\r\n\r\n- It removes `this._onType.fire(typeInput);` from the compositionupdate event listener. If you are in the middle of a composition there is no need to fire off the event. This change fixes the unaccented character from being inserted. `` no longer inserts `e`.\r\n\r\n- In the composition end function `browser.isFirefox` is added to the conditional that resets this._textAreaState to the value of the text area. This is needed as the insert of the composition is handled by L294. The textarea needs to be updated correctly when the compositions ends.\r\n\r\nTested in Firefox (Windows 10, Ubuntu, macOS), Safari (macOS), Chrome (macOS), Edge Legacy (Windows 10), Edge (Windows 10)\r\n\r\n<!-- Thank you for submitting a Pull Request. Please: \r\n* Read our Pull Request guidelines:\r\n  https://github.com/Microsoft/vscode/wiki/How-to-Contribute#pull-requests.\r\n* Associate an issue with the Pull Request.\r\n* Ensure that the code is up-to-date with the `master` branch.\r\n* Include a description of the proposed changes and how to test them. \r\n-->\r\n\r\nThis PR fixes #\r\n",
        "contexto": {
            "codigo_completo_bugado": "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as browser from 'vs/base/browser/browser';\nimport * as dom from 'vs/base/browser/dom';\nimport { FastDomNode } from 'vs/base/browser/fastDomNode';\nimport { IKeyboardEvent } from 'vs/base/browser/keyboardEvent';\nimport { RunOnceScheduler } from 'vs/base/common/async';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { KeyCode } from 'vs/base/common/keyCodes';\nimport { Disposable, IDisposable } from 'vs/base/common/lifecycle';\nimport * as platform from 'vs/base/common/platform';\nimport * as strings from 'vs/base/common/strings';\nimport { ITextAreaWrapper, ITypeData, TextAreaState } from 'vs/editor/browser/controller/textAreaState';\nimport { Position } from 'vs/editor/common/core/position';\nimport { Selection } from 'vs/editor/common/core/selection';\nimport { BrowserFeatures } from 'vs/base/browser/canIUse';\n\nexport interface ICompositionData {\n\tdata: string;\n}\n\nexport const CopyOptions = {\n\tforceCopyWithSyntaxHighlighting: false\n};\n\nconst enum ReadFromTextArea {\n\tType,\n\tPaste\n}\n\nexport interface IPasteData {\n\ttext: string;\n\tmetadata: ClipboardStoredMetadata | null;\n}\n\nexport interface ClipboardDataToCopy {\n\tisFromEmptySelection: boolean;\n\tmulticursorText: string[] | null | undefined;\n\ttext: string;\n\thtml: string | null | undefined;\n\tmode: string | null;\n}\n\nexport interface ClipboardStoredMetadata {\n\tversion: 1;\n\tisFromEmptySelection: boolean | undefined;\n\tmulticursorText: string[] | null | undefined;\n\tmode: string | null;\n}\n\nexport interface ITextAreaInputHost {\n\tgetDataToCopy(html: boolean): ClipboardDataToCopy;\n\tgetScreenReaderContent(currentState: TextAreaState): TextAreaState;\n\tdeduceModelPosition(viewAnchorPosition: Position, deltaOffset: number, lineFeedCnt: number): Position;\n}\n\ninterface CompositionEvent extends UIEvent {\n\treadonly data: string;\n\treadonly locale: string;\n}\n\ninterface InMemoryClipboardMetadata {\n\tlastCopiedValue: string;\n\tdata: ClipboardStoredMetadata;\n}\n\n/**\n * Every time we write to the clipboard, we record a bit of extra metadata here.\n * Every time we read from the cipboard, if the text matches our last written text,\n * we can fetch the previous metadata.\n */\nexport class InMemoryClipboardMetadataManager {\n\tpublic static readonly INSTANCE = new InMemoryClipboardMetadataManager();\n\n\tprivate _lastState: InMemoryClipboardMetadata | null;\n\n\tconstructor() {\n\t\tthis._lastState = null;\n\t}\n\n\tpublic set(lastCopiedValue: string, data: ClipboardStoredMetadata): void {\n\t\tthis._lastState = { lastCopiedValue, data };\n\t}\n\n\tpublic get(pastedText: string): ClipboardStoredMetadata | null {\n\t\tif (this._lastState && this._lastState.lastCopiedValue === pastedText) {\n\t\t\t// match!\n\t\t\treturn this._lastState.data;\n\t\t}\n\t\tthis._lastState = null;\n\t\treturn null;\n\t}\n}\n\nexport interface ICompositionStartEvent {\n\tmoveOneCharacterLeft: boolean;\n}\n\n/**\n * Writes screen reader content to the textarea and is able to analyze its input events to generate:\n *  - onCut\n *  - onPaste\n *  - onType\n *\n * Composition events are generated for presentation purposes (composition input is reflected in onType).\n */\nexport class TextAreaInput extends Disposable {\n\n\tprivate _onFocus = this._register(new Emitter<void>());\n\tpublic readonly onFocus: Event<void> = this._onFocus.event;\n\n\tprivate _onBlur = this._register(new Emitter<void>());\n\tpublic readonly onBlur: Event<void> = this._onBlur.event;\n\n\tprivate _onKeyDown = this._register(new Emitter<IKeyboardEvent>());\n\tpublic readonly onKeyDown: Event<IKeyboardEvent> = this._onKeyDown.event;\n\n\tprivate _onKeyUp = this._register(new Emitter<IKeyboardEvent>());\n\tpublic readonly onKeyUp: Event<IKeyboardEvent> = this._onKeyUp.event;\n\n\tprivate _onCut = this._register(new Emitter<void>());\n\tpublic readonly onCut: Event<void> = this._onCut.event;\n\n\tprivate _onPaste = this._register(new Emitter<IPasteData>());\n\tpublic readonly onPaste: Event<IPasteData> = this._onPaste.event;\n\n\tprivate _onType = this._register(new Emitter<ITypeData>());\n\tpublic readonly onType: Event<ITypeData> = this._onType.event;\n\n\tprivate _onCompositionStart = this._register(new Emitter<ICompositionStartEvent>());\n\tpublic readonly onCompositionStart: Event<ICompositionStartEvent> = this._onCompositionStart.event;\n\n\tprivate _onCompositionUpdate = this._register(new Emitter<ICompositionData>());\n\tpublic readonly onCompositionUpdate: Event<ICompositionData> = this._onCompositionUpdate.event;\n\n\tprivate _onCompositionEnd = this._register(new Emitter<void>());\n\tpublic readonly onCompositionEnd: Event<void> = this._onCompositionEnd.event;\n\n\tprivate _onSelectionChangeRequest = this._register(new Emitter<Selection>());\n\tpublic readonly onSelectionChangeRequest: Event<Selection> = this._onSelectionChangeRequest.event;\n\n\t// ---\n\n\tprivate readonly _host: ITextAreaInputHost;\n\tprivate readonly _textArea: TextAreaWrapper;\n\tprivate readonly _asyncTriggerCut: RunOnceScheduler;\n\n\tprivate _textAreaState: TextAreaState;\n\tprivate _selectionChangeListener: IDisposable | null;\n\n\tprivate _hasFocus: boolean;\n\tprivate _isDoingComposition: boolean;\n\tprivate _nextCommand: ReadFromTextArea;\n\n\tconstructor(host: ITextAreaInputHost, private textArea: FastDomNode<HTMLTextAreaElement>) {\n\t\tsuper();\n\t\tthis._host = host;\n\t\tthis._textArea = this._register(new TextAreaWrapper(textArea));\n\t\tthis._asyncTriggerCut = this._register(new RunOnceScheduler(() => this._onCut.fire(), 0));\n\n\t\tthis._textAreaState = TextAreaState.EMPTY;\n\t\tthis._selectionChangeListener = null;\n\t\tthis.writeScreenReaderContent('ctor');\n\n\t\tthis._hasFocus = false;\n\t\tthis._isDoingComposition = false;\n\t\tthis._nextCommand = ReadFromTextArea.Type;\n\n\t\tlet lastKeyDown: IKeyboardEvent | null = null;\n\n\t\tthis._register(dom.addStandardDisposableListener(textArea.domNode, 'keydown', (e: IKeyboardEvent) => {\n\t\t\tif (e.keyCode === KeyCode.KEY_IN_COMPOSITION\n\t\t\t\t|| (this._isDoingComposition && e.keyCode === KeyCode.Backspace)) {\n\t\t\t\t// Stop propagation for keyDown events if the IME is processing key input\n\t\t\t\te.stopPropagation();\n\t\t\t}\n\n\t\t\tif (e.equals(KeyCode.Escape)) {\n\t\t\t\t// Prevent default always for `Esc`, otherwise it will generate a keypress\n\t\t\t\t// See https://msdn.microsoft.com/en-us/library/ie/ms536939(v=vs.85).aspx\n\t\t\t\te.preventDefault();\n\t\t\t}\n\n\t\t\tlastKeyDown = e;\n\t\t\tthis._onKeyDown.fire(e);\n\t\t}));\n\n\t\tthis._register(dom.addStandardDisposableListener(textArea.domNode, 'keyup', (e: IKeyboardEvent) => {\n\t\t\tthis._onKeyUp.fire(e);\n\t\t}));\n\n\t\tthis._register(dom.addDisposableListener(textArea.domNode, 'compositionstart', (e: CompositionEvent) => {\n\t\t\tif (this._isDoingComposition) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._isDoingComposition = true;\n\n\t\t\tlet moveOneCharacterLeft = false;\n\t\t\tif (\n\t\t\t\tplatform.isMacintosh\n\t\t\t\t&& lastKeyDown\n\t\t\t\t&& lastKeyDown.equals(KeyCode.KEY_IN_COMPOSITION)\n\t\t\t\t&& this._textAreaState.selectionStart === this._textAreaState.selectionEnd\n\t\t\t\t&& this._textAreaState.selectionStart > 0\n\t\t\t\t&& this._textAreaState.value.substr(this._textAreaState.selectionStart - 1, 1) === e.data\n\t\t\t) {\n\t\t\t\t// Handling long press case on macOS + arrow key => pretend the character was selected\n\t\t\t\tif (lastKeyDown.code === 'ArrowRight' || lastKeyDown.code === 'ArrowLeft') {\n\t\t\t\t\tmoveOneCharacterLeft = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (moveOneCharacterLeft) {\n\t\t\t\tthis._textAreaState = new TextAreaState(\n\t\t\t\t\tthis._textAreaState.value,\n\t\t\t\t\tthis._textAreaState.selectionStart - 1,\n\t\t\t\t\tthis._textAreaState.selectionEnd,\n\t\t\t\t\tthis._textAreaState.selectionStartPosition ? new Position(this._textAreaState.selectionStartPosition.lineNumber, this._textAreaState.selectionStartPosition.column - 1) : null,\n\t\t\t\t\tthis._textAreaState.selectionEndPosition\n\t\t\t\t);\n\t\t\t} else if (!browser.isEdge) {\n\t\t\t\t// In IE we cannot set .value when handling 'compositionstart' because the entire composition will get canceled.\n\t\t\t\tthis._setAndWriteTextAreaState('compositionstart', TextAreaState.EMPTY);\n\t\t\t}\n\n\t\t\tthis._onCompositionStart.fire({ moveOneCharacterLeft });\n\t\t}));\n\n\t\t/**\n\t\t * Deduce the typed input from a text area's value and the last observed state.\n\t\t */\n\t\tconst deduceInputFromTextAreaValue = (couldBeEmojiInput: boolean): [TextAreaState, ITypeData] => {\n\t\t\tconst oldState = this._textAreaState;\n\t\t\tconst newState = TextAreaState.readFromTextArea(this._textArea);\n\t\t\treturn [newState, TextAreaState.deduceInput(oldState, newState, couldBeEmojiInput)];\n\t\t};\n\n\t\t/**\n\t\t * Deduce the composition input from a string.\n\t\t */\n\t\tconst deduceComposition = (text: string): [TextAreaState, ITypeData] => {\n\t\t\tconst oldState = this._textAreaState;\n\t\t\tconst newState = TextAreaState.selectedText(text);\n\t\t\tconst typeInput: ITypeData = {\n\t\t\t\ttext: newState.value,\n\t\t\t\treplaceCharCnt: oldState.selectionEnd - oldState.selectionStart\n\t\t\t};\n\t\t\treturn [newState, typeInput];\n\t\t};\n\n\t\tconst compositionDataInValid = (locale: string): boolean => {\n\t\t\t// https://github.com/microsoft/monaco-editor/issues/339\n\t\t\t// Multi-part Japanese compositions reset cursor in Edge/IE, Chinese and Korean IME don't have this issue.\n\t\t\t// The reason that we can't use this path for all CJK IME is IE and Edge behave differently when handling Korean IME,\n\t\t\t// which breaks this path of code.\n\t\t\tif (browser.isEdge && locale === 'ja') {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t};\n\n\t\tthis._register(dom.addDisposableListener(textArea.domNode, 'compositionupdate', (e: CompositionEvent) => {\n\t\t\tif (compositionDataInValid(e.locale)) {\n\t\t\t\tconst [newState, typeInput] = deduceInputFromTextAreaValue(/*couldBeEmojiInput*/false);\n\t\t\t\tthis._textAreaState = newState;\n\t\t\t\tthis._onType.fire(typeInput);\n\t\t\t\tthis._onCompositionUpdate.fire(e);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst [newState, typeInput] = deduceComposition(e.data || '');\n\t\t\tthis._textAreaState = newState;\n\t\t\tthis._onType.fire(typeInput);\n\t\t\tthis._onCompositionUpdate.fire(e);\n\t\t}));\n\n\t\tthis._register(dom.addDisposableListener(textArea.domNode, 'compositionend', (e: CompositionEvent) => {\n\t\t\t// https://github.com/microsoft/monaco-editor/issues/1663\n\t\t\t// On iOS 13.2, Chinese system IME randomly trigger an additional compositionend event with empty data\n\t\t\tif (!this._isDoingComposition) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (compositionDataInValid(e.locale)) {\n\t\t\t\t// https://github.com/microsoft/monaco-editor/issues/339\n\t\t\t\tconst [newState, typeInput] = deduceInputFromTextAreaValue(/*couldBeEmojiInput*/false);\n\t\t\t\tthis._textAreaState = newState;\n\t\t\t\tthis._onType.fire(typeInput);\n\t\t\t} else {\n\t\t\t\tconst [newState, typeInput] = deduceComposition(e.data || '');\n\t\t\t\tthis._textAreaState = newState;\n\t\t\t\tthis._onType.fire(typeInput);\n\t\t\t}\n\n\t\t\t// Due to isEdgeOrIE (where the textarea was not cleared initially) and isChrome (the textarea is not updated correctly when composition ends)\n\t\t\t// we cannot assume the text at the end consists only of the composited text\n\t\t\tif (browser.isEdge || browser.isChrome) {\n\t\t\t\tthis._textAreaState = TextAreaState.readFromTextArea(this._textArea);\n\t\t\t}\n\n\t\t\tif (!this._isDoingComposition) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._isDoingComposition = false;\n\n\t\t\tthis._onCompositionEnd.fire();\n\t\t}));\n\n\t\tthis._register(dom.addDisposableListener(textArea.domNode, 'input', () => {\n\t\t\t// Pretend here we touched the text area, as the `input` event will most likely\n\t\t\t// result in a `selectionchange` event which we want to ignore\n\t\t\tthis._textArea.setIgnoreSelectionChangeTime('received input event');\n\n\t\t\tif (this._isDoingComposition) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst [newState, typeInput] = deduceInputFromTextAreaValue(/*couldBeEmojiInput*/platform.isMacintosh);\n\t\t\tif (typeInput.replaceCharCnt === 0 && typeInput.text.length === 1 && strings.isHighSurrogate(typeInput.text.charCodeAt(0))) {\n\t\t\t\t// Ignore invalid input but keep it around for next time\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._textAreaState = newState;\n\t\t\tif (this._nextCommand === ReadFromTextArea.Type) {\n\t\t\t\tif (typeInput.text !== '') {\n\t\t\t\t\tthis._onType.fire(typeInput);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (typeInput.text !== '' || typeInput.replaceCharCnt !== 0) {\n\t\t\t\t\tthis._firePaste(typeInput.text, null);\n\t\t\t\t}\n\t\t\t\tthis._nextCommand = ReadFromTextArea.Type;\n\t\t\t}\n\t\t}));\n\n\t\t// --- Clipboard operations\n\n\t\tthis._register(dom.addDisposableListener(textArea.domNode, 'cut', (e: ClipboardEvent) => {\n\t\t\t// Pretend here we touched the text area, as the `cut` event will most likely\n\t\t\t// result in a `selectionchange` event which we want to ignore\n\t\t\tthis._textArea.setIgnoreSelectionChangeTime('received cut event');\n\n\t\t\tthis._ensureClipboardGetsEditorSelection(e);\n\t\t\tthis._asyncTriggerCut.schedule();\n\t\t}));\n\n\t\tthis._register(dom.addDisposableListener(textArea.domNode, 'copy', (e: ClipboardEvent) => {\n\t\t\tthis._ensureClipboardGetsEditorSelection(e);\n\t\t}));\n\n\t\tthis._register(dom.addDisposableListener(textArea.domNode, 'paste', (e: ClipboardEvent) => {\n\t\t\t// Pretend here we touched the text area, as the `paste` event will most likely\n\t\t\t// result in a `selectionchange` event which we want to ignore\n\t\t\tthis._textArea.setIgnoreSelectionChangeTime('received paste event');\n\n\t\t\tif (ClipboardEventUtils.canUseTextData(e)) {\n\t\t\t\tconst [pastePlainText, metadata] = ClipboardEventUtils.getTextData(e);\n\t\t\t\tif (pastePlainText !== '') {\n\t\t\t\t\tthis._firePaste(pastePlainText, metadata);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this._textArea.getSelectionStart() !== this._textArea.getSelectionEnd()) {\n\t\t\t\t\t// Clean up the textarea, to get a clean paste\n\t\t\t\t\tthis._setAndWriteTextAreaState('paste', TextAreaState.EMPTY);\n\t\t\t\t}\n\t\t\t\tthis._nextCommand = ReadFromTextArea.Paste;\n\t\t\t}\n\t\t}));\n\n\t\tthis._register(dom.addDisposableListener(textArea.domNode, 'focus', () => {\n\t\t\tthis._setHasFocus(true);\n\t\t}));\n\t\tthis._register(dom.addDisposableListener(textArea.domNode, 'blur', () => {\n\t\t\tthis._setHasFocus(false);\n\t\t}));\n\t}\n\n\tprivate _installSelectionChangeListener(): IDisposable {\n\t\t// See https://github.com/microsoft/vscode/issues/27216 and https://github.com/microsoft/vscode/issues/98256\n\t\t// When using a Braille display, it is possible for users to reposition the\n\t\t// system caret. This is reflected in Chrome as a `selectionchange` event.\n\t\t//\n\t\t// The `selectionchange` event appears to be emitted under numerous other circumstances,\n\t\t// so it is quite a challenge to distinguish a `selectionchange` coming in from a user\n\t\t// using a Braille display from all the other cases.\n\t\t//\n\t\t// The problems with the `selectionchange` event are:\n\t\t//  * the event is emitted when the textarea is focused programmatically -- textarea.focus()\n\t\t//  * the event is emitted when the selection is changed in the textarea programmatically -- textarea.setSelectionRange(...)\n\t\t//  * the event is emitted when the value of the textarea is changed programmatically -- textarea.value = '...'\n\t\t//  * the event is emitted when tabbing into the textarea\n\t\t//  * the event is emitted asynchronously (sometimes with a delay as high as a few tens of ms)\n\t\t//  * the event sometimes comes in bursts for a single logical textarea operation\n\n\t\t// `selectionchange` events often come multiple times for a single logical change\n\t\t// so throttle multiple `selectionchange` events that burst in a short period of time.\n\t\tlet previousSelectionChangeEventTime = 0;\n\t\treturn dom.addDisposableListener(document, 'selectionchange', (e) => {\n\t\t\tif (!this._hasFocus) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this._isDoingComposition) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!browser.isChrome) {\n\t\t\t\t// Support only for Chrome until testing happens on other browsers\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst now = Date.now();\n\n\t\t\tconst delta1 = now - previousSelectionChangeEventTime;\n\t\t\tpreviousSelectionChangeEventTime = now;\n\t\t\tif (delta1 < 5) {\n\t\t\t\t// received another `selectionchange` event within 5ms of the previous `selectionchange` event\n\t\t\t\t// => ignore it\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst delta2 = now - this._textArea.getIgnoreSelectionChangeTime();\n\t\t\tthis._textArea.resetSelectionChangeTime();\n\t\t\tif (delta2 < 100) {\n\t\t\t\t// received a `selectionchange` event within 100ms since we touched the textarea\n\t\t\t\t// => ignore it, since we caused it\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!this._textAreaState.selectionStartPosition || !this._textAreaState.selectionEndPosition) {\n\t\t\t\t// Cannot correlate a position in the textarea with a position in the editor...\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst newValue = this._textArea.getValue();\n\t\t\tif (this._textAreaState.value !== newValue) {\n\t\t\t\t// Cannot correlate a position in the textarea with a position in the editor...\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst newSelectionStart = this._textArea.getSelectionStart();\n\t\t\tconst newSelectionEnd = this._textArea.getSelectionEnd();\n\t\t\tif (this._textAreaState.selectionStart === newSelectionStart && this._textAreaState.selectionEnd === newSelectionEnd) {\n\t\t\t\t// Nothing to do...\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst _newSelectionStartPosition = this._textAreaState.deduceEditorPosition(newSelectionStart);\n\t\t\tconst newSelectionStartPosition = this._host.deduceModelPosition(_newSelectionStartPosition[0]!, _newSelectionStartPosition[1], _newSelectionStartPosition[2]);\n\n\t\t\tconst _newSelectionEndPosition = this._textAreaState.deduceEditorPosition(newSelectionEnd);\n\t\t\tconst newSelectionEndPosition = this._host.deduceModelPosition(_newSelectionEndPosition[0]!, _newSelectionEndPosition[1], _newSelectionEndPosition[2]);\n\n\t\t\tconst newSelection = new Selection(\n\t\t\t\tnewSelectionStartPosition.lineNumber, newSelectionStartPosition.column,\n\t\t\t\tnewSelectionEndPosition.lineNumber, newSelectionEndPosition.column\n\t\t\t);\n\n\t\t\tthis._onSelectionChangeRequest.fire(newSelection);\n\t\t});\n\t}\n\n\tpublic dispose(): void {\n\t\tsuper.dispose();\n\t\tif (this._selectionChangeListener) {\n\t\t\tthis._selectionChangeListener.dispose();\n\t\t\tthis._selectionChangeListener = null;\n\t\t}\n\t}\n\n\tpublic focusTextArea(): void {\n\t\t// Setting this._hasFocus and writing the screen reader content\n\t\t// will result in a focus() and setSelectionRange() in the textarea\n\t\tthis._setHasFocus(true);\n\n\t\t// If the editor is off DOM, focus cannot be really set, so let's double check that we have managed to set the focus\n\t\tthis.refreshFocusState();\n\t}\n\n\tpublic isFocused(): boolean {\n\t\treturn this._hasFocus;\n\t}\n\n\tpublic refreshFocusState(): void {\n\t\tconst shadowRoot = dom.getShadowRoot(this.textArea.domNode);\n\t\tif (shadowRoot) {\n\t\t\tthis._setHasFocus(shadowRoot.activeElement === this.textArea.domNode);\n\t\t} else if (dom.isInDOM(this.textArea.domNode)) {\n\t\t\tthis._setHasFocus(document.activeElement === this.textArea.domNode);\n\t\t} else {\n\t\t\tthis._setHasFocus(false);\n\t\t}\n\t}\n\n\tprivate _setHasFocus(newHasFocus: boolean): void {\n\t\tif (this._hasFocus === newHasFocus) {\n\t\t\t// no change\n\t\t\treturn;\n\t\t}\n\t\tthis._hasFocus = newHasFocus;\n\n\t\tif (this._selectionChangeListener) {\n\t\t\tthis._selectionChangeListener.dispose();\n\t\t\tthis._selectionChangeListener = null;\n\t\t}\n\t\tif (this._hasFocus) {\n\t\t\tthis._selectionChangeListener = this._installSelectionChangeListener();\n\t\t}\n\n\t\tif (this._hasFocus) {\n\t\t\tif (browser.isEdge) {\n\t\t\t\t// Edge has a bug where setting the selection range while the focus event\n\t\t\t\t// is dispatching doesn't work. To reproduce, \"tab into\" the editor.\n\t\t\t\tthis._setAndWriteTextAreaState('focusgain', TextAreaState.EMPTY);\n\t\t\t} else {\n\t\t\t\tthis.writeScreenReaderContent('focusgain');\n\t\t\t}\n\t\t}\n\n\t\tif (this._hasFocus) {\n\t\t\tthis._onFocus.fire();\n\t\t} else {\n\t\t\tthis._onBlur.fire();\n\t\t}\n\t}\n\n\tprivate _setAndWriteTextAreaState(reason: string, textAreaState: TextAreaState): void {\n\t\tif (!this._hasFocus) {\n\t\t\ttextAreaState = textAreaState.collapseSelection();\n\t\t}\n\n\t\ttextAreaState.writeToTextArea(reason, this._textArea, this._hasFocus);\n\t\tthis._textAreaState = textAreaState;\n\t}\n\n\tpublic writeScreenReaderContent(reason: string): void {\n\t\tif (this._isDoingComposition) {\n\t\t\t// Do not write to the text area when doing composition\n\t\t\treturn;\n\t\t}\n\n\t\tthis._setAndWriteTextAreaState(reason, this._host.getScreenReaderContent(this._textAreaState));\n\t}\n\n\tprivate _ensureClipboardGetsEditorSelection(e: ClipboardEvent): void {\n\t\tconst dataToCopy = this._host.getDataToCopy(ClipboardEventUtils.canUseTextData(e) && BrowserFeatures.clipboard.richText);\n\t\tconst storedMetadata: ClipboardStoredMetadata = {\n\t\t\tversion: 1,\n\t\t\tisFromEmptySelection: dataToCopy.isFromEmptySelection,\n\t\t\tmulticursorText: dataToCopy.multicursorText,\n\t\t\tmode: dataToCopy.mode\n\t\t};\n\t\tInMemoryClipboardMetadataManager.INSTANCE.set(\n\t\t\t// When writing \"LINE\\r\\n\" to the clipboard and then pasting,\n\t\t\t// Firefox pastes \"LINE\\n\", so let's work around this quirk\n\t\t\t(browser.isFirefox ? dataToCopy.text.replace(/\\r\\n/g, '\\n') : dataToCopy.text),\n\t\t\tstoredMetadata\n\t\t);\n\n\t\tif (!ClipboardEventUtils.canUseTextData(e)) {\n\t\t\t// Looks like an old browser. The strategy is to place the text\n\t\t\t// we'd like to be copied to the clipboard in the textarea and select it.\n\t\t\tthis._setAndWriteTextAreaState('copy or cut', TextAreaState.selectedText(dataToCopy.text));\n\t\t\treturn;\n\t\t}\n\n\t\tClipboardEventUtils.setTextData(e, dataToCopy.text, dataToCopy.html, storedMetadata);\n\t}\n\n\tprivate _firePaste(text: string, metadata: ClipboardStoredMetadata | null): void {\n\t\tif (!metadata) {\n\t\t\t// try the in-memory store\n\t\t\tmetadata = InMemoryClipboardMetadataManager.INSTANCE.get(text);\n\t\t}\n\t\tthis._onPaste.fire({\n\t\t\ttext: text,\n\t\t\tmetadata: metadata\n\t\t});\n\t}\n}\n\nclass ClipboardEventUtils {\n\n\tpublic static canUseTextData(e: ClipboardEvent): boolean {\n\t\tif (e.clipboardData) {\n\t\t\treturn true;\n\t\t}\n\t\tif ((<any>window).clipboardData) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic static getTextData(e: ClipboardEvent): [string, ClipboardStoredMetadata | null] {\n\t\tif (e.clipboardData) {\n\t\t\te.preventDefault();\n\n\t\t\tconst text = e.clipboardData.getData('text/plain');\n\t\t\tlet metadata: ClipboardStoredMetadata | null = null;\n\t\t\tconst rawmetadata = e.clipboardData.getData('vscode-editor-data');\n\t\t\tif (typeof rawmetadata === 'string') {\n\t\t\t\ttry {\n\t\t\t\t\tmetadata = <ClipboardStoredMetadata>JSON.parse(rawmetadata);\n\t\t\t\t\tif (metadata.version !== 1) {\n\t\t\t\t\t\tmetadata = null;\n\t\t\t\t\t}\n\t\t\t\t} catch (err) {\n\t\t\t\t\t// no problem!\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn [text, metadata];\n\t\t}\n\n\t\tif ((<any>window).clipboardData) {\n\t\t\te.preventDefault();\n\t\t\tconst text: string = (<any>window).clipboardData.getData('Text');\n\t\t\treturn [text, null];\n\t\t}\n\n\t\tthrow new Error('ClipboardEventUtils.getTextData: Cannot use text data!');\n\t}\n\n\tpublic static setTextData(e: ClipboardEvent, text: string, html: string | null | undefined, metadata: ClipboardStoredMetadata): void {\n\t\tif (e.clipboardData) {\n\t\t\te.clipboardData.setData('text/plain', text);\n\t\t\tif (typeof html === 'string') {\n\t\t\t\te.clipboardData.setData('text/html', html);\n\t\t\t}\n\t\t\te.clipboardData.setData('vscode-editor-data', JSON.stringify(metadata));\n\t\t\te.preventDefault();\n\t\t\treturn;\n\t\t}\n\n\t\tif ((<any>window).clipboardData) {\n\t\t\t(<any>window).clipboardData.setData('Text', text);\n\t\t\te.preventDefault();\n\t\t\treturn;\n\t\t}\n\n\t\tthrow new Error('ClipboardEventUtils.setTextData: Cannot use text data!');\n\t}\n}\n\nclass TextAreaWrapper extends Disposable implements ITextAreaWrapper {\n\n\tprivate readonly _actual: FastDomNode<HTMLTextAreaElement>;\n\tprivate _ignoreSelectionChangeTime: number;\n\n\tconstructor(_textArea: FastDomNode<HTMLTextAreaElement>) {\n\t\tsuper();\n\t\tthis._actual = _textArea;\n\t\tthis._ignoreSelectionChangeTime = 0;\n\t}\n\n\tpublic setIgnoreSelectionChangeTime(reason: string): void {\n\t\tthis._ignoreSelectionChangeTime = Date.now();\n\t}\n\n\tpublic getIgnoreSelectionChangeTime(): number {\n\t\treturn this._ignoreSelectionChangeTime;\n\t}\n\n\tpublic resetSelectionChangeTime(): void {\n\t\tthis._ignoreSelectionChangeTime = 0;\n\t}\n\n\tpublic getValue(): string {\n\t\t// console.log('current value: ' + this._textArea.value);\n\t\treturn this._actual.domNode.value;\n\t}\n\n\tpublic setValue(reason: string, value: string): void {\n\t\tconst textArea = this._actual.domNode;\n\t\tif (textArea.value === value) {\n\t\t\t// No change\n\t\t\treturn;\n\t\t}\n\t\t// console.log('reason: ' + reason + ', current value: ' + textArea.value + ' => new value: ' + value);\n\t\tthis.setIgnoreSelectionChangeTime('setValue');\n\t\ttextArea.value = value;\n\t}\n\n\tpublic getSelectionStart(): number {\n\t\treturn this._actual.domNode.selectionStart;\n\t}\n\n\tpublic getSelectionEnd(): number {\n\t\treturn this._actual.domNode.selectionEnd;\n\t}\n\n\tpublic setSelectionRange(reason: string, selectionStart: number, selectionEnd: number): void {\n\t\tconst textArea = this._actual.domNode;\n\n\t\tlet activeElement: Element | null = null;\n\t\tconst shadowRoot = dom.getShadowRoot(textArea);\n\t\tif (shadowRoot) {\n\t\t\tactiveElement = shadowRoot.activeElement;\n\t\t} else {\n\t\t\tactiveElement = document.activeElement;\n\t\t}\n\n\t\tconst currentIsFocused = (activeElement === textArea);\n\t\tconst currentSelectionStart = textArea.selectionStart;\n\t\tconst currentSelectionEnd = textArea.selectionEnd;\n\n\t\tif (currentIsFocused && currentSelectionStart === selectionStart && currentSelectionEnd === selectionEnd) {\n\t\t\t// No change\n\t\t\t// Firefox iframe bug https://github.com/microsoft/monaco-editor/issues/643#issuecomment-367871377\n\t\t\tif (browser.isFirefox && window.parent !== window) {\n\t\t\t\ttextArea.focus();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// console.log('reason: ' + reason + ', setSelectionRange: ' + selectionStart + ' -> ' + selectionEnd);\n\n\t\tif (currentIsFocused) {\n\t\t\t// No need to focus, only need to change the selection range\n\t\t\tthis.setIgnoreSelectionChangeTime('setSelectionRange');\n\t\t\ttextArea.setSelectionRange(selectionStart, selectionEnd);\n\t\t\tif (browser.isFirefox && window.parent !== window) {\n\t\t\t\ttextArea.focus();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// If the focus is outside the textarea, browsers will try really hard to reveal the textarea.\n\t\t// Here, we try to undo the browser's desperate reveal.\n\t\ttry {\n\t\t\tconst scrollState = dom.saveParentsScrollTop(textArea);\n\t\t\tthis.setIgnoreSelectionChangeTime('setSelectionRange');\n\t\t\ttextArea.focus();\n\t\t\ttextArea.setSelectionRange(selectionStart, selectionEnd);\n\t\t\tdom.restoreParentsScrollTop(textArea, scrollState);\n\t\t} catch (e) {\n\t\t\t// Sometimes IE throws when setting selection (e.g. textarea is off-DOM)\n\t\t}\n\t}\n}\n",
            "linguagem": "ts",
            "total_linhas": 743
        },
        "solucao_humana": {
            "patch_diff": "@@ -297,7 +297,7 @@ export class TextAreaInput extends Disposable {\n \n \t\t\t// Due to isEdgeOrIE (where the textarea was not cleared initially) and isChrome (the textarea is not updated correctly when composition ends)\n \t\t\t// we cannot assume the text at the end consists only of the composited text\n-\t\t\tif (browser.isEdge || browser.isChrome) {\n+\t\t\tif (browser.isEdge || browser.isChrome|| browser.isFirefox) {\n \t\t\t\tthis._textAreaState = TextAreaState.readFromTextArea(this._textArea);\n \t\t\t}\n ",
            "apenas_linhas_adicionadas": [
                "\t\t\tif (browser.isEdge || browser.isChrome|| browser.isFirefox) {"
            ]
        }
    }
]