{
        "id": 54320,
        "url": "https://github.com/microsoft/vscode/pull/54320",
        "descricao_bug": "Fixes: #54292\r\n\r\nCalculation for drop-down needs to use offsetWidth on the parent select to not include\r\nmargins.",
        "contexto": {
            "codigo_completo_bugado": "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport 'vs/css!./selectBoxCustom';\n\nimport * as nls from 'vs/nls';\nimport { IDisposable, dispose } from 'vs/base/common/lifecycle';\nimport { Event, Emitter, chain } from 'vs/base/common/event';\nimport { KeyCode, KeyCodeUtils } from 'vs/base/common/keyCodes';\nimport { StandardKeyboardEvent } from 'vs/base/browser/keyboardEvent';\nimport * as dom from 'vs/base/browser/dom';\nimport * as arrays from 'vs/base/common/arrays';\nimport { IContextViewProvider, AnchorPosition } from 'vs/base/browser/ui/contextview/contextview';\nimport { List } from 'vs/base/browser/ui/list/listWidget';\nimport { IVirtualDelegate, IRenderer } from 'vs/base/browser/ui/list/list';\nimport { domEvent } from 'vs/base/browser/event';\nimport { ScrollbarVisibility } from 'vs/base/common/scrollable';\nimport { ISelectBoxDelegate, ISelectBoxOptions, ISelectBoxStyles, ISelectData } from 'vs/base/browser/ui/selectBox/selectBox';\nimport { isMacintosh } from 'vs/base/common/platform';\n\nconst $ = dom.$;\n\nconst SELECT_OPTION_ENTRY_TEMPLATE_ID = 'selectOption.entry.template';\n\nexport interface ISelectOptionItem {\n\toptionText: string;\n\toptionDisabled: boolean;\n}\n\ninterface ISelectListTemplateData {\n\troot: HTMLElement;\n\toptionText: HTMLElement;\n\tdisposables: IDisposable[];\n}\n\nclass SelectListRenderer implements IRenderer<ISelectOptionItem, ISelectListTemplateData> {\n\n\tget templateId(): string { return SELECT_OPTION_ENTRY_TEMPLATE_ID; }\n\n\tconstructor() { }\n\n\trenderTemplate(container: HTMLElement): any {\n\t\tconst data = <ISelectListTemplateData>Object.create(null);\n\t\tdata.disposables = [];\n\t\tdata.root = container;\n\t\tdata.optionText = dom.append(container, $('.option-text'));\n\n\t\treturn data;\n\t}\n\n\trenderElement(element: ISelectOptionItem, index: number, templateData: ISelectListTemplateData): void {\n\t\tconst data = <ISelectListTemplateData>templateData;\n\t\tconst optionText = (<ISelectOptionItem>element).optionText;\n\t\tconst optionDisabled = (<ISelectOptionItem>element).optionDisabled;\n\n\t\tdata.optionText.textContent = optionText;\n\t\tdata.root.setAttribute('aria-label', nls.localize('selectAriaOption', \"{0}\", optionText));\n\n\t\t// pseudo-select disabled option\n\t\tif (optionDisabled) {\n\t\t\tdom.addClass((<HTMLElement>data.root), 'option-disabled');\n\t\t} else {\n\t\t\t// Make sure we do class removal from prior template rendering\n\t\t\tdom.removeClass((<HTMLElement>data.root), 'option-disabled');\n\t\t}\n\t}\n\n\tdisposeElement(): void {\n\t\t// noop\n\t}\n\n\tdisposeTemplate(templateData: ISelectListTemplateData): void {\n\t\ttemplateData.disposables = dispose(templateData.disposables);\n\t}\n}\n\nexport class SelectBoxList implements ISelectBoxDelegate, IVirtualDelegate<ISelectOptionItem> {\n\n\tprivate static readonly DEFAULT_DROPDOWN_MINIMUM_BOTTOM_MARGIN = 32;\n\tprivate static readonly DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN = 42;\n\tprivate static readonly DEFAULT_MINIMUM_VISIBLE_OPTIONS = 3;\n\n\tprivate _isVisible: boolean;\n\tprivate selectBoxOptions: ISelectBoxOptions;\n\tprivate selectElement: HTMLSelectElement;\n\tprivate options: string[];\n\tprivate selected: number;\n\tprivate disabledOptionIndex: number;\n\tprivate readonly _onDidSelect: Emitter<ISelectData>;\n\tprivate toDispose: IDisposable[];\n\tprivate styles: ISelectBoxStyles;\n\tprivate listRenderer: SelectListRenderer;\n\tprivate contextViewProvider: IContextViewProvider;\n\tprivate selectDropDownContainer: HTMLElement;\n\tprivate styleElement: HTMLStyleElement;\n\tprivate selectList: List<ISelectOptionItem>;\n\tprivate selectDropDownListContainer: HTMLElement;\n\tprivate widthControlElement: HTMLElement;\n\tprivate _currentSelection: number;\n\tprivate _dropDownPosition: AnchorPosition;\n\n\tconstructor(options: string[], selected: number, contextViewProvider: IContextViewProvider, styles: ISelectBoxStyles, selectBoxOptions?: ISelectBoxOptions) {\n\n\t\tthis.toDispose = [];\n\t\tthis._isVisible = false;\n\t\tthis.selectBoxOptions = selectBoxOptions || Object.create(null);\n\n\t\tif (typeof this.selectBoxOptions.minBottomMargin !== 'number') {\n\t\t\tthis.selectBoxOptions.minBottomMargin = SelectBoxList.DEFAULT_DROPDOWN_MINIMUM_BOTTOM_MARGIN;\n\t\t} else if (this.selectBoxOptions.minBottomMargin < 0) {\n\t\t\tthis.selectBoxOptions.minBottomMargin = 0;\n\t\t}\n\n\t\tthis.selectElement = document.createElement('select');\n\t\t// Use custom CSS vars for padding calculation\n\t\tthis.selectElement.className = 'monaco-select-box monaco-select-box-dropdown-padding';\n\n\t\tthis._onDidSelect = new Emitter<ISelectData>();\n\t\tthis.styles = styles;\n\n\t\tthis.registerListeners();\n\t\tthis.constructSelectDropDown(contextViewProvider);\n\n\t\tthis.setOptions(options, selected);\n\t}\n\n\t// IDelegate - List renderer\n\n\tgetHeight(): number {\n\t\treturn 18;\n\t}\n\n\tgetTemplateId(): string {\n\t\treturn SELECT_OPTION_ENTRY_TEMPLATE_ID;\n\t}\n\n\tprivate constructSelectDropDown(contextViewProvider: IContextViewProvider) {\n\n\t\t// SetUp ContextView container to hold select Dropdown\n\t\tthis.contextViewProvider = contextViewProvider;\n\t\tthis.selectDropDownContainer = dom.$('.monaco-select-box-dropdown-container');\n\t\t// Use custom CSS vars for padding calculation (shared with parent select)\n\t\tdom.addClass(this.selectDropDownContainer, 'monaco-select-box-dropdown-padding');\n\t\t// Setup list for drop-down select\n\t\tthis.createSelectList(this.selectDropDownContainer);\n\n\t\t// Create span flex box item/div we can measure and control\n\t\tlet widthControlOuterDiv = dom.append(this.selectDropDownContainer, $('.select-box-dropdown-container-width-control'));\n\t\tlet widthControlInnerDiv = dom.append(widthControlOuterDiv, $('.width-control-div'));\n\t\tthis.widthControlElement = document.createElement('span');\n\t\tthis.widthControlElement.className = 'option-text-width-control';\n\t\tdom.append(widthControlInnerDiv, this.widthControlElement);\n\n\t\t// Always default to below position\n\t\tthis._dropDownPosition = AnchorPosition.BELOW;\n\n\t\t// Inline stylesheet for themes\n\t\tthis.styleElement = dom.createStyleSheet(this.selectDropDownContainer);\n\t}\n\n\tprivate registerListeners() {\n\n\t\t// Parent native select keyboard listeners\n\n\t\tthis.toDispose.push(dom.addStandardDisposableListener(this.selectElement, 'change', (e) => {\n\t\t\tthis.selectElement.title = e.target.value;\n\t\t\tthis._onDidSelect.fire({\n\t\t\t\tindex: e.target.selectedIndex,\n\t\t\t\tselected: e.target.value\n\t\t\t});\n\t\t}));\n\n\t\t// Have to implement both keyboard and mouse controllers to handle disabled options\n\t\t// Intercept mouse events to override normal select actions on parents\n\n\t\tthis.toDispose.push(dom.addDisposableListener(this.selectElement, dom.EventType.CLICK, (e) => {\n\t\t\tdom.EventHelper.stop(e);\n\n\t\t\tif (this._isVisible) {\n\t\t\t\tthis.hideSelectDropDown(true);\n\t\t\t} else {\n\t\t\t\tthis.showSelectDropDown();\n\t\t\t}\n\t\t}));\n\n\t\tthis.toDispose.push(dom.addDisposableListener(this.selectElement, dom.EventType.MOUSE_DOWN, (e) => {\n\t\t\tdom.EventHelper.stop(e);\n\t\t}));\n\n\t\t// Intercept keyboard handling\n\n\t\tthis.toDispose.push(dom.addDisposableListener(this.selectElement, dom.EventType.KEY_DOWN, (e: KeyboardEvent) => {\n\t\t\tconst event = new StandardKeyboardEvent(e);\n\t\t\tlet showDropDown = false;\n\n\t\t\t// Create and drop down select list on keyboard select\n\t\t\tif (isMacintosh) {\n\t\t\t\tif (event.keyCode === KeyCode.DownArrow || event.keyCode === KeyCode.UpArrow || event.keyCode === KeyCode.Space || event.keyCode === KeyCode.Enter) {\n\t\t\t\t\tshowDropDown = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (event.keyCode === KeyCode.DownArrow && event.altKey || event.keyCode === KeyCode.UpArrow && event.altKey || event.keyCode === KeyCode.Space || event.keyCode === KeyCode.Enter) {\n\t\t\t\t\tshowDropDown = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (showDropDown) {\n\t\t\t\tthis.showSelectDropDown();\n\t\t\t\tdom.EventHelper.stop(e);\n\t\t\t}\n\t\t}));\n\t}\n\n\tpublic get onDidSelect(): Event<ISelectData> {\n\t\treturn this._onDidSelect.event;\n\t}\n\n\tpublic setOptions(options: string[], selected?: number, disabled?: number): void {\n\n\t\tif (!this.options || !arrays.equals(this.options, options)) {\n\t\t\tthis.options = options;\n\t\t\tthis.selectElement.options.length = 0;\n\n\t\t\tlet i = 0;\n\t\t\tthis.options.forEach((option) => {\n\t\t\t\tthis.selectElement.add(this.createOption(option, i, disabled === i++));\n\t\t\t});\n\n\t\t\t// Mirror options in drop-down\n\t\t\t// Populate select list for non-native select mode\n\t\t\tif (this.selectList && !!this.options) {\n\t\t\t\tlet listEntries: ISelectOptionItem[];\n\n\t\t\t\tlistEntries = [];\n\t\t\t\tif (disabled !== undefined) {\n\t\t\t\t\tthis.disabledOptionIndex = disabled;\n\t\t\t\t}\n\t\t\t\tfor (let index = 0; index < this.options.length; index++) {\n\t\t\t\t\tconst element = this.options[index];\n\t\t\t\t\tlet optionDisabled: boolean;\n\t\t\t\t\tindex === this.disabledOptionIndex ? optionDisabled = true : optionDisabled = false;\n\t\t\t\t\tlistEntries.push({ optionText: element, optionDisabled: optionDisabled });\n\t\t\t\t}\n\n\t\t\t\tthis.selectList.splice(0, this.selectList.length, listEntries);\n\t\t\t}\n\t\t}\n\n\t\tif (selected !== undefined) {\n\t\t\tthis.select(selected);\n\t\t\t// Set current = selected since this is not necessarily a user exit\n\t\t\tthis._currentSelection = this.selected;\n\t\t}\n\t}\n\n\tpublic select(index: number): void {\n\n\t\tif (index >= 0 && index < this.options.length) {\n\t\t\tthis.selected = index;\n\t\t} else if (index > this.options.length - 1) {\n\t\t\t// Adjust index to end of list\n\t\t\t// This could make client out of sync with the select\n\t\t\tthis.select(this.options.length - 1);\n\t\t} else if (this.selected < 0) {\n\t\t\tthis.selected = 0;\n\t\t}\n\n\t\tthis.selectElement.selectedIndex = this.selected;\n\t\tthis.selectElement.title = this.options[this.selected];\n\t}\n\n\tpublic focus(): void {\n\t\tif (this.selectElement) {\n\t\t\tthis.selectElement.focus();\n\t\t}\n\t}\n\n\tpublic blur(): void {\n\t\tif (this.selectElement) {\n\t\t\tthis.selectElement.blur();\n\t\t}\n\t}\n\n\tpublic render(container: HTMLElement): void {\n\t\tdom.addClass(container, 'select-container');\n\t\tcontainer.appendChild(this.selectElement);\n\t\tthis.setOptions(this.options, this.selected);\n\t\tthis.applyStyles();\n\t}\n\n\tpublic style(styles: ISelectBoxStyles): void {\n\n\t\tconst content: string[] = [];\n\n\t\tthis.styles = styles;\n\n\t\t// Style non-native select mode\n\n\t\tif (this.styles.listFocusBackground) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.focused { background-color: ${this.styles.listFocusBackground} !important; }`);\n\t\t}\n\n\t\tif (this.styles.listFocusForeground) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.focused:not(:hover) { color: ${this.styles.listFocusForeground} !important; }`);\n\t\t}\n\n\t\t// Hover foreground - ignore for disabled options\n\t\tif (this.styles.listHoverForeground) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:hover { color: ${this.styles.listHoverForeground} !important; }`);\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.option-disabled:hover { background-color: ${this.styles.listActiveSelectionForeground} !important; }`);\n\t\t}\n\n\t\t// Hover background - ignore for disabled options\n\t\tif (this.styles.listHoverBackground) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:not(.option-disabled):not(.focused):hover { background-color: ${this.styles.listHoverBackground} !important; }`);\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.option-disabled:hover { background-color: ${this.styles.selectBackground} !important; }`);\n\t\t}\n\n\t\t// Match quickOpen outline styles - ignore for disabled options\n\t\tif (this.styles.listFocusOutline) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.focused { outline: 1.6px dotted ${this.styles.listFocusOutline} !important; outline-offset: -1.6px !important; }`);\n\t\t}\n\n\t\tif (this.styles.listHoverOutline) {\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:hover:not(.focused) { outline: 1.6px dashed ${this.styles.listHoverOutline} !important; outline-offset: -1.6px !important; }`);\n\t\t\tcontent.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.option-disabled:hover { outline: none !important; }`);\n\t\t}\n\n\t\tthis.styleElement.innerHTML = content.join('\\n');\n\n\t\tthis.applyStyles();\n\t}\n\n\tpublic applyStyles(): void {\n\n\t\t// Style parent select\n\n\t\tlet background = null;\n\n\t\tif (this.selectElement) {\n\t\t\tbackground = this.styles.selectBackground ? this.styles.selectBackground.toString() : null;\n\t\t\tconst foreground = this.styles.selectForeground ? this.styles.selectForeground.toString() : null;\n\t\t\tconst border = this.styles.selectBorder ? this.styles.selectBorder.toString() : null;\n\n\t\t\tthis.selectElement.style.backgroundColor = background;\n\t\t\tthis.selectElement.style.color = foreground;\n\t\t\tthis.selectElement.style.borderColor = border;\n\t\t}\n\n\t\t// Style drop down select list (non-native mode only)\n\n\t\tif (this.selectList) {\n\t\t\tthis.selectList.style({});\n\n\t\t\tlet listBackground = this.styles.selectListBackground ? this.styles.selectListBackground.toString() : background;\n\t\t\tthis.selectDropDownListContainer.style.backgroundColor = listBackground;\n\t\t\tconst optionsBorder = this.styles.focusBorder ? this.styles.focusBorder.toString() : null;\n\t\t\tthis.selectDropDownContainer.style.outlineColor = optionsBorder;\n\t\t\tthis.selectDropDownContainer.style.outlineOffset = '-1px';\n\t\t}\n\t}\n\n\tprivate createOption(value: string, index: number, disabled?: boolean): HTMLOptionElement {\n\t\tlet option = document.createElement('option');\n\t\toption.value = value;\n\t\toption.text = value;\n\t\toption.disabled = disabled;\n\n\t\treturn option;\n\t}\n\n\t// ContextView dropdown methods\n\n\tprivate showSelectDropDown() {\n\t\tif (!this.contextViewProvider || this._isVisible) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Set drop-down position above/below from required height and margins\n\t\tthis.layoutSelectDropDown(true);\n\n\t\tthis._isVisible = true;\n\t\tthis.cloneElementFont(this.selectElement, this.selectDropDownContainer);\n\n\t\tthis.contextViewProvider.showContextView({\n\t\t\tgetAnchor: () => this.selectElement,\n\t\t\trender: (container: HTMLElement) => this.renderSelectDropDown(container),\n\t\t\tlayout: () => this.layoutSelectDropDown(),\n\t\t\tonHide: () => {\n\t\t\t\tdom.toggleClass(this.selectDropDownContainer, 'visible', false);\n\t\t\t\tdom.toggleClass(this.selectElement, 'synthetic-focus', false);\n\t\t\t},\n\t\t\tanchorPosition: this._dropDownPosition\n\t\t});\n\n\t\t// Track initial selection the case user escape, blur\n\t\tthis._currentSelection = this.selected;\n\t}\n\n\tprivate hideSelectDropDown(focusSelect: boolean) {\n\t\tif (!this.contextViewProvider || !this._isVisible) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._isVisible = false;\n\n\t\tif (focusSelect) {\n\t\t\tthis.selectElement.focus();\n\t\t}\n\t\tthis.contextViewProvider.hideContextView();\n\t}\n\n\tprivate renderSelectDropDown(container: HTMLElement): IDisposable {\n\t\tcontainer.appendChild(this.selectDropDownContainer);\n\n\t\tthis.layoutSelectDropDown();\n\t\treturn {\n\t\t\tdispose: () => container.removeChild(this.selectDropDownContainer) // remove to take out the CSS rules we add\n\t\t};\n\t}\n\n\tprivate layoutSelectDropDown(preLayoutPosition?: boolean) {\n\n\t\t// Layout ContextView drop down select list and container\n\t\t// Have to manage our vertical overflow, sizing, position below or above\n\t\t// Position has to be determined and set prior to contextView instantiation\n\n\t\tif (this.selectList) {\n\n\t\t\tconst selectPosition = dom.getDomNodePagePosition(this.selectElement);\n\t\t\tconst styles = getComputedStyle(this.selectElement);\n\t\t\tconst verticalPadding = parseFloat(styles.getPropertyValue('--dropdown-padding-top')) + parseFloat(styles.getPropertyValue('--dropdown-padding-bottom'));\n\t\t\tlet maxSelectDropDownHeight = 0;\n\t\t\tmaxSelectDropDownHeight = (window.innerHeight - selectPosition.top - selectPosition.height - this.selectBoxOptions.minBottomMargin);\n\n\t\t\tthis.selectList.layout();\n\t\t\tlet listHeight = this.selectList.contentHeight;\n\n\t\t\t// If we are only doing pre-layout check/adjust position only\n\t\t\t// Calculate vertical space available, flip up if insufficient\n\t\t\t// Use reflected padding on parent select, ContextView style properties not available before DOM attachment\n\t\t\tif (preLayoutPosition) {\n\n\t\t\t\t// Always show complete list items - never more than Max available vertical height\n\t\t\t\tif (listHeight + verticalPadding > maxSelectDropDownHeight) {\n\t\t\t\t\tconst maxVisibleOptions = ((Math.floor((maxSelectDropDownHeight - verticalPadding) / this.getHeight())));\n\n\t\t\t\t\t// Check if we can at least show min items otherwise flip above\n\t\t\t\t\tif (maxVisibleOptions < SelectBoxList.DEFAULT_MINIMUM_VISIBLE_OPTIONS) {\n\t\t\t\t\t\tthis._dropDownPosition = AnchorPosition.ABOVE;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._dropDownPosition = AnchorPosition.BELOW;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Do full layout on showSelectDropDown only\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Make visible to enable measurements\n\t\t\tdom.toggleClass(this.selectDropDownContainer, 'visible', true);\n\n\t\t\t// SetUp list dimensions and layout - account for container padding\n\t\t\t// Use position to check above or below available space\n\t\t\tif (this._dropDownPosition === AnchorPosition.BELOW) {\n\t\t\t\t// Set container height to max from select bottom to margin (default/minBottomMargin)\n\t\t\t\tif (listHeight + verticalPadding > maxSelectDropDownHeight) {\n\t\t\t\t\tlistHeight = ((Math.floor((maxSelectDropDownHeight - verticalPadding) / this.getHeight())) * this.getHeight());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Set container height to max from select top to margin (default/minTopMargin)\n\t\t\t\tmaxSelectDropDownHeight = (selectPosition.top - SelectBoxList.DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN);\n\t\t\t\tif (listHeight + verticalPadding > maxSelectDropDownHeight) {\n\t\t\t\t\tlistHeight = ((Math.floor((maxSelectDropDownHeight - SelectBoxList.DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN) / this.getHeight())) * this.getHeight());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set adjusted list height and relayout\n\t\t\tthis.selectList.layout(listHeight);\n\t\t\tthis.selectList.domFocus();\n\n\t\t\t// Finally set focus on selected item\n\t\t\tif (this.selectList.length > 0) {\n\t\t\t\tthis.selectList.setFocus([this.selected || 0]);\n\t\t\t\tthis.selectList.reveal(this.selectList.getFocus()[0] || 0);\n\t\t\t}\n\n\t\t\t// Set final container height after adjustments\n\t\t\tthis.selectDropDownContainer.style.height = (listHeight + verticalPadding) + 'px';\n\n\t\t\t// Determine optimal width - min(longest option), opt(parent select), max(ContextView controlled)\n\t\t\tconst selectWidth = dom.getTotalWidth(this.selectElement);\n\t\t\tconst selectMinWidth = this.setWidthControlElement(this.widthControlElement);\n\t\t\tconst selectOptimalWidth = Math.max(selectMinWidth, Math.round(selectWidth)).toString() + 'px';\n\n\t\t\tthis.selectDropDownContainer.style.width = selectOptimalWidth;\n\n\t\t\t// Maintain focus outline on parent select as well as list container - tabindex for focus\n\t\t\tthis.selectDropDownListContainer.setAttribute('tabindex', '0');\n\t\t\tdom.toggleClass(this.selectElement, 'synthetic-focus', true);\n\t\t\tdom.toggleClass(this.selectDropDownContainer, 'synthetic-focus', true);\n\t\t}\n\t}\n\n\tprivate setWidthControlElement(container: HTMLElement): number {\n\t\tlet elementWidth = 0;\n\n\t\tif (container && !!this.options) {\n\t\t\tlet longest = 0;\n\n\t\t\tfor (let index = 0; index < this.options.length; index++) {\n\t\t\t\tif (this.options[index].length > this.options[longest].length) {\n\t\t\t\t\tlongest = index;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcontainer.innerHTML = this.options[longest];\n\t\t\telementWidth = dom.getTotalWidth(container);\n\t\t}\n\n\t\treturn elementWidth;\n\t}\n\n\tprivate cloneElementFont(source: HTMLElement, target: HTMLElement) {\n\t\tconst fontSize = window.getComputedStyle(source, null).getPropertyValue('font-size');\n\t\tconst fontFamily = window.getComputedStyle(source, null).getPropertyValue('font-family');\n\t\ttarget.style.fontFamily = fontFamily;\n\t\ttarget.style.fontSize = fontSize;\n\t}\n\n\tprivate createSelectList(parent: HTMLElement): void {\n\n\t\t// SetUp container for list\n\t\tthis.selectDropDownListContainer = dom.append(parent, $('.select-box-dropdown-list-container'));\n\n\t\tthis.listRenderer = new SelectListRenderer();\n\n\t\tthis.selectList = new List(this.selectDropDownListContainer, this, [this.listRenderer], {\n\t\t\tuseShadows: false,\n\t\t\tselectOnMouseDown: false,\n\t\t\tverticalScrollMode: ScrollbarVisibility.Visible,\n\t\t\tkeyboardSupport: false,\n\t\t\tmouseSupport: false\n\t\t});\n\n\t\t// SetUp list keyboard controller - control navigation, disabled items, focus\n\t\tconst onSelectDropDownKeyDown = chain(domEvent(this.selectDropDownListContainer, 'keydown'))\n\t\t\t.filter(() => this.selectList.length > 0)\n\t\t\t.map(e => new StandardKeyboardEvent(e));\n\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.Enter).on(e => this.onEnter(e), this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.Escape).on(e => this.onEscape(e), this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.UpArrow).on(this.onUpArrow, this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.DownArrow).on(this.onDownArrow, this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.PageDown).on(this.onPageDown, this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.PageUp).on(this.onPageUp, this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.Home).on(this.onHome, this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => e.keyCode === KeyCode.End).on(this.onEnd, this, this.toDispose);\n\t\tonSelectDropDownKeyDown.filter(e => (e.keyCode >= KeyCode.KEY_0 && e.keyCode <= KeyCode.KEY_Z) || (e.keyCode >= KeyCode.US_SEMICOLON && e.keyCode <= KeyCode.NUMPAD_DIVIDE)).on(this.onCharacter, this, this.toDispose);\n\n\t\t// SetUp list mouse controller - control navigation, disabled items, focus\n\n\t\tchain(domEvent(this.selectList.getHTMLElement(), 'mouseup'))\n\t\t\t.filter(() => this.selectList.length > 0)\n\t\t\t.on(e => this.onMouseUp(e), this, this.toDispose);\n\n\t\tthis.toDispose.push(this.selectList.onDidBlur(e => this.onListBlur()));\n\t}\n\n\t// List methods\n\n\t// List mouse controller - active exit, select option, fire onDidSelect if change, return focus to parent select\n\tprivate onMouseUp(e: MouseEvent): void {\n\n\t\tdom.EventHelper.stop(e);\n\n\t\t// Check our mouse event is on an option (not scrollbar)\n\t\tif (!e.toElement.classList.contains('option-text')) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst listRowElement = e.toElement.parentElement;\n\t\tconst index = Number(listRowElement.getAttribute('data-index'));\n\t\tconst disabled = listRowElement.classList.contains('option-disabled');\n\n\t\t// Ignore mouse selection of disabled options\n\t\tif (index >= 0 && index < this.options.length && !disabled) {\n\t\t\tthis.selected = index;\n\t\t\tthis.select(this.selected);\n\n\t\t\tthis.selectList.setFocus([this.selected]);\n\t\t\tthis.selectList.reveal(this.selectList.getFocus()[0]);\n\n\t\t\t// Only fire if selection change\n\t\t\tif (this.selected !== this._currentSelection) {\n\t\t\t\t// Set current = selected\n\t\t\t\tthis._currentSelection = this.selected;\n\n\t\t\t\tthis._onDidSelect.fire({\n\t\t\t\t\tindex: this.selectElement.selectedIndex,\n\t\t\t\t\tselected: this.selectElement.title\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthis.hideSelectDropDown(true);\n\t\t}\n\t}\n\n\t// List Exit - passive - implicit no selection change, hide drop-down\n\tprivate onListBlur(): void {\n\n\t\tif (this.selected !== this._currentSelection) {\n\t\t\t// Reset selected to current if no change\n\t\t\tthis.select(this._currentSelection);\n\t\t}\n\n\t\tthis.hideSelectDropDown(false);\n\t}\n\n\t// List keyboard controller\n\n\t// List exit - active - hide ContextView dropdown, reset selection, return focus to parent select\n\tprivate onEscape(e: StandardKeyboardEvent): void {\n\t\tdom.EventHelper.stop(e);\n\n\t\t// Reset selection to value when opened\n\t\tthis.select(this._currentSelection);\n\t\tthis.hideSelectDropDown(true);\n\t}\n\n\t// List exit - active - hide ContextView dropdown, return focus to parent select, fire onDidSelect if change\n\tprivate onEnter(e: StandardKeyboardEvent): void {\n\t\tdom.EventHelper.stop(e);\n\n\t\t// Only fire if selection change\n\t\tif (this.selected !== this._currentSelection) {\n\t\t\tthis._currentSelection = this.selected;\n\t\t\tthis._onDidSelect.fire({\n\t\t\t\tindex: this.selectElement.selectedIndex,\n\t\t\t\tselected: this.selectElement.title\n\t\t\t});\n\t\t}\n\n\t\tthis.hideSelectDropDown(true);\n\t}\n\n\t// List navigation - have to handle a disabled option (jump over)\n\tprivate onDownArrow(): void {\n\t\tif (this.selected < this.options.length - 1) {\n\t\t\t// Skip disabled options\n\t\t\tif ((this.selected + 1) === this.disabledOptionIndex && this.options.length > this.selected + 2) {\n\t\t\t\tthis.selected += 2;\n\t\t\t} else {\n\t\t\t\tthis.selected++;\n\t\t\t}\n\t\t\t// Set focus/selection - only fire event when closing drop-down or on blur\n\t\t\tthis.select(this.selected);\n\t\t\tthis.selectList.setFocus([this.selected]);\n\t\t\tthis.selectList.reveal(this.selectList.getFocus()[0]);\n\t\t}\n\t}\n\n\tprivate onUpArrow(): void {\n\t\tif (this.selected > 0) {\n\t\t\t// Skip disabled options\n\t\t\tif ((this.selected - 1) === this.disabledOptionIndex && this.selected > 1) {\n\t\t\t\tthis.selected -= 2;\n\t\t\t} else {\n\t\t\t\tthis.selected--;\n\t\t\t}\n\t\t\t// Set focus/selection - only fire event when closing drop-down or on blur\n\t\t\tthis.select(this.selected);\n\t\t\tthis.selectList.setFocus([this.selected]);\n\t\t\tthis.selectList.reveal(this.selectList.getFocus()[0]);\n\t\t}\n\t}\n\n\tprivate onPageUp(e: StandardKeyboardEvent): void {\n\t\tdom.EventHelper.stop(e);\n\n\t\tthis.selectList.focusPreviousPage();\n\n\t\t// Allow scrolling to settle\n\t\tsetTimeout(() => {\n\t\t\tthis.selected = this.selectList.getFocus()[0];\n\n\t\t\t// Shift selection down if we land on a disabled option\n\t\t\tif (this.selected === this.disabledOptionIndex && this.selected < this.options.length - 1) {\n\t\t\t\tthis.selected++;\n\t\t\t\tthis.selectList.setFocus([this.selected]);\n\t\t\t}\n\t\t\tthis.selectList.reveal(this.selected);\n\t\t\tthis.select(this.selected);\n\t\t}, 1);\n\t}\n\n\tprivate onPageDown(e: StandardKeyboardEvent): void {\n\t\tdom.EventHelper.stop(e);\n\n\t\tthis.selectList.focusNextPage();\n\n\t\t// Allow scrolling to settle\n\t\tsetTimeout(() => {\n\t\t\tthis.selected = this.selectList.getFocus()[0];\n\n\t\t\t// Shift selection up if we land on a disabled option\n\t\t\tif (this.selected === this.disabledOptionIndex && this.selected > 0) {\n\t\t\t\tthis.selected--;\n\t\t\t\tthis.selectList.setFocus([this.selected]);\n\t\t\t}\n\t\t\tthis.selectList.reveal(this.selected);\n\t\t\tthis.select(this.selected);\n\t\t}, 1);\n\t}\n\n\tprivate onHome(e: StandardKeyboardEvent): void {\n\t\tdom.EventHelper.stop(e);\n\n\t\tif (this.options.length < 2) {\n\t\t\treturn;\n\t\t}\n\t\tthis.selected = 0;\n\t\tif (this.selected === this.disabledOptionIndex && this.selected > 1) {\n\t\t\tthis.selected++;\n\t\t}\n\t\tthis.selectList.setFocus([this.selected]);\n\t\tthis.selectList.reveal(this.selected);\n\t\tthis.select(this.selected);\n\t}\n\n\tprivate onEnd(e: StandardKeyboardEvent): void {\n\t\tdom.EventHelper.stop(e);\n\n\t\tif (this.options.length < 2) {\n\t\t\treturn;\n\t\t}\n\t\tthis.selected = this.options.length - 1;\n\t\tif (this.selected === this.disabledOptionIndex && this.selected > 1) {\n\t\t\tthis.selected--;\n\t\t}\n\t\tthis.selectList.setFocus([this.selected]);\n\t\tthis.selectList.reveal(this.selected);\n\t\tthis.select(this.selected);\n\t}\n\n\t// Mimic option first character navigation of native select\n\tprivate onCharacter(e: StandardKeyboardEvent): void {\n\t\tconst ch = KeyCodeUtils.toString(e.keyCode);\n\t\tlet optionIndex = -1;\n\n\t\tfor (let i = 0; i < this.options.length - 1; i++) {\n\t\t\toptionIndex = (i + this.selected + 1) % this.options.length;\n\t\t\tif (this.options[optionIndex].charAt(0).toUpperCase() === ch) {\n\t\t\t\tthis.select(optionIndex);\n\t\t\t\tthis.selectList.setFocus([optionIndex]);\n\t\t\t\tthis.selectList.reveal(this.selectList.getFocus()[0]);\n\t\t\t\tdom.EventHelper.stop(e);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic dispose(): void {\n\t\tthis.hideSelectDropDown(false);\n\t\tthis.toDispose = dispose(this.toDispose);\n\t}\n}\n",
            "linguagem": "ts",
            "total_linhas": 769
        },
        "solucao_humana": {
            "patch_diff": "@@ -489,8 +489,8 @@ export class SelectBoxList implements ISelectBoxDelegate, IVirtualDelegate<ISele\n \t\t\t// Set final container height after adjustments\n \t\t\tthis.selectDropDownContainer.style.height = (listHeight + verticalPadding) + 'px';\n \n-\t\t\t// Determine optimal width - min(longest option), opt(parent select), max(ContextView controlled)\n-\t\t\tconst selectWidth = dom.getTotalWidth(this.selectElement);\n+\t\t\t// Determine optimal width - min(longest option), opt(parent select, excluding margins), max(ContextView controlled)\n+\t\t\tconst selectWidth = this.selectElement.offsetWidth;\n \t\t\tconst selectMinWidth = this.setWidthControlElement(this.widthControlElement);\n \t\t\tconst selectOptimalWidth = Math.max(selectMinWidth, Math.round(selectWidth)).toString() + 'px';\n ",
            "apenas_linhas_adicionadas": [
                "\t\t\t// Determine optimal width - min(longest option), opt(parent select, excluding margins), max(ContextView controlled)",
                "\t\t\tconst selectWidth = this.selectElement.offsetWidth;"
            ]
        },
        "LLM": "CHAT GPT",
        "solucao_llm": ["❌ Antes (inclui margem):",
                "const selectWidth = dom.getTotalWidth(this.selectElement);",
                "✅ Depois (usa offsetWidth, não inclui margem):",
                "const selectWidth = this.selectElement.offsetWidth;",
                "const selectMinWidth = this.setWidthControlElement(this.widthControlElement);",
                "const selectOptimalWidth = Math.max(selectMinWidth, Math.round(selectWidth)).toString() + 'px';",
                "this.selectDropDownContainer.style.width = selectOptimalWidth;"
            ]
    },
    {
        "id": 51224,
        "url": "https://github.com/microsoft/vscode/pull/51224",
        "arquivo_caminho": "src/vs/code/electron-main/app.ts",
        "descricao_bug": "Fixes #40505\r\n\r\n@bpasero @alexandrudima @sandy081 Make sure the changes makes sense.",
        "contexto": {
            "codigo_completo_bugado": "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n'use strict';\n\nimport { app, ipcMain as ipc } from 'electron';\nimport * as platform from 'vs/base/common/platform';\nimport { WindowsManager } from 'vs/code/electron-main/windows';\nimport { IWindowsService, OpenContext, ActiveWindowManager } from 'vs/platform/windows/common/windows';\nimport { WindowsChannel } from 'vs/platform/windows/common/windowsIpc';\nimport { WindowsService } from 'vs/platform/windows/electron-main/windowsService';\nimport { ILifecycleService } from 'vs/platform/lifecycle/electron-main/lifecycleMain';\nimport { CodeMenu } from 'vs/code/electron-main/menus';\nimport { getShellEnvironment } from 'vs/code/node/shellEnv';\nimport { IUpdateService } from 'vs/platform/update/common/update';\nimport { UpdateChannel } from 'vs/platform/update/common/updateIpc';\nimport { Server as ElectronIPCServer } from 'vs/base/parts/ipc/electron-main/ipc.electron-main';\nimport { Server, connect, Client } from 'vs/base/parts/ipc/node/ipc.net';\nimport { SharedProcess } from 'vs/code/electron-main/sharedProcess';\nimport { Mutex } from 'windows-mutex';\nimport { LaunchService, LaunchChannel, ILaunchService } from './launch';\nimport { IInstantiationService, ServicesAccessor } from 'vs/platform/instantiation/common/instantiation';\nimport { ServiceCollection } from 'vs/platform/instantiation/common/serviceCollection';\nimport { SyncDescriptor } from 'vs/platform/instantiation/common/descriptors';\nimport { ILogService } from 'vs/platform/log/common/log';\nimport { IStateService } from 'vs/platform/state/common/state';\nimport { IEnvironmentService } from 'vs/platform/environment/common/environment';\nimport { IConfigurationService } from 'vs/platform/configuration/common/configuration';\nimport { IURLService } from 'vs/platform/url/common/url';\nimport { URLHandlerChannelClient, URLServiceChannel } from 'vs/platform/url/common/urlIpc';\nimport { ITelemetryService } from 'vs/platform/telemetry/common/telemetry';\nimport { NullTelemetryService } from 'vs/platform/telemetry/common/telemetryUtils';\nimport { ITelemetryAppenderChannel, TelemetryAppenderClient } from 'vs/platform/telemetry/common/telemetryIpc';\nimport { TelemetryService, ITelemetryServiceConfig } from 'vs/platform/telemetry/common/telemetryService';\nimport { resolveCommonProperties } from 'vs/platform/telemetry/node/commonProperties';\nimport { getDelayedChannel } from 'vs/base/parts/ipc/common/ipc';\nimport product from 'vs/platform/node/product';\nimport pkg from 'vs/platform/node/package';\nimport { ProxyAuthHandler } from './auth';\nimport { IDisposable, dispose } from 'vs/base/common/lifecycle';\nimport { ConfigurationService } from 'vs/platform/configuration/node/configurationService';\nimport { TPromise } from 'vs/base/common/winjs.base';\nimport { IWindowsMainService } from 'vs/platform/windows/electron-main/windows';\nimport { IHistoryMainService } from 'vs/platform/history/common/history';\nimport { isUndefinedOrNull } from 'vs/base/common/types';\nimport { CodeWindow } from 'vs/code/electron-main/window';\nimport { KeyboardLayoutMonitor } from 'vs/code/electron-main/keyboard';\nimport URI from 'vs/base/common/uri';\nimport { WorkspacesChannel } from 'vs/platform/workspaces/common/workspacesIpc';\nimport { IWorkspacesMainService } from 'vs/platform/workspaces/common/workspaces';\nimport { getMachineId } from 'vs/base/node/id';\nimport { Win32UpdateService } from 'vs/platform/update/electron-main/updateService.win32';\nimport { LinuxUpdateService } from 'vs/platform/update/electron-main/updateService.linux';\nimport { DarwinUpdateService } from 'vs/platform/update/electron-main/updateService.darwin';\nimport { IIssueService } from 'vs/platform/issue/common/issue';\nimport { IssueChannel } from 'vs/platform/issue/common/issueIpc';\nimport { IssueService } from 'vs/platform/issue/electron-main/issueService';\nimport { LogLevelSetterChannel } from 'vs/platform/log/common/logIpc';\nimport { setUnexpectedErrorHandler } from 'vs/base/common/errors';\nimport { ElectronURLListener } from 'vs/platform/url/electron-main/electronUrlListener';\nimport { serve as serveDriver } from 'vs/platform/driver/electron-main/driver';\n\nexport class CodeApplication {\n\n\tprivate static readonly MACHINE_ID_KEY = 'telemetry.machineId';\n\n\tprivate toDispose: IDisposable[];\n\tprivate windowsMainService: IWindowsMainService;\n\n\tprivate electronIpcServer: ElectronIPCServer;\n\n\tprivate sharedProcess: SharedProcess;\n\tprivate sharedProcessClient: TPromise<Client>;\n\n\tconstructor(\n\t\tprivate mainIpcServer: Server,\n\t\tprivate userEnv: platform.IProcessEnvironment,\n\t\t@IInstantiationService private instantiationService: IInstantiationService,\n\t\t@ILogService private logService: ILogService,\n\t\t@IEnvironmentService private environmentService: IEnvironmentService,\n\t\t@ILifecycleService private lifecycleService: ILifecycleService,\n\t\t@IConfigurationService configurationService: ConfigurationService,\n\t\t@IStateService private stateService: IStateService,\n\t\t@IHistoryMainService private historyMainService: IHistoryMainService\n\t) {\n\t\tthis.toDispose = [mainIpcServer, configurationService];\n\n\t\tthis.registerListeners();\n\t}\n\n\tprivate registerListeners(): void {\n\n\t\t// We handle uncaught exceptions here to prevent electron from opening a dialog to the user\n\t\tsetUnexpectedErrorHandler(err => this.onUnexpectedError(err));\n\t\tprocess.on('uncaughtException', err => this.onUnexpectedError(err));\n\n\t\tapp.on('will-quit', () => {\n\t\t\tthis.logService.trace('App#will-quit: disposing resources');\n\n\t\t\tthis.dispose();\n\t\t});\n\n\t\tapp.on('accessibility-support-changed', (event: Event, accessibilitySupportEnabled: boolean) => {\n\t\t\tif (this.windowsMainService) {\n\t\t\t\tthis.windowsMainService.sendToAll('vscode:accessibilitySupportChanged', accessibilitySupportEnabled);\n\t\t\t}\n\t\t});\n\n\t\tapp.on('activate', (event: Event, hasVisibleWindows: boolean) => {\n\t\t\tthis.logService.trace('App#activate');\n\n\t\t\t// Mac only event: open new window when we get activated\n\t\t\tif (!hasVisibleWindows && this.windowsMainService) {\n\t\t\t\tthis.windowsMainService.openNewWindow(OpenContext.DOCK);\n\t\t\t}\n\t\t});\n\n\t\tconst isValidWebviewSource = (source: string): boolean => {\n\t\t\tif (!source) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (source === 'data:text/html;charset=utf-8,%3C%21DOCTYPE%20html%3E%0D%0A%3Chtml%20lang%3D%22en%22%20style%3D%22width%3A%20100%25%3B%20height%3A%20100%25%22%3E%0D%0A%3Chead%3E%0D%0A%09%3Ctitle%3EVirtual%20Document%3C%2Ftitle%3E%0D%0A%3C%2Fhead%3E%0D%0A%3Cbody%20style%3D%22margin%3A%200%3B%20overflow%3A%20hidden%3B%20width%3A%20100%25%3B%20height%3A%20100%25%22%3E%0D%0A%3C%2Fbody%3E%0D%0A%3C%2Fhtml%3E') {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tconst srcUri: any = URI.parse(source.toLowerCase()).toString();\n\t\t\treturn srcUri.startsWith(URI.file(this.environmentService.appRoot.toLowerCase()).toString());\n\t\t};\n\n\t\tapp.on('web-contents-created', (event: any, contents) => {\n\t\t\tcontents.on('will-attach-webview', (event: Electron.Event, webPreferences, params) => {\n\t\t\t\tdelete webPreferences.preload;\n\t\t\t\twebPreferences.nodeIntegration = false;\n\n\t\t\t\t// Verify URLs being loaded\n\t\t\t\tif (isValidWebviewSource(params.src) && isValidWebviewSource(webPreferences.preloadURL)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Otherwise prevent loading\n\t\t\t\tthis.logService.error('webContents#web-contents-created: Prevented webview attach');\n\t\t\t\tevent.preventDefault();\n\t\t\t});\n\n\t\t\tcontents.on('will-navigate', event => {\n\t\t\t\tthis.logService.error('webContents#will-navigate: Prevented webcontent navigation');\n\t\t\t\tevent.preventDefault();\n\t\t\t});\n\t\t});\n\n\t\tlet macOpenFiles: string[] = [];\n\t\tlet runningTimeout: number = null;\n\t\tapp.on('open-file', (event: Event, path: string) => {\n\t\t\tthis.logService.trace('App#open-file: ', path);\n\t\t\tevent.preventDefault();\n\n\t\t\t// Keep in array because more might come!\n\t\t\tmacOpenFiles.push(path);\n\n\t\t\t// Clear previous handler if any\n\t\t\tif (runningTimeout !== null) {\n\t\t\t\tclearTimeout(runningTimeout);\n\t\t\t\trunningTimeout = null;\n\t\t\t}\n\n\t\t\t// Handle paths delayed in case more are coming!\n\t\t\trunningTimeout = setTimeout(() => {\n\t\t\t\tif (this.windowsMainService) {\n\t\t\t\t\tthis.windowsMainService.open({\n\t\t\t\t\t\tcontext: OpenContext.DOCK /* can also be opening from finder while app is running */,\n\t\t\t\t\t\tcli: this.environmentService.args,\n\t\t\t\t\t\tpathsToOpen: macOpenFiles,\n\t\t\t\t\t\tpreferNewWindow: true /* dropping on the dock or opening from finder prefers to open in a new window */\n\t\t\t\t\t});\n\t\t\t\t\tmacOpenFiles = [];\n\t\t\t\t\trunningTimeout = null;\n\t\t\t\t}\n\t\t\t}, 100);\n\t\t});\n\n\t\tapp.on('new-window-for-tab', () => {\n\t\t\tthis.windowsMainService.openNewWindow(OpenContext.DESKTOP); //macOS native tab \"+\" button\n\t\t});\n\n\t\tipc.on('vscode:exit', (event: any, code: number) => {\n\t\t\tthis.logService.trace('IPC#vscode:exit', code);\n\n\t\t\tthis.dispose();\n\t\t\tthis.lifecycleService.kill(code);\n\t\t});\n\n\t\tipc.on('vscode:fetchShellEnv', event => {\n\t\t\tconst webContents = event.sender.webContents;\n\t\t\tgetShellEnvironment().then(shellEnv => {\n\t\t\t\tif (!webContents.isDestroyed()) {\n\t\t\t\t\twebContents.send('vscode:acceptShellEnv', shellEnv);\n\t\t\t\t}\n\t\t\t}, err => {\n\t\t\t\tif (!webContents.isDestroyed()) {\n\t\t\t\t\twebContents.send('vscode:acceptShellEnv', {});\n\t\t\t\t}\n\n\t\t\t\tthis.logService.error('Error fetching shell env', err);\n\t\t\t});\n\t\t});\n\n\t\tipc.on('vscode:broadcast', (event: any, windowId: number, broadcast: { channel: string; payload: any; }) => {\n\t\t\tif (this.windowsMainService && broadcast.channel && !isUndefinedOrNull(broadcast.payload)) {\n\t\t\t\tthis.logService.trace('IPC#vscode:broadcast', broadcast.channel, broadcast.payload);\n\n\t\t\t\t// Handle specific events on main side\n\t\t\t\tthis.onBroadcast(broadcast.channel, broadcast.payload);\n\n\t\t\t\t// Send to all windows (except sender window)\n\t\t\t\tthis.windowsMainService.sendToAll('vscode:broadcast', broadcast, [windowId]);\n\t\t\t}\n\t\t});\n\n\t\t// Keyboard layout changes\n\t\tKeyboardLayoutMonitor.INSTANCE.onDidChangeKeyboardLayout(() => {\n\t\t\tif (this.windowsMainService) {\n\t\t\t\tthis.windowsMainService.sendToAll('vscode:keyboardLayoutChanged', false);\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate onUnexpectedError(err: Error): void {\n\t\tif (err) {\n\n\t\t\t// take only the message and stack property\n\t\t\tconst friendlyError = {\n\t\t\t\tmessage: err.message,\n\t\t\t\tstack: err.stack\n\t\t\t};\n\n\t\t\t// handle on client side\n\t\t\tif (this.windowsMainService) {\n\t\t\t\tthis.windowsMainService.sendToFocused('vscode:reportError', JSON.stringify(friendlyError));\n\t\t\t}\n\t\t}\n\n\t\tthis.logService.error(`[uncaught exception in main]: ${err}`);\n\t\tif (err.stack) {\n\t\t\tthis.logService.error(err.stack);\n\t\t}\n\t}\n\n\tprivate onBroadcast(event: string, payload: any): void {\n\n\t\t// Theme changes\n\t\tif (event === 'vscode:changeColorTheme' && typeof payload === 'string') {\n\t\t\tlet data = JSON.parse(payload);\n\n\t\t\tthis.stateService.setItem(CodeWindow.themeStorageKey, data.id);\n\t\t\tthis.stateService.setItem(CodeWindow.themeBackgroundStorageKey, data.background);\n\t\t}\n\t}\n\n\tpublic startup(): TPromise<void> {\n\t\tthis.logService.debug('Starting VS Code');\n\t\tthis.logService.debug(`from: ${this.environmentService.appRoot}`);\n\t\tthis.logService.debug('args:', this.environmentService.args);\n\n\t\t// Make sure we associate the program with the app user model id\n\t\t// This will help Windows to associate the running program with\n\t\t// any shortcut that is pinned to the taskbar and prevent showing\n\t\t// two icons in the taskbar for the same app.\n\t\tif (platform.isWindows && product.win32AppUserModelId) {\n\t\t\tapp.setAppUserModelId(product.win32AppUserModelId);\n\t\t}\n\n\t\t// Create Electron IPC Server\n\t\tthis.electronIpcServer = new ElectronIPCServer();\n\n\t\t// Resolve unique machine ID\n\t\tthis.logService.trace('Resolving machine identifier...');\n\t\treturn this.resolveMachineId().then(machineId => {\n\t\t\tthis.logService.trace(`Resolved machine identifier: ${machineId}`);\n\n\t\t\t// Spawn shared process\n\t\t\tthis.sharedProcess = new SharedProcess(this.environmentService, this.lifecycleService, this.logService, machineId, this.userEnv);\n\t\t\tthis.sharedProcessClient = this.sharedProcess.whenReady().then(() => connect(this.environmentService.sharedIPCHandle, 'main'));\n\n\t\t\t// Services\n\t\t\tconst appInstantiationService = this.initServices(machineId);\n\n\t\t\tlet promise: TPromise<any> = TPromise.as(null);\n\n\t\t\t// Create driver\n\t\t\tif (this.environmentService.driverHandle) {\n\t\t\t\tserveDriver(this.electronIpcServer, this.environmentService.driverHandle, this.environmentService, appInstantiationService).then(server => {\n\t\t\t\t\tthis.logService.info('Driver started at:', this.environmentService.driverHandle);\n\t\t\t\t\tthis.toDispose.push(server);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn promise.then(() => {\n\n\t\t\t\t// Setup Auth Handler\n\t\t\t\tconst authHandler = appInstantiationService.createInstance(ProxyAuthHandler);\n\t\t\t\tthis.toDispose.push(authHandler);\n\n\t\t\t\t// Open Windows\n\t\t\t\tappInstantiationService.invokeFunction(accessor => this.openFirstWindow(accessor));\n\n\t\t\t\t// Post Open Windows Tasks\n\t\t\t\tappInstantiationService.invokeFunction(accessor => this.afterWindowOpen(accessor));\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate resolveMachineId(): TPromise<string> {\n\t\tconst machineId = this.stateService.getItem<string>(CodeApplication.MACHINE_ID_KEY);\n\t\tif (machineId) {\n\t\t\treturn TPromise.wrap(machineId);\n\t\t}\n\n\t\treturn getMachineId().then(machineId => {\n\n\t\t\t// Remember in global storage\n\t\t\tthis.stateService.setItem(CodeApplication.MACHINE_ID_KEY, machineId);\n\n\t\t\treturn machineId;\n\t\t});\n\t}\n\n\tprivate initServices(machineId: string): IInstantiationService {\n\t\tconst services = new ServiceCollection();\n\n\t\tif (process.platform === 'win32') {\n\t\t\tservices.set(IUpdateService, new SyncDescriptor(Win32UpdateService));\n\t\t} else if (process.platform === 'linux') {\n\t\t\tservices.set(IUpdateService, new SyncDescriptor(LinuxUpdateService));\n\t\t} else if (process.platform === 'darwin') {\n\t\t\tservices.set(IUpdateService, new SyncDescriptor(DarwinUpdateService));\n\t\t}\n\n\t\tservices.set(IWindowsMainService, new SyncDescriptor(WindowsManager, machineId));\n\t\tservices.set(IWindowsService, new SyncDescriptor(WindowsService, this.sharedProcess));\n\t\tservices.set(ILaunchService, new SyncDescriptor(LaunchService));\n\t\tservices.set(IIssueService, new SyncDescriptor(IssueService, machineId, this.userEnv));\n\n\t\t// Telemtry\n\t\tif (this.environmentService.isBuilt && !this.environmentService.isExtensionDevelopment && !this.environmentService.args['disable-telemetry'] && !!product.enableTelemetry) {\n\t\t\tconst channel = getDelayedChannel<ITelemetryAppenderChannel>(this.sharedProcessClient.then(c => c.getChannel('telemetryAppender')));\n\t\t\tconst appender = new TelemetryAppenderClient(channel);\n\t\t\tconst commonProperties = resolveCommonProperties(product.commit, pkg.version, machineId, this.environmentService.installSourcePath);\n\t\t\tconst piiPaths = [this.environmentService.appRoot, this.environmentService.extensionsPath];\n\t\t\tconst config: ITelemetryServiceConfig = { appender, commonProperties, piiPaths };\n\n\t\t\tservices.set(ITelemetryService, new SyncDescriptor(TelemetryService, config));\n\t\t} else {\n\t\t\tservices.set(ITelemetryService, NullTelemetryService);\n\t\t}\n\n\t\treturn this.instantiationService.createChild(services);\n\t}\n\n\tprivate openFirstWindow(accessor: ServicesAccessor): void {\n\t\tconst appInstantiationService = accessor.get(IInstantiationService);\n\n\t\t// Register more Main IPC services\n\t\tconst launchService = accessor.get(ILaunchService);\n\t\tconst launchChannel = new LaunchChannel(launchService);\n\t\tthis.mainIpcServer.registerChannel('launch', launchChannel);\n\n\t\t// Register more Electron IPC services\n\t\tconst updateService = accessor.get(IUpdateService);\n\t\tconst updateChannel = new UpdateChannel(updateService);\n\t\tthis.electronIpcServer.registerChannel('update', updateChannel);\n\n\t\tconst issueService = accessor.get(IIssueService);\n\t\tconst issueChannel = new IssueChannel(issueService);\n\t\tthis.electronIpcServer.registerChannel('issue', issueChannel);\n\n\t\tconst workspacesService = accessor.get(IWorkspacesMainService);\n\t\tconst workspacesChannel = appInstantiationService.createInstance(WorkspacesChannel, workspacesService);\n\t\tthis.electronIpcServer.registerChannel('workspaces', workspacesChannel);\n\n\t\tconst windowsService = accessor.get(IWindowsService);\n\t\tconst windowsChannel = new WindowsChannel(windowsService);\n\t\tthis.electronIpcServer.registerChannel('windows', windowsChannel);\n\t\tthis.sharedProcessClient.done(client => client.registerChannel('windows', windowsChannel));\n\n\t\tconst urlService = accessor.get(IURLService);\n\t\tconst urlChannel = new URLServiceChannel(urlService);\n\t\tthis.electronIpcServer.registerChannel('url', urlChannel);\n\n\t\t// Log level management\n\t\tconst logLevelChannel = new LogLevelSetterChannel(accessor.get(ILogService));\n\t\tthis.electronIpcServer.registerChannel('loglevel', logLevelChannel);\n\t\tthis.sharedProcessClient.done(client => client.registerChannel('loglevel', logLevelChannel));\n\n\t\t// Lifecycle\n\t\tthis.lifecycleService.ready();\n\n\t\t// Propagate to clients\n\t\tconst windowsMainService = this.windowsMainService = accessor.get(IWindowsMainService); // TODO@Joao: unfold this\n\n\t\tconst args = this.environmentService.args;\n\n\t\t// Create a URL handler which forwards to the last active window\n\t\tconst activeWindowManager = new ActiveWindowManager(windowsService);\n\t\tconst urlHandlerChannel = this.electronIpcServer.getChannel('urlHandler', { route: () => activeWindowManager.activeClientId });\n\t\tconst multiplexURLHandler = new URLHandlerChannelClient(urlHandlerChannel);\n\n\t\t// On Mac, Code can be running without any open windows, so we must create a window to handle urls,\n\t\t// if there is none\n\t\tif (platform.isMacintosh) {\n\t\t\tconst environmentService = accessor.get(IEnvironmentService);\n\n\t\t\turlService.registerHandler({\n\t\t\t\tasync handleURL(uri: URI): TPromise<boolean> {\n\t\t\t\t\tif (windowsMainService.getWindowCount() === 0) {\n\t\t\t\t\t\tconst cli = { ...environmentService.args, goto: true };\n\t\t\t\t\t\tconst [window] = windowsMainService.open({ context: OpenContext.API, cli, forceEmpty: true });\n\n\t\t\t\t\t\treturn window.ready().then(() => urlService.open(uri));\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// Register the multiple URL handker\n\t\turlService.registerHandler(multiplexURLHandler);\n\n\t\t// Watch Electron URLs and forward them to the UrlService\n\t\tconst urls = args['open-url'] ? args._urls : [];\n\t\tconst urlListener = new ElectronURLListener(urls, urlService, this.windowsMainService);\n\t\tthis.toDispose.push(urlListener);\n\n\t\tthis.windowsMainService.ready(this.userEnv);\n\n\t\t// Open our first window\n\t\tconst macOpenFiles = (<any>global).macOpenFiles as string[];\n\t\tconst context = !!process.env['VSCODE_CLI'] ? OpenContext.CLI : OpenContext.DESKTOP;\n\t\tif (args['new-window'] && args._.length === 0) {\n\t\t\tthis.windowsMainService.open({ context, cli: args, forceNewWindow: true, forceEmpty: true, initialStartup: true }); // new window if \"-n\" was used without paths\n\t\t} else if (macOpenFiles && macOpenFiles.length && (!args._ || !args._.length)) {\n\t\t\tthis.windowsMainService.open({ context: OpenContext.DOCK, cli: args, pathsToOpen: macOpenFiles, initialStartup: true }); // mac: open-file event received on startup\n\t\t} else {\n\t\t\tthis.windowsMainService.open({ context, cli: args, forceNewWindow: args['new-window'] || (!args._.length && args['unity-launch']), diffMode: args.diff, initialStartup: true }); // default: read paths from cli\n\t\t}\n\t}\n\n\tprivate afterWindowOpen(accessor: ServicesAccessor): void {\n\t\tconst appInstantiationService = accessor.get(IInstantiationService);\n\t\tconst windowsMainService = accessor.get(IWindowsMainService);\n\n\t\tlet windowsMutex: Mutex = null;\n\t\tif (platform.isWindows) {\n\n\t\t\t// Setup Windows mutex\n\t\t\ttry {\n\t\t\t\tconst Mutex = (require.__$__nodeRequire('windows-mutex') as any).Mutex;\n\t\t\t\twindowsMutex = new Mutex(product.win32MutexName);\n\t\t\t\tthis.toDispose.push({ dispose: () => windowsMutex.release() });\n\t\t\t} catch (e) {\n\t\t\t\tif (!this.environmentService.isBuilt) {\n\t\t\t\t\twindowsMainService.showMessageBox({\n\t\t\t\t\t\ttitle: product.nameLong,\n\t\t\t\t\t\ttype: 'warning',\n\t\t\t\t\t\tmessage: 'Failed to load windows-mutex!',\n\t\t\t\t\t\tdetail: e.toString(),\n\t\t\t\t\t\tnoLink: true\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Ensure Windows foreground love module\n\t\t\ttry {\n\t\t\t\t// tslint:disable-next-line:no-unused-expression\n\t\t\t\t<any>require.__$__nodeRequire('windows-foreground-love');\n\t\t\t} catch (e) {\n\t\t\t\tif (!this.environmentService.isBuilt) {\n\t\t\t\t\twindowsMainService.showMessageBox({\n\t\t\t\t\t\ttitle: product.nameLong,\n\t\t\t\t\t\ttype: 'warning',\n\t\t\t\t\t\tmessage: 'Failed to load windows-foreground-love!',\n\t\t\t\t\t\tdetail: e.toString(),\n\t\t\t\t\t\tnoLink: true\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Install Menu\n\t\tappInstantiationService.createInstance(CodeMenu);\n\n\t\t// Jump List\n\t\tthis.historyMainService.updateWindowsJumpList();\n\t\tthis.historyMainService.onRecentlyOpenedChange(() => this.historyMainService.updateWindowsJumpList());\n\n\t\t// Start shared process here\n\t\tthis.sharedProcess.spawn();\n\t}\n\n\tprivate dispose(): void {\n\t\tthis.toDispose = dispose(this.toDispose);\n\t}\n}\n",
            "linguagem": "ts",
            "total_linhas": 505
        },
        "solucao_humana": {
            "patch_diff": "@@ -494,8 +494,8 @@ export class CodeApplication {\n \t\tthis.historyMainService.updateWindowsJumpList();\n \t\tthis.historyMainService.onRecentlyOpenedChange(() => this.historyMainService.updateWindowsJumpList());\n \n-\t\t// Start shared process here\n-\t\tthis.sharedProcess.spawn();\n+\t\t// Start shared process after a while\n+\t\tTPromise.timeout(3000).then(() => this.sharedProcess.spawn());\n \t}\n \n \tprivate dispose(): void {",
            "apenas_linhas_adicionadas": [
                "\t\t// Start shared process after a while",
                "\t\tTPromise.timeout(3000).then(() => this.sharedProcess.spawn());"
            ]
        },
        "LLM": "CHAT GPT",
        "solucao_llm": ["const srcOK = isValidWebviewSource(params.src);
                        const preloadOK = !webPreferences.preloadURL || isValidWebviewSource(webPreferences.preloadURL);

                        if (srcOK && preloadOK) {
                            return;
                        }"
        ]
    },
    {
        "id": 49684,
        "url": "https://github.com/microsoft/vscode/pull/49684",
        "arquivo_caminho": "src/vs/platform/jsonschemas/common/jsonContributionRegistry.ts",
        "descricao_bug": "Change logs:\r\n\r\n**1) /vscode/src/vs/platform/jsonschemas/common/jsonContributionRegistry.ts：Remove interface `IJSONContributionRegistryEvent`.**\r\n\r\nWhy?\r\n\r\n**This event was created in 2015, and it's never referred by any other modules, functions……ect, when you are looking for its references in Visual Studio Code.**",
        "contexto": {
            "codigo_completo_bugado": "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport { IJSONSchema } from 'vs/base/common/jsonSchema';\nimport * as platform from 'vs/platform/registry/common/platform';\nimport { Event, Emitter } from 'vs/base/common/event';\n\nexport const Extensions = {\n\tJSONContribution: 'base.contributions.json'\n};\n\nexport interface ISchemaContributions {\n\tschemas?: { [id: string]: IJSONSchema };\n}\n\nexport interface IJSONContributionRegistry {\n\n\treadonly onDidChangeSchema: Event<string>;\n\n\t/**\n\t * Register a schema to the registry.\n\t */\n\tregisterSchema(uri: string, unresolvedSchemaContent: IJSONSchema): void;\n\n\n\t/**\n\t * Notifies all listeneres that the content of the given schema has changed.\n\t * @param uri The id of the schema\n\t */\n\tnotifySchemaChanged(uri: string): void;\n\n\t/**\n\t * Get all schemas\n\t */\n\tgetSchemaContributions(): ISchemaContributions;\n}\n\nexport interface IJSONContributionRegistryEvent {\n\n}\n\nfunction normalizeId(id: string) {\n\tif (id.length > 0 && id.charAt(id.length - 1) === '#') {\n\t\treturn id.substring(0, id.length - 1);\n\t}\n\treturn id;\n}\n\n\n\nclass JSONContributionRegistry implements IJSONContributionRegistry {\n\n\tprivate schemasById: { [id: string]: IJSONSchema };\n\n\tprivate readonly _onDidChangeSchema: Emitter<string> = new Emitter<string>();\n\treadonly onDidChangeSchema: Event<string> = this._onDidChangeSchema.event;\n\n\tconstructor() {\n\t\tthis.schemasById = {};\n\t}\n\n\tpublic registerSchema(uri: string, unresolvedSchemaContent: IJSONSchema): void {\n\t\tthis.schemasById[normalizeId(uri)] = unresolvedSchemaContent;\n\t\tthis._onDidChangeSchema.fire(uri);\n\t}\n\n\tpublic notifySchemaChanged(uri: string): void {\n\t\tthis._onDidChangeSchema.fire(uri);\n\t}\n\n\tpublic getSchemaContributions(): ISchemaContributions {\n\t\treturn {\n\t\t\tschemas: this.schemasById,\n\t\t};\n\t}\n\n}\n\nconst jsonContributionRegistry = new JSONContributionRegistry();\nplatform.Registry.add(Extensions.JSONContribution, jsonContributionRegistry);",
            "linguagem": "ts",
            "total_linhas": 83
        },
        "solucao_humana": {
            "patch_diff": "@@ -38,9 +38,7 @@ export interface IJSONContributionRegistry {\n \tgetSchemaContributions(): ISchemaContributions;\n }\n \n-export interface IJSONContributionRegistryEvent {\n \n-}\n \n function normalizeId(id: string) {\n \tif (id.length > 0 && id.charAt(id.length - 1) === '#') {",
            "apenas_linhas_adicionadas": []
        },
        "LLM": "CHAT GPT",
        "solucao_llm": "❌ REMOVIDO: interface IJSONContributionRegistryEvent (não utilizada)"
    },
    {
        "id": 49613,
        "url": "https://github.com/microsoft/vscode/pull/49613",
        "arquivo_caminho": "src/vs/workbench/services/themes/electron-browser/fileIconThemeData.ts",
        "descricao_bug": "There is a spell error in src/vs/workbench/services/themes/electron-browser/fileIconThemeData.ts\r\n\r\nfont-weigth => font-weight",
        "contexto": {
            "codigo_completo_bugado": "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport URI from 'vs/base/common/uri';\nimport * as nls from 'vs/nls';\nimport * as Paths from 'path';\nimport * as Json from 'vs/base/common/json';\nimport { ExtensionData, IThemeExtensionPoint, IFileIconTheme } from 'vs/workbench/services/themes/common/workbenchThemeService';\nimport { TPromise } from 'vs/base/common/winjs.base';\nimport * as pfs from 'vs/base/node/pfs';\nimport { WorkbenchThemeService } from 'vs/workbench/services/themes/electron-browser/workbenchThemeService';\nimport { getParseErrorMessage } from 'vs/base/common/jsonErrorMessages';\n\nexport class FileIconThemeData implements IFileIconTheme {\n\tid: string;\n\tlabel: string;\n\tsettingsId: string;\n\tdescription?: string;\n\thasFileIcons?: boolean;\n\thasFolderIcons?: boolean;\n\thidesExplorerArrows?: boolean;\n\tisLoaded: boolean;\n\tpath?: string;\n\textensionData: ExtensionData;\n\n\tstyleSheetContent?: string;\n\n\tprivate constructor() {\n\t}\n\n\tpublic ensureLoaded(themeService: WorkbenchThemeService): TPromise<string> {\n\t\tif (!this.isLoaded) {\n\t\t\tif (this.path) {\n\t\t\t\treturn _loadIconThemeDocument(this.path).then(iconThemeDocument => {\n\t\t\t\t\tlet result = _processIconThemeDocument(this.id, this.path, iconThemeDocument);\n\t\t\t\t\tthis.styleSheetContent = result.content;\n\t\t\t\t\tthis.hasFileIcons = result.hasFileIcons;\n\t\t\t\t\tthis.hasFolderIcons = result.hasFolderIcons;\n\t\t\t\t\tthis.hidesExplorerArrows = result.hidesExplorerArrows;\n\t\t\t\t\tthis.isLoaded = true;\n\t\t\t\t\treturn this.styleSheetContent;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn TPromise.as(this.styleSheetContent);\n\t}\n\n\tstatic fromExtensionTheme(iconTheme: IThemeExtensionPoint, normalizedAbsolutePath: string, extensionData: ExtensionData): FileIconThemeData {\n\t\tlet themeData = new FileIconThemeData();\n\t\tthemeData.id = extensionData.extensionId + '-' + iconTheme.id;\n\t\tthemeData.label = iconTheme.label || Paths.basename(iconTheme.path);\n\t\tthemeData.settingsId = iconTheme.id;\n\t\tthemeData.description = iconTheme.description;\n\t\tthemeData.path = normalizedAbsolutePath;\n\t\tthemeData.extensionData = extensionData;\n\t\tthemeData.isLoaded = false;\n\t\treturn themeData;\n\t}\n\n\tprivate static _noIconTheme: FileIconThemeData = null;\n\n\tstatic noIconTheme(): FileIconThemeData {\n\t\tlet themeData = FileIconThemeData._noIconTheme;\n\t\tif (!themeData) {\n\t\t\tthemeData = FileIconThemeData._noIconTheme = new FileIconThemeData();\n\t\t\tthemeData.id = '';\n\t\t\tthemeData.label = '';\n\t\t\tthemeData.settingsId = null;\n\t\t\tthemeData.hasFileIcons = false;\n\t\t\tthemeData.hasFolderIcons = false;\n\t\t\tthemeData.hidesExplorerArrows = false;\n\t\t\tthemeData.isLoaded = true;\n\t\t\tthemeData.extensionData = null;\n\t\t}\n\t\treturn themeData;\n\t}\n\n\tstatic fromStorageData(input: string): FileIconThemeData {\n\t\ttry {\n\t\t\tlet data = JSON.parse(input);\n\t\t\tlet theme = new FileIconThemeData();\n\t\t\tfor (let key in data) {\n\t\t\t\tswitch (key) {\n\t\t\t\t\tcase 'id':\n\t\t\t\t\tcase 'label':\n\t\t\t\t\tcase 'description':\n\t\t\t\t\tcase 'settingsId':\n\t\t\t\t\tcase 'extensionData':\n\t\t\t\t\tcase 'path':\n\t\t\t\t\tcase 'styleSheetContent':\n\t\t\t\t\tcase 'hasFileIcons':\n\t\t\t\t\tcase 'hidesExplorerArrows':\n\t\t\t\t\tcase 'hasFolderIcons':\n\t\t\t\t\t\ttheme[key] = data[key];\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn theme;\n\t\t} catch (e) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\ttoStorageData() {\n\t\treturn JSON.stringify({\n\t\t\tid: this.id,\n\t\t\tlabel: this.label,\n\t\t\tdescription: this.description,\n\t\t\tsettingsId: this.settingsId,\n\t\t\tpath: this.path,\n\t\t\tstyleSheetContent: this.styleSheetContent,\n\t\t\thasFileIcons: this.hasFileIcons,\n\t\t\thasFolderIcons: this.hasFolderIcons,\n\t\t\thidesExplorerArrows: this.hidesExplorerArrows\n\t\t});\n\t}\n}\n\ninterface IconDefinition {\n\ticonPath: string;\n\tfontColor: string;\n\tfontCharacter: string;\n\tfontSize: string;\n\tfontId: string;\n}\n\ninterface FontDefinition {\n\tid: string;\n\tweight: string;\n\tstyle: string;\n\tsize: string;\n\tsrc: { path: string; format: string; }[];\n}\n\ninterface IconsAssociation {\n\tfolder?: string;\n\tfile?: string;\n\tfolderExpanded?: string;\n\trootFolder?: string;\n\trootFolderExpanded?: string;\n\tfolderNames?: { [folderName: string]: string; };\n\tfolderNamesExpanded?: { [folderName: string]: string; };\n\tfileExtensions?: { [extension: string]: string; };\n\tfileNames?: { [fileName: string]: string; };\n\tlanguageIds?: { [languageId: string]: string; };\n}\n\ninterface IconThemeDocument extends IconsAssociation {\n\ticonDefinitions: { [key: string]: IconDefinition };\n\tfonts: FontDefinition[];\n\tlight?: IconsAssociation;\n\thighContrast?: IconsAssociation;\n\thidesExplorerArrows?: boolean;\n}\n\nfunction _loadIconThemeDocument(fileSetPath: string): TPromise<IconThemeDocument> {\n\treturn pfs.readFile(fileSetPath).then(content => {\n\t\tlet errors: Json.ParseError[] = [];\n\t\tlet contentValue = Json.parse(content.toString(), errors);\n\t\tif (errors.length > 0) {\n\t\t\treturn TPromise.wrapError(new Error(nls.localize('error.cannotparseicontheme', \"Problems parsing file icons file: {0}\", errors.map(e => getParseErrorMessage(e.error)).join(', '))));\n\t\t}\n\t\treturn TPromise.as(contentValue);\n\t});\n}\n\nfunction _processIconThemeDocument(id: string, iconThemeDocumentPath: string, iconThemeDocument: IconThemeDocument): { content: string; hasFileIcons: boolean; hasFolderIcons: boolean; hidesExplorerArrows: boolean; } {\n\n\tlet result = { content: '', hasFileIcons: false, hasFolderIcons: false, hidesExplorerArrows: iconThemeDocument.hidesExplorerArrows };\n\n\tif (!iconThemeDocument.iconDefinitions) {\n\t\treturn result;\n\t}\n\tlet selectorByDefinitionId: { [def: string]: string[] } = {};\n\n\tfunction resolvePath(path: string) {\n\t\tconst uri = URI.file(Paths.join(Paths.dirname(iconThemeDocumentPath), path));\n\t\treturn uri.toString();\n\t}\n\n\tfunction collectSelectors(associations: IconsAssociation, baseThemeClassName?: string) {\n\t\tfunction addSelector(selector: string, defId: string) {\n\t\t\tif (defId) {\n\t\t\t\tlet list = selectorByDefinitionId[defId];\n\t\t\t\tif (!list) {\n\t\t\t\t\tlist = selectorByDefinitionId[defId] = [];\n\t\t\t\t}\n\t\t\t\tlist.push(selector);\n\t\t\t}\n\t\t}\n\t\tif (associations) {\n\t\t\tlet qualifier = '.show-file-icons';\n\t\t\tif (baseThemeClassName) {\n\t\t\t\tqualifier = baseThemeClassName + ' ' + qualifier;\n\t\t\t}\n\n\t\t\tlet expanded = '.monaco-tree-row.expanded'; // workaround for #11453\n\n\t\t\tif (associations.folder) {\n\t\t\t\taddSelector(`${qualifier} .folder-icon::before`, associations.folder);\n\t\t\t\tresult.hasFolderIcons = true;\n\t\t\t}\n\n\t\t\tif (associations.folderExpanded) {\n\t\t\t\taddSelector(`${qualifier} ${expanded} .folder-icon::before`, associations.folderExpanded);\n\t\t\t\tresult.hasFolderIcons = true;\n\t\t\t}\n\n\t\t\tlet rootFolder = associations.rootFolder || associations.folder;\n\t\t\tlet rootFolderExpanded = associations.rootFolderExpanded || associations.folderExpanded;\n\n\t\t\tif (rootFolder) {\n\t\t\t\taddSelector(`${qualifier} .rootfolder-icon::before`, rootFolder);\n\t\t\t\tresult.hasFolderIcons = true;\n\t\t\t}\n\n\t\t\tif (rootFolderExpanded) {\n\t\t\t\taddSelector(`${qualifier} ${expanded} .rootfolder-icon::before`, rootFolderExpanded);\n\t\t\t\tresult.hasFolderIcons = true;\n\t\t\t}\n\n\t\t\tif (associations.file) {\n\t\t\t\taddSelector(`${qualifier} .file-icon::before`, associations.file);\n\t\t\t\tresult.hasFileIcons = true;\n\t\t\t}\n\n\t\t\tlet folderNames = associations.folderNames;\n\t\t\tif (folderNames) {\n\t\t\t\tfor (let folderName in folderNames) {\n\t\t\t\t\taddSelector(`${qualifier} .${escapeCSS(folderName.toLowerCase())}-name-folder-icon.folder-icon::before`, folderNames[folderName]);\n\t\t\t\t\tresult.hasFolderIcons = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet folderNamesExpanded = associations.folderNamesExpanded;\n\t\t\tif (folderNamesExpanded) {\n\t\t\t\tfor (let folderName in folderNamesExpanded) {\n\t\t\t\t\taddSelector(`${qualifier} ${expanded} .${escapeCSS(folderName.toLowerCase())}-name-folder-icon.folder-icon::before`, folderNamesExpanded[folderName]);\n\t\t\t\t\tresult.hasFolderIcons = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet languageIds = associations.languageIds;\n\t\t\tif (languageIds) {\n\t\t\t\tif (!languageIds.jsonc && languageIds.json) {\n\t\t\t\t\tlanguageIds.jsonc = languageIds.json;\n\t\t\t\t}\n\t\t\t\tfor (let languageId in languageIds) {\n\t\t\t\t\taddSelector(`${qualifier} .${escapeCSS(languageId)}-lang-file-icon.file-icon::before`, languageIds[languageId]);\n\t\t\t\t\tresult.hasFileIcons = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet fileExtensions = associations.fileExtensions;\n\t\t\tif (fileExtensions) {\n\t\t\t\tfor (let fileExtension in fileExtensions) {\n\t\t\t\t\tlet selectors: string[] = [];\n\t\t\t\t\tlet segments = fileExtension.toLowerCase().split('.');\n\t\t\t\t\tif (segments.length) {\n\t\t\t\t\t\tfor (let i = 0; i < segments.length; i++) {\n\t\t\t\t\t\t\tselectors.push(`.${escapeCSS(segments.slice(i).join('.'))}-ext-file-icon`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tselectors.push('.ext-file-icon'); // extra segment to increase file-ext score\n\t\t\t\t\t}\n\t\t\t\t\taddSelector(`${qualifier} ${selectors.join('')}.file-icon::before`, fileExtensions[fileExtension]);\n\t\t\t\t\tresult.hasFileIcons = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet fileNames = associations.fileNames;\n\t\t\tif (fileNames) {\n\t\t\t\tfor (let fileName in fileNames) {\n\t\t\t\t\tlet selectors: string[] = [];\n\t\t\t\t\tfileName = fileName.toLowerCase();\n\t\t\t\t\tselectors.push(`.${escapeCSS(fileName)}-name-file-icon`);\n\t\t\t\t\tlet segments = fileName.split('.');\n\t\t\t\t\tif (segments.length) {\n\t\t\t\t\t\tfor (let i = 1; i < segments.length; i++) {\n\t\t\t\t\t\t\tselectors.push(`.${escapeCSS(segments.slice(i).join('.'))}-ext-file-icon`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tselectors.push('.ext-file-icon'); // extra segment to increase file-ext score\n\t\t\t\t\t}\n\t\t\t\t\taddSelector(`${qualifier} ${selectors.join('')}.file-icon::before`, fileNames[fileName]);\n\t\t\t\t\tresult.hasFileIcons = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcollectSelectors(iconThemeDocument);\n\tcollectSelectors(iconThemeDocument.light, '.vs');\n\tcollectSelectors(iconThemeDocument.highContrast, '.hc-black');\n\n\tif (!result.hasFileIcons && !result.hasFolderIcons) {\n\t\treturn result;\n\t}\n\n\tlet cssRules: string[] = [];\n\n\tlet fonts = iconThemeDocument.fonts;\n\tif (Array.isArray(fonts)) {\n\t\tfonts.forEach(font => {\n\t\t\tlet src = font.src.map(l => `url('${resolvePath(l.path)}') format('${l.format}')`).join(', ');\n\t\t\tcssRules.push(`@font-face { src: ${src}; font-family: '${font.id}'; font-weigth: ${font.weight}; font-style: ${font.style}; }`);\n\t\t});\n\t\tcssRules.push(`.show-file-icons .file-icon::before, .show-file-icons .folder-icon::before, .show-file-icons .rootfolder-icon::before { font-family: '${fonts[0].id}'; font-size: ${fonts[0].size || '150%'}}`);\n\t}\n\n\tfor (let defId in selectorByDefinitionId) {\n\t\tlet selectors = selectorByDefinitionId[defId];\n\t\tlet definition = iconThemeDocument.iconDefinitions[defId];\n\t\tif (definition) {\n\t\t\tif (definition.iconPath) {\n\t\t\t\tcssRules.push(`${selectors.join(', ')} { content: ' '; background-image: url(\"${resolvePath(definition.iconPath)}\"); }`);\n\t\t\t}\n\t\t\tif (definition.fontCharacter || definition.fontColor) {\n\t\t\t\tlet body = '';\n\t\t\t\tif (definition.fontColor) {\n\t\t\t\t\tbody += ` color: ${definition.fontColor};`;\n\t\t\t\t}\n\t\t\t\tif (definition.fontCharacter) {\n\t\t\t\t\tbody += ` content: '${definition.fontCharacter}';`;\n\t\t\t\t}\n\t\t\t\tif (definition.fontSize) {\n\t\t\t\t\tbody += ` font-size: ${definition.fontSize};`;\n\t\t\t\t}\n\t\t\t\tif (definition.fontId) {\n\t\t\t\t\tbody += ` font-family: ${definition.fontId};`;\n\t\t\t\t}\n\t\t\t\tcssRules.push(`${selectors.join(', ')} { ${body} }`);\n\t\t\t}\n\t\t}\n\t}\n\tresult.content = cssRules.join('\\n');\n\treturn result;\n}\nfunction escapeCSS(str: string) {\n\treturn window['CSS'].escape(str);\n}",
            "linguagem": "ts",
            "total_linhas": 338
        },
        "solucao_humana": {
            "patch_diff": "@@ -300,7 +300,7 @@ function _processIconThemeDocument(id: string, iconThemeDocumentPath: string, ic\n \tif (Array.isArray(fonts)) {\n \t\tfonts.forEach(font => {\n \t\t\tlet src = font.src.map(l => `url('${resolvePath(l.path)}') format('${l.format}')`).join(', ');\n-\t\t\tcssRules.push(`@font-face { src: ${src}; font-family: '${font.id}'; font-weigth: ${font.weight}; font-style: ${font.style}; }`);\n+\t\t\tcssRules.push(`@font-face { src: ${src}; font-family: '${font.id}'; font-weight: ${font.weight}; font-style: ${font.style}; }`);\n \t\t});\n \t\tcssRules.push(`.show-file-icons .file-icon::before, .show-file-icons .folder-icon::before, .show-file-icons .rootfolder-icon::before { font-family: '${fonts[0].id}'; font-size: ${fonts[0].size || '150%'}}`);\n \t}\n@@ -335,4 +335,4 @@ function _processIconThemeDocument(id: string, iconThemeDocumentPath: string, ic\n }\n function escapeCSS(str: string) {\n \treturn window['CSS'].escape(str);\n-}\n\\ No newline at end of file\n+}",
            "apenas_linhas_adicionadas": [
                "\t\t\tcssRules.push(`@font-face { src: ${src}; font-family: '${font.id}'; font-weight: ${font.weight}; font-style: ${font.style}; }`);",
                "}"
            ]
        },
        "LLM": "CHAT GPT",
        "solucao_llm": "cssRules.push(`@font-face { src: ${src}; font-family: '${font.id}'; font-weight: ${font.weight}; font-style: ${font.style}; }`);"
    },
{
        "id": 47052,
        "url": "https://github.com/microsoft/vscode/pull/47052",
        "arquivo_caminho": "extensions/git/src/commands.ts",
        "descricao_bug": "Git: Delete branch notification should be modal",
        "contexto": {
            "codigo_completo_bugado": "use strict';\n\nimport { Uri, commands, Disposable, window, workspace, QuickPickItem, OutputChannel, Range, WorkspaceEdit, Position, LineChange, SourceControlResourceState, TextDocumentShowOptions, ViewColumn, ProgressLocation, TextEditor, CancellationTokenSource, StatusBarAlignment, MessageOptions } from 'vscode';\nimport { Ref, RefType, Git, GitErrorCodes, Branch } from './git';\nimport { Repository, Resource, Status, CommitOptions, ResourceGroupType } from './repository';\nimport { Model } from './model';\nimport { toGitUri, fromGitUri } from './uri';\nimport { grep, isDescendant } from './util';\nimport { applyLineChanges, intersectDiffWithRange, toLineRanges, invertLineChange, getModifiedRange } from './staging';\nimport * as path from 'path';\nimport { lstat, Stats } from 'fs';\nimport * as os from 'os';\nimport TelemetryReporter from 'vscode-extension-telemetry';\nimport * as nls from 'vscode-nls';\n\nconst localize = nls.loadMessageBundle();\n\nclass CheckoutItem implements QuickPickItem {\n\n\tprotected get shortCommit(): string { return (this.ref.commit || '').substr(0, 8); }\n\tprotected get treeish(): string | undefined { return this.ref.name; }\n\tget label(): string { return this.ref.name || this.shortCommit; }\n\tget description(): string { return this.shortCommit; }\n\n\tconstructor(protected ref: Ref) { }\n\n\tasync run(repository: Repository): Promise<void> {\n\t\tconst ref = this.treeish;\n\n\t\tif (!ref) {\n\t\t\treturn;\n\t\t}\n\n\t\tawait repository.checkout(ref);\n\t}\n}\n\nclass CheckoutTagItem extends CheckoutItem {\n\n\tget description(): string {\n\t\treturn localize('tag at', \"Tag at {0}\", this.shortCommit);\n\t}\n}\n\nclass CheckoutRemoteHeadItem extends CheckoutItem {\n\n\tget description(): string {\n\t\treturn localize('remote branch at', \"Remote branch at {0}\", this.shortCommit);\n\t}\n\n\tprotected get treeish(): string | undefined {\n\t\tif (!this.ref.name) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst match = /^[^/]+\\/(.*)$/.exec(this.ref.name);\n\t\treturn match ? match[1] : this.ref.name;\n\t}\n}\n\nclass BranchDeleteItem implements QuickPickItem {\n\n\tprivate get shortCommit(): string { return (this.ref.commit || '').substr(0, 8); }\n\tget branchName(): string | undefined { return this.ref.name; }\n\tget label(): string { return this.branchName || ''; }\n\tget description(): string { return this.shortCommit; }\n\n\tconstructor(private ref: Ref) { }\n\n\tasync run(repository: Repository, force?: boolean): Promise<void> {\n\t\tif (!this.branchName) {\n\t\t\treturn;\n\t\t}\n\t\tawait repository.deleteBranch(this.branchName, force);\n\t}\n}\n\nclass MergeItem implements QuickPickItem {\n\n\tget label(): string { return this.ref.name || ''; }\n\tget description(): string { return this.ref.name || ''; }\n\n\tconstructor(protected ref: Ref) { }\n\n\tasync run(repository: Repository): Promise<void> {\n\t\tawait repository.merge(this.ref.name! || this.ref.commit!);\n\t}\n}\n\nclass CreateBranchItem implements QuickPickItem {\n\n\tconstructor(private cc: CommandCenter) { }\n\n\tget label(): string { return localize('create branch', '$(plus) Create new branch'); }\n\tget description(): string { return ''; }\n\n\tasync run(repository: Repository): Promise<void> {\n\t\tawait this.cc.branch(repository);\n\t}\n}\n\ninterface CommandOptions {\n\trepository?: boolean;\n\tdiff?: boolean;\n}\n\ninterface Command {\n\tcommandId: string;\n\tkey: string;\n\tmethod: Function;\n\toptions: CommandOptions;\n}\n\nconst Commands: Command[] = [];\n\nfunction command(commandId: string, options: CommandOptions = {}): Function {\n\treturn (target: any, key: string, descriptor: any) => {\n\t\tif (!(typeof descriptor.value === 'function')) {\n\t\t\tthrow new Error('not supported');\n\t\t}\n\n\t\tCommands.push({ commandId, key, method: descriptor.value, options });\n\t};\n}\n\nconst ImageMimetypes = [\n\t'image/png',\n\t'image/gif',\n\t'image/jpeg',\n\t'image/webp',\n\t'image/tiff',\n\t'image/bmp'\n];\n\nexport class CommandCenter {\n\n\tprivate disposables: Disposable[];\n\n\tconstructor(\n\t\tprivate git: Git,\n\t\tprivate model: Model,\n\t\tprivate outputChannel: OutputChannel,\n\t\tprivate telemetryReporter: TelemetryReporter\n\t) {\n\t\tthis.disposables = Commands.map(({ commandId, key, method, options }) => {\n\t\t\tconst command = this.createCommand(commandId, key, method, options);\n\n\t\t\tif (options.diff) {\n\t\t\t\treturn commands.registerDiffInformationCommand(commandId, command);\n\t\t\t} else {\n\t\t\t\treturn commands.registerCommand(commandId, command);\n\t\t\t}\n\t\t});\n\t}\n\n\t@command('git.refresh', { repository: true })\n\tasync refresh(repository: Repository): Promise<void> {\n\t\tawait repository.status();\n\t}\n\n\t@command('git.openResource')\n\tasync openResource(resource: Resource): Promise<void> {\n\t\tawait this._openResource(resource, undefined, true, false);\n\t}\n\n\tprivate async _openResource(resource: Resource, preview?: boolean, preserveFocus?: boolean, preserveSelection?: boolean): Promise<void> {\n\t\tlet stat: Stats | undefined;\n\n\t\ttry {\n\t\t\tstat = await new Promise<Stats>((c, e) => lstat(resource.resourceUri.fsPath, (err, stat) => err ? e(err) : c(stat)));\n\t\t} catch (err) {\n\t\t\t// noop\n\t\t}\n\n\t\tlet left: Uri | undefined;\n\t\tlet right: Uri | undefined;\n\n\t\tif (stat && stat.isDirectory()) {\n\t\t\tconst repository = this.model.getRepositoryForSubmodule(resource.resourceUri);\n\n\t\t\tif (repository) {\n\t\t\t\tright = toGitUri(resource.resourceUri, resource.resourceGroupType === ResourceGroupType.Index ? 'index' : 'wt', { submoduleOf: repository.root });\n\t\t\t}\n\t\t} else {\n\t\t\tleft = await this.getLeftResource(resource);\n\t\t\tright = await this.getRightResource(resource);\n\t\t}\n\n\t\tconst title = this.getTitle(resource);\n\n\t\tif (!right) {\n\t\t\t// TODO\n\t\t\tconsole.error('oh no');\n\t\t\treturn;\n\t\t}\n\n\t\tconst opts: TextDocumentShowOptions = {\n\t\t\tpreserveFocus,\n\t\t\tpreview,\n\t\t\tviewColumn: ViewColumn.Active\n\t\t};\n\n\t\tconst activeTextEditor = window.activeTextEditor;\n\n\t\t// Check if active text editor has same path as other editor. we cannot compare via\n\t\t// URI.toString() here because the schemas can be different. Instead we just go by path.\n\t\tif (preserveSelection && activeTextEditor && activeTextEditor.document.uri.path === right.path) {\n\t\t\topts.selection = activeTextEditor.selection;\n\t\t}\n\n\t\tif (!left) {\n\t\t\tawait commands.executeCommand<void>('vscode.open', right, opts);\n\t\t} else {\n\t\t\tawait commands.executeCommand<void>('vscode.diff', left, right, title, opts);\n\t\t}\n\t}\n\n\tprivate async getURI(uri: Uri, ref: string): Promise<Uri | undefined> {\n\t\tconst repository = this.model.getRepository(uri);\n\n\t\tif (!repository) {\n\t\t\treturn toGitUri(uri, ref);\n\t\t}\n\n\t\ttry {\n\t\t\tlet gitRef = ref;\n\n\t\t\tif (gitRef === '~') {\n\t\t\t\tconst uriString = uri.toString();\n\t\t\t\tconst [indexStatus] = repository.indexGroup.resourceStates.filter(r => r.resourceUri.toString() === uriString);\n\t\t\t\tgitRef = indexStatus ? '' : 'HEAD';\n\t\t\t}\n\n\t\t\tconst { size, object } = await repository.lstree(gitRef, uri.fsPath);\n\t\t\tconst { mimetype } = await repository.detectObjectType(object);\n\n\t\t\tif (mimetype === 'text/plain') {\n\t\t\t\treturn toGitUri(uri, ref);\n\t\t\t}\n\n\t\t\tif (size > 1000000) { // 1 MB\n\t\t\t\treturn Uri.parse(`data:;label:${path.basename(uri.fsPath)};description:${gitRef},`);\n\t\t\t}\n\n\t\t\tif (ImageMimetypes.indexOf(mimetype) > -1) {\n\t\t\t\tconst contents = await repository.buffer(gitRef, uri.fsPath);\n\t\t\t\treturn Uri.parse(`data:${mimetype};label:${path.basename(uri.fsPath)};description:${gitRef};size:${size};base64,${contents.toString('base64')}`);\n\t\t\t}\n\n\t\t\treturn Uri.parse(`data:;label:${path.basename(uri.fsPath)};description:${gitRef},`);\n\n\t\t} catch (err) {\n\t\t\treturn toGitUri(uri, ref);\n\t\t}\n\t}\n\n\tprivate async getLeftResource(resource: Resource): Promise<Uri | undefined> {\n\t\tswitch (resource.type) {\n\t\t\tcase Status.INDEX_MODIFIED:\n\t\t\tcase Status.INDEX_RENAMED:\n\t\t\t\treturn this.getURI(resource.original, 'HEAD');\n\n\t\t\tcase Status.MODIFIED:\n\t\t\t\treturn this.getURI(resource.resourceUri, '~');\n\n\t\t\tcase Status.DELETED_BY_THEM:\n\t\t\t\treturn this.getURI(resource.resourceUri, '');\n\t\t}\n\t}\n\n\tprivate async getRightResource(resource: Resource): Promise<Uri | undefined> {\n\t\tswitch (resource.type) {\n\t\t\tcase Status.INDEX_MODIFIED:\n\t\t\tcase Status.INDEX_ADDED:\n\t\t\tcase Status.INDEX_COPIED:\n\t\t\tcase Status.INDEX_RENAMED:\n\t\t\t\treturn this.getURI(resource.resourceUri, '');\n\n\t\t\tcase Status.INDEX_DELETED:\n\t\t\tcase Status.DELETED_BY_THEM:\n\t\t\tcase Status.DELETED:\n\t\t\t\treturn this.getURI(resource.resourceUri, 'HEAD');\n\n\t\t\tcase Status.MODIFIED:\n\t\t\tcase Status.UNTRACKED:\n\t\t\tcase Status.IGNORED:\n\t\t\t\tconst repository = this.model.getRepository(resource.resourceUri);\n\n\t\t\t\tif (!repository) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst uriString = resource.resourceUri.toString();\n\t\t\t\tconst [indexStatus] = repository.indexGroup.resourceStates.filter(r => r.resourceUri.toString() === uriString);\n\n\t\t\t\tif (indexStatus && indexStatus.renameResourceUri) {\n\t\t\t\t\treturn indexStatus.renameResourceUri;\n\t\t\t\t}\n\n\t\t\t\treturn resource.resourceUri;\n\n\t\t\tcase Status.BOTH_ADDED:\n\t\t\tcase Status.BOTH_MODIFIED:\n\t\t\t\treturn resource.resourceUri;\n\t\t}\n\t}\n\n\tprivate getTitle(resource: Resource): string {\n\t\tconst basename = path.basename(resource.resourceUri.fsPath);\n\n\t\tswitch (resource.type) {\n\t\t\tcase Status.INDEX_MODIFIED:\n\t\t\tcase Status.INDEX_RENAMED:\n\t\t\tcase Status.DELETED_BY_THEM:\n\t\t\t\treturn `${basename} (Index)`;\n\n\t\t\tcase Status.MODIFIED:\n\t\t\tcase Status.BOTH_ADDED:\n\t\t\tcase Status.BOTH_MODIFIED:\n\t\t\t\treturn `${basename} (Working Tree)`;\n\t\t}\n\n\t\treturn '';\n\t}\n\n\tprivate static cloneId = 0;\n\n\t@command('git.clone')\n\tasync clone(url?: string): Promise<void> {\n\t\tif (!url) {\n\t\t\turl = await window.showInputBox({\n\t\t\t\tprompt: localize('repourl', \"Repository URL\"),\n\t\t\t\tignoreFocusOut: true\n\t\t\t});\n\t\t}\n\n\t\tif (!url) {\n\t\t\t/* __GDPR__\n\t\t\t\t\"clone\" : {\n\t\t\t\t\t\"outcome\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n\t\t\t\t}\n\t\t\t*/\n\t\t\tthis.telemetryReporter.sendTelemetryEvent('clone', { outcome: 'no_URL' });\n\t\t\treturn;\n\t\t}\n\n\t\tconst config = workspace.getConfiguration('git');\n\t\tlet value = config.get<string>('defaultCloneDirectory') || os.homedir();\n\n\t\tconst parentPath = await window.showInputBox({\n\t\t\tprompt: localize('parent', \"Parent Directory\"),\n\t\t\tvalue,\n\t\t\tignoreFocusOut: true\n\t\t});\n\n\t\tif (!parentPath) {\n\t\t\t/* __GDPR__\n\t\t\t\t\"clone\" : {\n\t\t\t\t\t\"outcome\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n\t\t\t\t}\n\t\t\t*/\n\t\t\tthis.telemetryReporter.sendTelemetryEvent('clone', { outcome: 'no_directory' });\n\t\t\treturn;\n\t\t}\n\n\t\tconst tokenSource = new CancellationTokenSource();\n\t\tconst cancelCommandId = `cancelClone${CommandCenter.cloneId++}`;\n\t\tconst commandDisposable = commands.registerCommand(cancelCommandId, () => tokenSource.cancel());\n\n\t\tconst statusBarItem = window.createStatusBarItem(StatusBarAlignment.Left);\n\t\tstatusBarItem.text = localize('cancel', \"$(sync~spin) Cloning repository... Click to cancel\");\n\t\tstatusBarItem.tooltip = localize('cancel tooltip', \"Cancel clone\");\n\t\tstatusBarItem.command = cancelCommandId;\n\t\tstatusBarItem.show();\n\n\t\tconst clonePromise = this.git.clone(url, parentPath.replace(/^~/, os.homedir()), tokenSource.token);\n\n\t\ttry {\n\t\t\twindow.withProgress({ location: ProgressLocation.SourceControl, title: localize('cloning', \"Cloning git repository...\") }, () => clonePromise);\n\n\t\t\tconst repositoryPath = await clonePromise;\n\n\t\t\tconst open = localize('openrepo', \"Open Repository\");\n\t\t\tconst result = await window.showInformationMessage(localize('proposeopen', \"Would you like to open the cloned repository?\"), open);\n\n\t\t\tconst openFolder = result === open;\n\t\t\t/* __GDPR__\n\t\t\t\t\"clone\" : {\n\t\t\t\t\t\"outcome\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" },\n\t\t\t\t\t\"openFolder\": { \"classification\": \"SystemMetaData\", \"purpose\": \"PerformanceAndHealth\", \"isMeasurement\": true }\n\t\t\t\t}\n\t\t\t*/\n\t\t\tthis.telemetryReporter.sendTelemetryEvent('clone', { outcome: 'success' }, { openFolder: openFolder ? 1 : 0 });\n\t\t\tif (openFolder) {\n\t\t\t\tcommands.executeCommand('vscode.openFolder', Uri.file(repositoryPath));\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tif (/already exists and is not an empty directory/.test(err && err.stderr || '')) {\n\t\t\t\t/* __GDPR__\n\t\t\t\t\t\"clone\" : {\n\t\t\t\t\t\t\"outcome\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n\t\t\t\t\t}\n\t\t\t\t*/\n\t\t\t\tthis.telemetryReporter.sendTelemetryEvent('clone', { outcome: 'directory_not_empty' });\n\t\t\t} else if (/Cancelled/i.test(err && (err.message || err.stderr || ''))) {\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\t/* __GDPR__\n\t\t\t\t\t\"clone\" : {\n\t\t\t\t\t\t\"outcome\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n\t\t\t\t\t}\n\t\t\t\t*/\n\t\t\t\tthis.telemetryReporter.sendTelemetryEvent('clone', { outcome: 'error' });\n\t\t\t}\n\n\t\t\tthrow err;\n\t\t} finally {\n\t\t\tcommandDisposable.dispose();\n\t\t\tstatusBarItem.dispose();\n\t\t}\n\t}\n\n\t@command('git.init')\n\tasync init(): Promise<void> {\n\t\tlet path: string | undefined;\n\n\t\tif (workspace.workspaceFolders && workspace.workspaceFolders.length > 1) {\n\t\t\tconst placeHolder = localize('init', \"Pick workspace folder to initialize git repo in\");\n\t\t\tconst items = workspace.workspaceFolders.map(folder => ({ label: folder.name, description: folder.uri.fsPath, folder }));\n\t\t\tconst item = await window.showQuickPick(items, { placeHolder, ignoreFocusOut: true });\n\n\t\t\tif (!item) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tpath = item.folder.uri.fsPath;\n\t\t}\n\n\t\tif (!path) {\n\t\t\tconst homeUri = Uri.file(os.homedir());\n\t\t\tconst defaultUri = workspace.workspaceFolders && workspace.workspaceFolders.length > 0\n\t\t\t\t? Uri.file(workspace.workspaceFolders[0].uri.fsPath)\n\t\t\t\t: homeUri;\n\n\t\t\tconst result = await window.showOpenDialog({\n\t\t\t\tcanSelectFiles: false,\n\t\t\t\tcanSelectFolders: true,\n\t\t\t\tcanSelectMany: false,\n\t\t\t\tdefaultUri,\n\t\t\t\topenLabel: localize('init repo', \"Initialize Repository\")\n\t\t\t});\n\n\t\t\tif (!result || result.length === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst uri = result[0];\n\n\t\t\tif (homeUri.toString().startsWith(uri.toString())) {\n\t\t\t\tconst yes = localize('create repo', \"Initialize Repository\");\n\t\t\t\tconst answer = await window.showWarningMessage(localize('are you sure', \"This will create a Git repository in '{0}'. Are you sure you want to continue?\", uri.fsPath), yes);\n\n\t\t\t\tif (answer !== yes) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpath = uri.fsPath;\n\t\t}\n\n\t\tawait this.git.init(path);\n\t\tawait this.model.tryOpenRepository(path);\n\t}\n\n\t@command('git.close', { repository: true })\n\tasync close(repository: Repository): Promise<void> {\n\t\tthis.model.close(repository);\n\t}\n\n\t@command('git.openFile')\n\tasync openFile(arg?: Resource | Uri, ...resourceStates: SourceControlResourceState[]): Promise<void> {\n\t\tconst preserveFocus = arg instanceof Resource;\n\n\t\tlet uris: Uri[] | undefined;\n\n\t\tif (arg instanceof Uri) {\n\t\t\tif (arg.scheme === 'git') {\n\t\t\t\turis = [Uri.file(fromGitUri(arg).path)];\n\t\t\t} else if (arg.scheme === 'file') {\n\t\t\t\turis = [arg];\n\t\t\t}\n\t\t} else {\n\t\t\tlet resource = arg;\n\n\t\t\tif (!(resource instanceof Resource)) {\n\t\t\t\t// can happen when called from a keybinding\n\t\t\t\tresource = this.getSCMResource();\n\t\t\t}\n\n\t\t\tif (resource) {\n\t\t\t\tconst resources = ([resource, ...resourceStates] as Resource[])\n\t\t\t\t\t.filter(r => r.type !== Status.DELETED && r.type !== Status.INDEX_DELETED);\n\n\t\t\t\turis = resources.map(r => r.resourceUri);\n\t\t\t}\n\t\t}\n\n\t\tif (!uris) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst preview = uris.length === 1 ? true : false;\n\t\tconst activeTextEditor = window.activeTextEditor;\n\t\tfor (const uri of uris) {\n\t\t\tconst opts: TextDocumentShowOptions = {\n\t\t\t\tpreserveFocus,\n\t\t\t\tpreview,\n\t\t\t\tviewColumn: ViewColumn.Active\n\t\t\t};\n\n\t\t\t// Check if active text editor has same path as other editor. we cannot compare via\n\t\t\t// URI.toString() here because the schemas can be different. Instead we just go by path.\n\t\t\tif (activeTextEditor && activeTextEditor.document.uri.path === uri.path) {\n\t\t\t\topts.selection = activeTextEditor.selection;\n\t\t\t}\n\n\t\t\tawait commands.executeCommand<void>('vscode.open', uri, opts);\n\t\t}\n\t}\n\n\t@command('git.openFile2')\n\tasync openFile2(arg?: Resource | Uri, ...resourceStates: SourceControlResourceState[]): Promise<void> {\n\t\tthis.openFile(arg, ...resourceStates);\n\t}\n\n\t@command('git.openHEADFile')\n\tasync openHEADFile(arg?: Resource | Uri): Promise<void> {\n\t\tlet resource: Resource | undefined = undefined;\n\n\t\tif (arg instanceof Resource) {\n\t\t\tresource = arg;\n\t\t} else if (arg instanceof Uri) {\n\t\t\tresource = this.getSCMResource(arg);\n\t\t} else {\n\t\t\tresource = this.getSCMResource();\n\t\t}\n\n\t\tif (!resource) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst HEAD = await this.getLeftResource(resource);\n\n\t\tif (!HEAD) {\n\t\t\twindow.showWarningMessage(localize('HEAD not available', \"HEAD version of '{0}' is not available.\", path.basename(resource.resourceUri.fsPath)));\n\t\t\treturn;\n\t\t}\n\n\t\treturn await commands.executeCommand<void>('vscode.open', HEAD);\n\t}\n\n\t@command('git.openChange')\n\tasync openChange(arg?: Resource | Uri, ...resourceStates: SourceControlResourceState[]): Promise<void> {\n\t\tconst preserveFocus = arg instanceof Resource;\n\t\tconst preserveSelection = arg instanceof Uri || !arg;\n\t\tlet resources: Resource[] | undefined = undefined;\n\n\t\tif (arg instanceof Uri) {\n\t\t\tconst resource = this.getSCMResource(arg);\n\t\t\tif (resource !== undefined) {\n\t\t\t\tresources = [resource];\n\t\t\t}\n\t\t} else {\n\t\t\tlet resource: Resource | undefined = undefined;\n\n\t\t\tif (arg instanceof Resource) {\n\t\t\t\tresource = arg;\n\t\t\t} else {\n\t\t\t\tresource = this.getSCMResource();\n\t\t\t}\n\n\t\t\tif (resource) {\n\t\t\t\tresources = [...resourceStates as Resource[], resource];\n\t\t\t}\n\t\t}\n\n\t\tif (!resources) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst preview = resources.length === 1 ? undefined : false;\n\t\tfor (const resource of resources) {\n\t\t\tawait this._openResource(resource, preview, preserveFocus, preserveSelection);\n\t\t}\n\t}\n\n\t@command('git.stage')\n\tasync stage(...resourceStates: SourceControlResourceState[]): Promise<void> {\n\t\tif (resourceStates.length === 0 || (resourceStates[0] && !(resourceStates[0].resourceUri instanceof Uri))) {\n\t\t\tconst resource = this.getSCMResource();\n\n\t\t\tif (!resource) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tresourceStates = [resource];\n\t\t}\n\n\t\tconst selection = resourceStates.filter(s => s instanceof Resource) as Resource[];\n\t\tconst merge = selection.filter(s => s.resourceGroupType === ResourceGroupType.Merge);\n\t\tconst bothModified = merge.filter(s => s.type === Status.BOTH_MODIFIED);\n\t\tconst promises = bothModified.map(s => grep(s.resourceUri.fsPath, /^<{7}|^={7}|^>{7}/));\n\t\tconst unresolvedBothModified = await Promise.all<boolean>(promises);\n\t\tconst resolvedConflicts = bothModified.filter((s, i) => !unresolvedBothModified[i]);\n\t\tconst unresolvedConflicts = [\n\t\t\t...merge.filter(s => s.type !== Status.BOTH_MODIFIED),\n\t\t\t...bothModified.filter((s, i) => unresolvedBothModified[i])\n\t\t];\n\n\t\tif (unresolvedConflicts.length > 0) {\n\t\t\tconst message = unresolvedConflicts.length > 1\n\t\t\t\t? localize('confirm stage files with merge conflicts', \"Are you sure you want to stage {0} files with merge conflicts?\", unresolvedConflicts.length)\n\t\t\t\t: localize('confirm stage file with merge conflicts', \"Are you sure you want to stage {0} with merge conflicts?\", path.basename(unresolvedConflicts[0].resourceUri.fsPath));\n\n\t\t\tconst yes = localize('yes', \"Yes\");\n\t\t\tconst pick = await window.showWarningMessage(message, { modal: true }, yes);\n\n\t\t\tif (pick !== yes) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tconst workingTree = selection.filter(s => s.resourceGroupType === ResourceGroupType.WorkingTree);\n\t\tconst scmResources = [...workingTree, ...resolvedConflicts, ...unresolvedConflicts];\n\n\t\tif (!scmResources.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst resources = scmResources.map(r => r.resourceUri);\n\t\tawait this.runByRepository(resources, async (repository, resources) => repository.add(resources));\n\t}\n\n\t@command('git.stageAll', { repository: true })\n\tasync stageAll(repository: Repository): Promise<void> {\n\t\tconst resources = repository.mergeGroup.resourceStates.filter(s => s instanceof Resource) as Resource[];\n\t\tconst mergeConflicts = resources.filter(s => s.resourceGroupType === ResourceGroupType.Merge);\n\n\t\tif (mergeConflicts.length > 0) {\n\t\t\tconst message = mergeConflicts.length > 1\n\t\t\t\t? localize('confirm stage files with merge conflicts', \"Are you sure you want to stage {0} files with merge conflicts?\", mergeConflicts.length)\n\t\t\t\t: localize('confirm stage file with merge conflicts', \"Are you sure you want to stage {0} with merge conflicts?\", path.basename(mergeConflicts[0].resourceUri.fsPath));\n\n\t\t\tconst yes = localize('yes', \"Yes\");\n\t\t\tconst pick = await window.showWarningMessage(message, { modal: true }, yes);\n\n\t\t\tif (pick !== yes) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tawait repository.add([]);\n\t}\n\n\t@command('git.stageChange')\n\tasync stageChange(uri: Uri, changes: LineChange[], index: number): Promise<void> {\n\t\tconst textEditor = window.visibleTextEditors.filter(e => e.document.uri.toString() === uri.toString())[0];\n\n\t\tif (!textEditor) {\n\t\t\treturn;\n\t\t}\n\n\t\tawait this._stageChanges(textEditor, [changes[index]]);\n\t}\n\n\t@command('git.stageSelectedRanges', { diff: true })\n\tasync stageSelectedChanges(changes: LineChange[]): Promise<void> {\n\t\tconst textEditor = window.activeTextEditor;\n\n\t\tif (!textEditor) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst modifiedDocument = textEditor.document;\n\t\tconst selectedLines = toLineRanges(textEditor.selections, modifiedDocument);\n\t\tconst selectedChanges = changes\n\t\t\t.map(diff => selectedLines.reduce<LineChange | null>((result, range) => result || intersectDiffWithRange(modifiedDocument, diff, range), null))\n\t\t\t.filter(d => !!d) as LineChange[];\n\n\t\tif (!selectedChanges.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tawait this._stageChanges(textEditor, selectedChanges);\n\t}\n\n\tprivate async _stageChanges(textEditor: TextEditor, changes: LineChange[]): Promise<void> {\n\t\tconst modifiedDocument = textEditor.document;\n\t\tconst modifiedUri = modifiedDocument.uri;\n\n\t\tif (modifiedUri.scheme !== 'file') {\n\t\t\treturn;\n\t\t}\n\n\t\tconst originalUri = toGitUri(modifiedUri, '~');\n\t\tconst originalDocument = await workspace.openTextDocument(originalUri);\n\t\tconst result = applyLineChanges(originalDocument, modifiedDocument, changes);\n\n\t\tawait this.runByRepository(modifiedUri, async (repository, resource) => await repository.stage(resource, result));\n\t}\n\n\t@command('git.revertChange')\n\tasync revertChange(uri: Uri, changes: LineChange[], index: number): Promise<void> {\n\t\tconst textEditor = window.visibleTextEditors.filter(e => e.document.uri.toString() === uri.toString())[0];\n\n\t\tif (!textEditor) {\n\t\t\treturn;\n\t\t}\n\n\t\tawait this._revertChanges(textEditor, [...changes.slice(0, index), ...changes.slice(index + 1)]);\n\t}\n\n\t@command('git.revertSelectedRanges', { diff: true })\n\tasync revertSelectedRanges(changes: LineChange[]): Promise<void> {\n\t\tconst textEditor = window.activeTextEditor;\n\n\t\tif (!textEditor) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst modifiedDocument = textEditor.document;\n\t\tconst selections = textEditor.selections;\n\t\tconst selectedChanges = changes.filter(change => {\n\t\t\tconst modifiedRange = getModifiedRange(modifiedDocument, change);\n\t\t\treturn selections.every(selection => !selection.intersection(modifiedRange));\n\t\t});\n\n\t\tif (selectedChanges.length === changes.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tawait this._revertChanges(textEditor, selectedChanges);\n\t}\n\n\tprivate async _revertChanges(textEditor: TextEditor, changes: LineChange[]): Promise<void> {\n\t\tconst modifiedDocument = textEditor.document;\n\t\tconst modifiedUri = modifiedDocument.uri;\n\n\t\tif (modifiedUri.scheme !== 'file') {\n\t\t\treturn;\n\t\t}\n\n\t\tconst originalUri = toGitUri(modifiedUri, '~');\n\t\tconst originalDocument = await workspace.openTextDocument(originalUri);\n\t\tconst basename = path.basename(modifiedUri.fsPath);\n\t\tconst message = localize('confirm revert', \"Are you sure you want to revert the selected changes in {0}?\", basename);\n\t\tconst yes = localize('revert', \"Revert Changes\");\n\t\tconst pick = await window.showWarningMessage(message, { modal: true }, yes);\n\n\t\tif (pick !== yes) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst result = applyLineChanges(originalDocument, modifiedDocument, changes);\n\t\tconst edit = new WorkspaceEdit();\n\t\tedit.replace(modifiedUri, new Range(new Position(0, 0), modifiedDocument.lineAt(modifiedDocument.lineCount - 1).range.end), result);\n\t\tworkspace.applyEdit(edit);\n\t\tawait modifiedDocument.save();\n\t}\n\n\t@command('git.unstage')\n\tasync unstage(...resourceStates: SourceControlResourceState[]): Promise<void> {\n\t\tif (resourceStates.length === 0 || (resourceStates[0] && !(resourceStates[0].resourceUri instanceof Uri))) {\n\t\t\tconst resource = this.getSCMResource();\n\n\t\t\tif (!resource) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tresourceStates = [resource];\n\t\t}\n\n\t\tconst scmResources = resourceStates\n\t\t\t.filter(s => s instanceof Resource && s.resourceGroupType === ResourceGroupType.Index) as Resource[];\n\n\t\tif (!scmResources.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst resources = scmResources.map(r => r.resourceUri);\n\t\tawait this.runByRepository(resources, async (repository, resources) => repository.revert(resources));\n\t}\n\n\t@command('git.unstageAll', { repository: true })\n\tasync unstageAll(repository: Repository): Promise<void> {\n\t\tawait repository.revert([]);\n\t}\n\n\t@command('git.unstageSelectedRanges', { diff: true })\n\tasync unstageSelectedRanges(diffs: LineChange[]): Promise<void> {\n\t\tconst textEditor = window.activeTextEditor;\n\n\t\tif (!textEditor) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst modifiedDocument = textEditor.document;\n\t\tconst modifiedUri = modifiedDocument.uri;\n\n\t\tif (modifiedUri.scheme !== 'git') {\n\t\t\treturn;\n\t\t}\n\n\t\tconst { ref } = fromGitUri(modifiedUri);\n\n\t\tif (ref !== '') {\n\t\t\treturn;\n\t\t}\n\n\t\tconst originalUri = toGitUri(modifiedUri, 'HEAD');\n\t\tconst originalDocument = await workspace.openTextDocument(originalUri);\n\t\tconst selectedLines = toLineRanges(textEditor.selections, modifiedDocument);\n\t\tconst selectedDiffs = diffs\n\t\t\t.map(diff => selectedLines.reduce<LineChange | null>((result, range) => result || intersectDiffWithRange(modifiedDocument, diff, range), null))\n\t\t\t.filter(d => !!d) as LineChange[];\n\n\t\tif (!selectedDiffs.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst invertedDiffs = selectedDiffs.map(invertLineChange);\n\t\tconst result = applyLineChanges(modifiedDocument, originalDocument, invertedDiffs);\n\n\t\tawait this.runByRepository(modifiedUri, async (repository, resource) => await repository.stage(resource, result));\n\t}\n\n\t@command('git.clean')\n\tasync clean(...resourceStates: SourceControlResourceState[]): Promise<void> {\n\t\tif (resourceStates.length === 0 || (resourceStates[0] && !(resourceStates[0].resourceUri instanceof Uri))) {\n\t\t\tconst resource = this.getSCMResource();\n\n\t\t\tif (!resource) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tresourceStates = [resource];\n\t\t}\n\n\t\tconst scmResources = resourceStates\n\t\t\t.filter(s => s instanceof Resource && s.resourceGroupType === ResourceGroupType.WorkingTree) as Resource[];\n\n\t\tif (!scmResources.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst untrackedCount = scmResources.reduce((s, r) => s + (r.type === Status.UNTRACKED ? 1 : 0), 0);\n\t\tlet message: string;\n\t\tlet yes = localize('discard', \"Discard Changes\");\n\n\t\tif (scmResources.length === 1) {\n\t\t\tif (untrackedCount > 0) {\n\t\t\t\tmessage = localize('confirm delete', \"Are you sure you want to DELETE {0}?\", path.basename(scmResources[0].resourceUri.fsPath));\n\t\t\t\tyes = localize('delete file', \"Delete file\");\n\t\t\t} else {\n\t\t\t\tmessage = localize('confirm discard', \"Are you sure you want to discard changes in {0}?\", path.basename(scmResources[0].resourceUri.fsPath));\n\t\t\t}\n\t\t} else {\n\t\t\tmessage = localize('confirm discard multiple', \"Are you sure you want to discard changes in {0} files?\", scmResources.length);\n\n\t\t\tif (untrackedCount > 0) {\n\t\t\t\tmessage = `${message}\\n\\n${localize('warn untracked', \"This will DELETE {0} untracked files!\", untrackedCount)}`;\n\t\t\t}\n\t\t}\n\n\t\tconst pick = await window.showWarningMessage(message, { modal: true }, yes);\n\n\t\tif (pick !== yes) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst resources = scmResources.map(r => r.resourceUri);\n\t\tawait this.runByRepository(resources, async (repository, resources) => repository.clean(resources));\n\t}\n\n\t@command('git.cleanAll', { repository: true })\n\tasync cleanAll(repository: Repository): Promise<void> {\n\t\tlet resources = repository.workingTreeGroup.resourceStates;\n\n\t\tif (resources.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst trackedResources = resources.filter(r => r.type !== Status.UNTRACKED && r.type !== Status.IGNORED);\n\t\tconst untrackedResources = resources.filter(r => r.type === Status.UNTRACKED || r.type === Status.IGNORED);\n\n\t\tif (untrackedResources.length === 0) {\n\t\t\tconst message = resources.length === 1\n\t\t\t\t? localize('confirm discard all single', \"Are you sure you want to discard changes in {0}?\", path.basename(resources[0].resourceUri.fsPath))\n\t\t\t\t: localize('confirm discard all', \"Are you sure you want to discard ALL changes in {0} files?\\nThis is IRREVERSIBLE!\\nYour current working set will be FOREVER LOST.\", resources.length);\n\t\t\tconst yes = resources.length === 1\n\t\t\t\t? localize('discardAll multiple', \"Discard 1 File\")\n\t\t\t\t: localize('discardAll', \"Discard All {0} Files\", resources.length);\n\t\t\tconst pick = await window.showWarningMessage(message, { modal: true }, yes);\n\n\t\t\tif (pick !== yes) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tawait repository.clean(resources.map(r => r.resourceUri));\n\t\t\treturn;\n\t\t} else if (resources.length === 1) {\n\t\t\tconst message = localize('confirm delete', \"Are you sure you want to DELETE {0}?\", path.basename(resources[0].resourceUri.fsPath));\n\t\t\tconst yes = localize('delete file', \"Delete file\");\n\t\t\tconst pick = await window.showWarningMessage(message, { modal: true }, yes);\n\n\t\t\tif (pick !== yes) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tawait repository.clean(resources.map(r => r.resourceUri));\n\t\t} else if (trackedResources.length === 0) {\n\t\t\tconst message = localize('confirm delete multiple', \"Are you sure you want to DELETE {0} files?\", resources.length);\n\t\t\tconst yes = localize('delete files', \"Delete Files\");\n\t\t\tconst pick = await window.showWarningMessage(message, { modal: true }, yes);\n\n\t\t\tif (pick !== yes) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tawait repository.clean(resources.map(r => r.resourceUri));\n\n\t\t} else { // resources.length > 1 && untrackedResources.length > 0 && trackedResources.length > 0\n\t\t\tconst untrackedMessage = untrackedResources.length === 1\n\t\t\t\t? localize('there are untracked files single', \"The following untracked file will be DELETED FROM DISK if discarded: {0}.\", path.basename(untrackedResources[0].resourceUri.fsPath))\n\t\t\t\t: localize('there are untracked files', \"There are {0} untracked files which will be DELETED FROM DISK if discarded.\", untrackedResources.length);\n\n\t\t\tconst message = localize('confirm discard all 2', \"{0}\\n\\nThis is IRREVERSIBLE, your current working set will be FOREVER LOST.\", untrackedMessage, resources.length);\n\n\t\t\tconst yesTracked = trackedResources.length === 1\n\t\t\t\t? localize('yes discard tracked', \"Discard 1 Tracked File\", trackedResources.length)\n\t\t\t\t: localize('yes discard tracked multiple', \"Discard {0} Tracked Files\", trackedResources.length);\n\n\t\t\tconst yesAll = localize('discardAll', \"Discard All {0} Files\", resources.length);\n\t\t\tconst pick = await window.showWarningMessage(message, { modal: true }, yesTracked, yesAll);\n\n\t\t\tif (pick === yesTracked) {\n\t\t\t\tresources = trackedResources;\n\t\t\t} else if (pick !== yesAll) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tawait repository.clean(resources.map(r => r.resourceUri));\n\t\t}\n\t}\n\n\tprivate async smartCommit(\n\t\trepository: Repository,\n\t\tgetCommitMessage: () => Promise<string | undefined>,\n\t\topts?: CommitOptions\n\t): Promise<boolean> {\n\t\tconst config = workspace.getConfiguration('git');\n\t\tconst promptToSaveFilesBeforeCommit = config.get<boolean>('promptToSaveFilesBeforeCommit') === true;\n\n\t\tif (promptToSaveFilesBeforeCommit) {\n\t\t\tconst unsavedTextDocuments = workspace.textDocuments\n\t\t\t\t.filter(d => !d.isUntitled && d.isDirty && isDescendant(repository.root, d.uri.fsPath));\n\n\t\t\tif (unsavedTextDocuments.length > 0) {\n\t\t\t\tconst message = unsavedTextDocuments.length === 1\n\t\t\t\t\t? localize('unsaved files single', \"The following file is unsaved: {0}.\\n\\nWould you like to save it before comitting?\", path.basename(unsavedTextDocuments[0].uri.fsPath))\n\t\t\t\t\t: localize('unsaved files', \"There are {0} unsaved files.\\n\\nWould you like to save them before comitting?\", unsavedTextDocuments.length);\n\t\t\t\tconst saveAndCommit = localize('save and commit', \"Save All & Commit\");\n\t\t\t\tconst commit = localize('commit', \"Commit Anyway\");\n\t\t\t\tconst pick = await window.showWarningMessage(message, { modal: true }, saveAndCommit, commit);\n\n\t\t\t\tif (pick === saveAndCommit) {\n\t\t\t\t\tawait Promise.all(unsavedTextDocuments.map(d => d.save()));\n\t\t\t\t\tawait repository.status();\n\t\t\t\t} else if (pick !== commit) {\n\t\t\t\t\treturn false; // do not commit on cancel\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst enableSmartCommit = config.get<boolean>('enableSmartCommit') === true;\n\t\tconst enableCommitSigning = config.get<boolean>('enableCommitSigning') === true;\n\t\tconst noStagedChanges = repository.indexGroup.resourceStates.length === 0;\n\t\tconst noUnstagedChanges = repository.workingTreeGroup.resourceStates.length === 0;\n\n\t\t// no changes, and the user has not configured to commit all in this case\n\t\tif (!noUnstagedChanges && noStagedChanges && !enableSmartCommit) {\n\n\t\t\t// prompt the user if we want to commit all or not\n\t\t\tconst message = localize('no staged changes', \"There are no staged changes to commit.\\n\\nWould you like to automatically stage all your changes and commit them directly?\");\n\t\t\tconst yes = localize('yes', \"Yes\");\n\t\t\tconst always = localize('always', \"Always\");\n\t\t\tconst pick = await window.showWarningMessage(message, { modal: true }, yes, always);\n\n\t\t\tif (pick === always) {\n\t\t\t\tconfig.update('enableSmartCommit', true, true);\n\t\t\t} else if (pick !== yes) {\n\t\t\t\treturn false; // do not commit on cancel\n\t\t\t}\n\t\t}\n\n\t\tif (!opts) {\n\t\t\topts = { all: noStagedChanges };\n\t\t} else if (!opts.all && noStagedChanges) {\n\t\t\topts = { ...opts, all: true };\n\t\t}\n\n\t\t// enable signing of commits if configurated\n\t\topts.signCommit = enableCommitSigning;\n\n\t\tif (\n\t\t\t// no changes\n\t\t\t(noStagedChanges && noUnstagedChanges)\n\t\t\t// or no staged changes and not `all`\n\t\t\t|| (!opts.all && noStagedChanges)\n\t\t) {\n\t\t\twindow.showInformationMessage(localize('no changes', \"There are no changes to commit.\"));\n\t\t\treturn false;\n\t\t}\n\n\t\tconst message = await getCommitMessage();\n\n\t\tif (!message) {\n\t\t\treturn false;\n\t\t}\n\n\t\tawait repository.commit(message, opts);\n\n\t\treturn true;\n\t}\n\n\tprivate async commitWithAnyInput(repository: Repository, opts?: CommitOptions): Promise<void> {\n\t\tconst message = repository.inputBox.value;\n\t\tconst getCommitMessage = async () => {\n\t\t\tif (message) {\n\t\t\t\treturn message;\n\t\t\t}\n\n\t\t\tlet value: string | undefined = undefined;\n\n\t\t\tif (opts && opts.amend && repository.HEAD && repository.HEAD.commit) {\n\t\t\t\tvalue = (await repository.getCommit(repository.HEAD.commit)).message;\n\t\t\t}\n\n\t\t\treturn await window.showInputBox({\n\t\t\t\tvalue,\n\t\t\t\tplaceHolder: localize('commit message', \"Commit message\"),\n\t\t\t\tprompt: localize('provide commit message', \"Please provide a commit message\"),\n\t\t\t\tignoreFocusOut: true\n\t\t\t});\n\t\t};\n\n\t\tconst didCommit = await this.smartCommit(repository, getCommitMessage, opts);\n\n\t\tif (message && didCommit) {\n\t\t\trepository.inputBox.value = await repository.getCommitTemplate();\n\t\t}\n\t}\n\n\t@command('git.commit', { repository: true })\n\tasync commit(repository: Repository): Promise<void> {\n\t\tawait this.commitWithAnyInput(repository);\n\t}\n\n\t@command('git.commitWithInput', { repository: true })\n\tasync commitWithInput(repository: Repository): Promise<void> {\n\t\tif (!repository.inputBox.value) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst didCommit = await this.smartCommit(repository, async () => repository.inputBox.value);\n\n\t\tif (didCommit) {\n\t\t\trepository.inputBox.value = await repository.getCommitTemplate();\n\t\t}\n\t}\n\n\t@command('git.commitStaged', { repository: true })\n\tasync commitStaged(repository: Repository): Promise<void> {\n\t\tawait this.commitWithAnyInput(repository, { all: false });\n\t}\n\n\t@command('git.commitStagedSigned', { repository: true })\n\tasync commitStagedSigned(repository: Repository): Promise<void> {\n\t\tawait this.commitWithAnyInput(repository, { all: false, signoff: true });\n\t}\n\n\t@command('git.commitStagedAmend', { repository: true })\n\tasync commitStagedAmend(repository: Repository): Promise<void> {\n\t\tawait this.commitWithAnyInput(repository, { all: false, amend: true });\n\t}\n\n\t@command('git.commitAll', { repository: true })\n\tasync commitAll(repository: Repository): Promise<void> {\n\t\tawait this.commitWithAnyInput(repository, { all: true });\n\t}\n\n\t@command('git.commitAllSigned', { repository: true })\n\tasync commitAllSigned(repository: Repository): Promise<void> {\n\t\tawait this.commitWithAnyInput(repository, { all: true, signoff: true });\n\t}\n\n\t@command('git.commitAllAmend', { repository: true })\n\tasync commitAllAmend(repository: Repository): Promise<void> {\n\t\tawait this.commitWithAnyInput(repository, { all: true, amend: true });\n\t}\n\n\t@command('git.undoCommit', { repository: true })\n\tasync undoCommit(repository: Repository): Promise<void> {\n\t\tconst HEAD = repository.HEAD;\n\n\t\tif (!HEAD || !HEAD.commit) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst commit = await repository.getCommit('HEAD');\n\t\tawait repository.reset('HEAD~');\n\t\trepository.inputBox.value = commit.message;\n\t}\n\n\t@command('git.checkout', { repository: true })\n\tasync checkout(repository: Repository, treeish: string): Promise<void> {\n\t\tif (typeof treeish === 'string') {\n\t\t\treturn await repository.checkout(treeish);\n\t\t}\n\n\t\tconst config = workspace.getConfiguration('git');\n\t\tconst checkoutType = config.get<string>('checkoutType') || 'all';\n\t\tconst includeTags = checkoutType === 'all' || checkoutType === 'tags';\n\t\tconst includeRemotes = checkoutType === 'all' || checkoutType === 'remote';\n\n\t\tconst createBranch = new CreateBranchItem(this);\n\n\t\tconst heads = repository.refs.filter(ref => ref.type === RefType.Head)\n\t\t\t.map(ref => new CheckoutItem(ref));\n\n\t\tconst tags = (includeTags ? repository.refs.filter(ref => ref.type === RefType.Tag) : [])\n\t\t\t.map(ref => new CheckoutTagItem(ref));\n\n\t\tconst remoteHeads = (includeRemotes ? repository.refs.filter(ref => ref.type === RefType.RemoteHead) : [])\n\t\t\t.map(ref => new CheckoutRemoteHeadItem(ref));\n\n\t\tconst picks = [createBranch, ...heads, ...tags, ...remoteHeads];\n\t\tconst placeHolder = localize('select a ref to checkout', 'Select a ref to checkout');\n\t\tconst choice = await window.showQuickPick(picks, { placeHolder });\n\n\t\tif (!choice) {\n\t\t\treturn;\n\t\t}\n\n\t\tawait choice.run(repository);\n\t}\n\n\t@command('git.branch', { repository: true })\n\tasync branch(repository: Repository): Promise<void> {\n\t\tconst result = await window.showInputBox({\n\t\t\tplaceHolder: localize('branch name', \"Branch name\"),\n\t\t\tprompt: localize('provide branch name', \"Please provide a branch name\"),\n\t\t\tignoreFocusOut: true\n\t\t});\n\n\t\tif (!result) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst name = result.replace(/^\\.|\\/\\.|\\.\\.|~|\\^|:|\\/$|\\.lock$|\\.lock\\/|\\\\|\\*|\\s|^\\s*$|\\.$/g, '-');\n\t\tawait repository.branch(name);\n\t}\n\n\t@command('git.deleteBranch', { repository: true })\n\tasync deleteBranch(repository: Repository, name: string, force?: boolean): Promise<void> {\n\t\tlet run: (force?: boolean) => Promise<void>;\n\t\tif (typeof name === 'string') {\n\t\t\trun = force => repository.deleteBranch(name, force);\n\t\t} else {\n\t\t\tconst currentHead = repository.HEAD && repository.HEAD.name;\n\t\t\tconst heads = repository.refs.filter(ref => ref.type === RefType.Head && ref.name !== currentHead)\n\t\t\t\t.map(ref => new BranchDeleteItem(ref));\n\n\t\t\tconst placeHolder = localize('select branch to delete', 'Select a branch to delete');\n\t\t\tconst choice = await window.showQuickPick<BranchDeleteItem>(heads, { placeHolder });\n\n\t\t\tif (!choice || !choice.branchName) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tname = choice.branchName;\n\t\t\trun = force => choice.run(repository, force);\n\t\t}\n\n\t\ttry {\n\t\t\tawait run(force);\n\t\t} catch (err) {\n\t\t\tif (err.gitErrorCode !== GitErrorCodes.BranchNotFullyMerged) {\n\t\t\t\tthrow err;\n\t\t\t}\n\n\t\t\tconst message = localize('confirm force delete branch', \"The branch '{0}' is not fully merged. Delete anyway?\", name);\n\t\t\tconst yes = localize('delete branch', \"Delete Branch\");\n\t\t\tconst pick = await window.showWarningMessage(message, yes);\n\n\t\t\tif (pick === yes) {\n\t\t\t\tawait run(true);\n\t\t\t}\n\t\t}\n\t}\n\n\t@command('git.renameBranch', { repository: true })\n\tasync renameBranch(repository: Repository): Promise<void> {\n\t\tconst placeHolder = localize('provide branch name', \"Please provide a branch name\");\n\t\tconst name = await window.showInputBox({ placeHolder });\n\n\t\tif (!name || name.trim().length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tawait repository.renameBranch(name);\n\t\t} catch (err) {\n\t\t\tswitch (err.gitErrorCode) {\n\t\t\t\tcase GitErrorCodes.InvalidBranchName:\n\t\t\t\t\twindow.showErrorMessage(localize('invalid branch name', 'Invalid branch name'));\n\t\t\t\t\treturn;\n\t\t\t\tcase GitErrorCodes.BranchAlreadyExists:\n\t\t\t\t\twindow.showErrorMessage(localize('branch already exists', \"A branch named '{0}' already exists\", name));\n\t\t\t\t\treturn;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow err;\n\t\t\t}\n\t\t}\n\t}\n\n\t@command('git.merge', { repository: true })\n\tasync merge(repository: Repository): Promise<void> {\n\t\tconst config = workspace.getConfiguration('git');\n\t\tconst checkoutType = config.get<string>('checkoutType') || 'all';\n\t\tconst includeRemotes = checkoutType === 'all' || checkoutType === 'remote';\n\n\t\tconst heads = repository.refs.filter(ref => ref.type === RefType.Head)\n\t\t\t.filter(ref => ref.name || ref.commit)\n\t\t\t.map(ref => new MergeItem(ref as Branch));\n\n\t\tconst remoteHeads = (includeRemotes ? repository.refs.filter(ref => ref.type === RefType.RemoteHead) : [])\n\t\t\t.filter(ref => ref.name || ref.commit)\n\t\t\t.map(ref => new MergeItem(ref as Branch));\n\n\t\tconst picks = [...heads, ...remoteHeads];\n\t\tconst placeHolder = localize('select a branch to merge from', 'Select a branch to merge from');\n\t\tconst choice = await window.showQuickPick<MergeItem>(picks, { placeHolder });\n\n\t\tif (!choice) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tawait choice.run(repository);\n\t\t} catch (err) {\n\t\t\tif (err.gitErrorCode !== GitErrorCodes.Conflict) {\n\t\t\t\tthrow err;\n\t\t\t}\n\n\t\t\tconst message = localize('merge conflicts', \"There are merge conflicts. Resolve them before committing.\");\n\t\t\tawait window.showWarningMessage(message);\n\t\t}\n\t}\n\n\t@command('git.createTag', { repository: true })\n\tasync createTag(repository: Repository): Promise<void> {\n\t\tconst inputTagName = await window.showInputBox({\n\t\t\tplaceHolder: localize('tag name', \"Tag name\"),\n\t\t\tprompt: localize('provide tag name', \"Please provide a tag name\"),\n\t\t\tignoreFocusOut: true\n\t\t});\n\n\t\tif (!inputTagName) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst inputMessage = await window.showInputBox({\n\t\t\tplaceHolder: localize('tag message', \"Message\"),\n\t\t\tprompt: localize('provide tag message', \"Please provide a message to annotate the tag\"),\n\t\t\tignoreFocusOut: true\n\t\t});\n\n\t\tconst name = inputTagName.replace(/^\\.|\\/\\.|\\.\\.|~|\\^|:|\\/$|\\.lock$|\\.lock\\/|\\\\|\\*|\\s|^\\s*$|\\.$/g, '-');\n\t\tconst message = inputMessage || name;\n\t\tawait repository.tag(name, message);\n\t}\n\n\t@command('git.fetch', { repository: true })\n\tasync fetch(repository: Repository): Promise<void> {\n\t\tif (repository.remotes.length === 0) {\n\t\t\twindow.showWarningMessage(localize('no remotes to fetch', \"This repository has no remotes configured to fetch from.\"));\n\t\t\treturn;\n\t\t}\n\n\t\tawait repository.fetch();\n\t}\n\n\t@command('git.pullFrom', { repository: true })\n\tasync pullFrom(repository: Repository): Promise<void> {\n\t\tconst remotes = repository.remotes;\n\n\t\tif (remotes.length === 0) {\n\t\t\twindow.showWarningMessage(localize('no remotes to pull', \"Your repository has no remotes configured to pull from.\"));\n\t\t\treturn;\n\t\t}\n\n\t\tconst remotePicks = remotes.map(r => ({ label: r.name, description: r.url }));\n\t\tconst placeHolder = localize('pick remote pull repo', \"Pick a remote to pull the branch from\");\n\t\tconst remotePick = await window.showQuickPick(remotePicks, { placeHolder });\n\n\t\tif (!remotePick) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst remoteRefs = repository.refs;\n\t\tconst remoteRefsFiltered = remoteRefs.filter(r => (r.remote === remotePick.label));\n\t\tconst branchPicks = remoteRefsFiltered.map(r => ({ label: r.name })) as { label: string; description: string }[];\n\t\tconst branchPick = await window.showQuickPick(branchPicks, { placeHolder });\n\n\t\tif (!branchPick) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst remoteCharCnt = remotePick.label.length;\n\n\t\trepository.pullFrom(false, remotePick.label, branchPick.label.slice(remoteCharCnt + 1));\n\t}\n\n\t@command('git.pull', { repository: true })\n\tasync pull(repository: Repository): Promise<void> {\n\t\tconst remotes = repository.remotes;\n\n\t\tif (remotes.length === 0) {\n\t\t\twindow.showWarningMessage(localize('no remotes to pull', \"Your repository has no remotes configured to pull from.\"));\n\t\t\treturn;\n\t\t}\n\n\t\tawait repository.pull(repository.HEAD);\n\t}\n\n\t@command('git.pullRebase', { repository: true })\n\tasync pullRebase(repository: Repository): Promise<void> {\n\t\tconst remotes = repository.remotes;\n\n\t\tif (remotes.length === 0) {\n\t\t\twindow.showWarningMessage(localize('no remotes to pull', \"Your repository has no remotes configured to pull from.\"));\n\t\t\treturn;\n\t\t}\n\n\t\tawait repository.pullWithRebase(repository.HEAD);\n\t}\n\n\t@command('git.push', { repository: true })\n\tasync push(repository: Repository): Promise<void> {\n\t\tconst remotes = repository.remotes;\n\n\t\tif (remotes.length === 0) {\n\t\t\twindow.showWarningMessage(localize('no remotes to push', \"Your repository has no remotes configured to push to.\"));\n\t\t\treturn;\n\t\t}\n\n\t\tif (!repository.HEAD || !repository.HEAD.name) {\n\t\t\twindow.showWarningMessage(localize('nobranch', \"Please check out a branch to push to a remote.\"));\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tawait repository.push(repository.HEAD);\n\t\t} catch (err) {\n\t\t\tif (err.gitErrorCode !== GitErrorCodes.NoUpstreamBranch) {\n\t\t\t\tthrow err;\n\t\t\t}\n\n\t\t\tconst branchName = repository.HEAD.name;\n\t\t\tconst message = localize('confirm publish branch', \"The branch '{0}' has no upstream branch. Would you like to publish this branch?\", branchName);\n\t\t\tconst yes = localize('ok', \"OK\");\n\t\t\tconst pick = await window.showWarningMessage(message, { modal: true }, yes);\n\n\t\t\tif (pick === yes) {\n\t\t\t\tawait this.publish(repository);\n\t\t\t}\n\t\t}\n\t}\n\n\t@command('git.pushWithTags', { repository: true })\n\tasync pushWithTags(repository: Repository): Promise<void> {\n\t\tconst remotes = repository.remotes;\n\n\t\tif (remotes.length === 0) {\n\t\t\twindow.showWarningMessage(localize('no remotes to push', \"Your repository has no remotes configured to push to.\"));\n\t\t\treturn;\n\t\t}\n\n\t\tawait repository.pushTags();\n\n\t\twindow.showInformationMessage(localize('push with tags success', \"Successfully pushed with tags.\"));\n\t}\n\n\t@command('git.pushTo', { repository: true })\n\tasync pushTo(repository: Repository): Promise<void> {\n\t\tconst remotes = repository.remotes;\n\n\t\tif (remotes.length === 0) {\n\t\t\twindow.showWarningMessage(localize('no remotes to push', \"Your repository has no remotes configured to push to.\"));\n\t\t\treturn;\n\t\t}\n\n\t\tif (!repository.HEAD || !repository.HEAD.name) {\n\t\t\twindow.showWarningMessage(localize('nobranch', \"Please check out a branch to push to a remote.\"));\n\t\t\treturn;\n\t\t}\n\n\t\tconst branchName = repository.HEAD.name;\n\t\tconst picks = remotes.map(r => ({ label: r.name, description: r.url }));\n\t\tconst placeHolder = localize('pick remote', \"Pick a remote to publish the branch '{0}' to:\", branchName);\n\t\tconst pick = await window.showQuickPick(picks, { placeHolder });\n\n\t\tif (!pick) {\n\t\t\treturn;\n\t\t}\n\n\t\trepository.pushTo(pick.label, branchName);\n\t}\n\n\tprivate async _sync(repository: Repository, rebase: boolean): Promise<void> {\n\t\tconst HEAD = repository.HEAD;\n\n\t\tif (!HEAD || !HEAD.upstream) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst config = workspace.getConfiguration('git');\n\t\tconst shouldPrompt = config.get<boolean>('confirmSync') === true;\n\n\t\tif (shouldPrompt) {\n\t\t\tconst message = localize('sync is unpredictable', \"This action will push and pull commits to and from '{0}/{1}'.\", HEAD.upstream.remote, HEAD.upstream.name);\n\t\t\tconst yes = localize('ok', \"OK\");\n\t\t\tconst neverAgain = localize('never again', \"OK, Don't Show Again\");\n\t\t\tconst pick = await window.showWarningMessage(message, { modal: true }, yes, neverAgain);\n\n\t\t\tif (pick === neverAgain) {\n\t\t\t\tawait config.update('confirmSync', false, true);\n\t\t\t} else if (pick !== yes) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (rebase) {\n\t\t\tawait repository.syncRebase(HEAD);\n\t\t} else {\n\t\t\tawait repository.sync(HEAD);\n\t\t}\n\t}\n\n\t@command('git.sync', { repository: true })\n\tsync(repository: Repository): Promise<void> {\n\t\treturn this._sync(repository, false);\n\t}\n\n\t@command('git._syncAll')\n\tasync syncAll(): Promise<void> {\n\t\tawait Promise.all(this.model.repositories.map(async repository => {\n\t\t\tconst HEAD = repository.HEAD;\n\n\t\t\tif (!HEAD || !HEAD.upstream) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tawait repository.sync(HEAD);\n\t\t}));\n\t}\n\n\t@command('git.syncRebase', { repository: true })\n\tsyncRebase(repository: Repository): Promise<void> {\n\t\treturn this._sync(repository, true);\n\t}\n\n\t@command('git.publish', { repository: true })\n\tasync publish(repository: Repository): Promise<void> {\n\t\tconst remotes = repository.remotes;\n\n\t\tif (remotes.length === 0) {\n\t\t\twindow.showWarningMessage(localize('no remotes to publish', \"Your repository has no remotes configured to publish to.\"));\n\t\t\treturn;\n\t\t}\n\n\t\tconst branchName = repository.HEAD && repository.HEAD.name || '';\n\t\tconst selectRemote = async () => {\n\t\t\tconst picks = repository.remotes.map(r => r.name);\n\t\t\tconst placeHolder = localize('pick remote', \"Pick a remote to publish the branch '{0}' to:\", branchName);\n\t\t\treturn await window.showQuickPick(picks, { placeHolder });\n\t\t};\n\t\tconst choice = remotes.length === 1 ? remotes[0].name : await selectRemote();\n\n\t\tif (!choice) {\n\t\t\treturn;\n\t\t}\n\n\t\tawait repository.pushTo(choice, branchName, true);\n\t}\n\n\t@command('git.ignore')\n\tasync ignore(...resourceStates: SourceControlResourceState[]): Promise<void> {\n\t\tif (resourceStates.length === 0 || (resourceStates[0] && !(resourceStates[0].resourceUri instanceof Uri))) {\n\t\t\tconst resource = this.getSCMResource();\n\n\t\t\tif (!resource) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tresourceStates = [resource];\n\t\t}\n\n\t\tconst resources = resourceStates\n\t\t\t.filter(s => s instanceof Resource)\n\t\t\t.map(r => r.resourceUri);\n\n\t\tif (!resources.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tawait this.runByRepository(resources, async (repository, resources) => repository.ignore(resources));\n\t}\n\n\tprivate async _stash(repository: Repository, includeUntracked = false): Promise<void> {\n\t\tconst noUnstagedChanges = repository.workingTreeGroup.resourceStates.length === 0;\n\t\tconst noStagedChanges = repository.indexGroup.resourceStates.length === 0;\n\n\t\tif (noUnstagedChanges && noStagedChanges) {\n\t\t\twindow.showInformationMessage(localize('no changes stash', \"There are no changes to stash.\"));\n\t\t\treturn;\n\t\t}\n\n\t\tconst message = await this.getStashMessage();\n\n\t\tif (typeof message === 'undefined') {\n\t\t\treturn;\n\t\t}\n\n\t\tawait repository.createStash(message, includeUntracked);\n\t}\n\n\tprivate async getStashMessage(): Promise<string | undefined> {\n\t\treturn await window.showInputBox({\n\t\t\tprompt: localize('provide stash message', \"Optionally provide a stash message\"),\n\t\t\tplaceHolder: localize('stash message', \"Stash message\")\n\t\t});\n\t}\n\n\t@command('git.stash', { repository: true })\n\tstash(repository: Repository): Promise<void> {\n\t\treturn this._stash(repository);\n\t}\n\n\t@command('git.stashIncludeUntracked', { repository: true })\n\tstashIncludeUntracked(repository: Repository): Promise<void> {\n\t\treturn this._stash(repository, true);\n\t}\n\n\t@command('git.stashPop', { repository: true })\n\tasync stashPop(repository: Repository): Promise<void> {\n\t\tconst stashes = await repository.getStashes();\n\n\t\tif (stashes.length === 0) {\n\t\t\twindow.showInformationMessage(localize('no stashes', \"There are no stashes to restore.\"));\n\t\t\treturn;\n\t\t}\n\n\t\tconst picks = stashes.map(r => ({ label: `#${r.index}:  ${r.description}`, description: '', details: '', id: r.index }));\n\t\tconst placeHolder = localize('pick stash to pop', \"Pick a stash to pop\");\n\t\tconst choice = await window.showQuickPick(picks, { placeHolder });\n\n\t\tif (!choice) {\n\t\t\treturn;\n\t\t}\n\n\t\tawait repository.popStash(choice.id);\n\t}\n\n\t@command('git.stashPopLatest', { repository: true })\n\tasync stashPopLatest(repository: Repository): Promise<void> {\n\t\tconst stashes = await repository.getStashes();\n\n\t\tif (stashes.length === 0) {\n\t\t\twindow.showInformationMessage(localize('no stashes', \"There are no stashes to restore.\"));\n\t\t\treturn;\n\t\t}\n\n\t\tawait repository.popStash();\n\t}\n\n\tprivate createCommand(id: string, key: string, method: Function, options: CommandOptions): (...args: any[]) => any {\n\t\tconst result = (...args: any[]) => {\n\t\t\tlet result: Promise<any>;\n\n\t\t\tif (!options.repository) {\n\t\t\t\tresult = Promise.resolve(method.apply(this, args));\n\t\t\t} else {\n\t\t\t\t// try to guess the repository based on the first argument\n\t\t\t\tconst repository = this.model.getRepository(args[0]);\n\t\t\t\tlet repositoryPromise: Promise<Repository | undefined>;\n\n\t\t\t\tif (repository) {\n\t\t\t\t\trepositoryPromise = Promise.resolve(repository);\n\t\t\t\t} else if (this.model.repositories.length === 1) {\n\t\t\t\t\trepositoryPromise = Promise.resolve(this.model.repositories[0]);\n\t\t\t\t} else {\n\t\t\t\t\trepositoryPromise = this.model.pickRepository();\n\t\t\t\t}\n\n\t\t\t\tresult = repositoryPromise.then(repository => {\n\t\t\t\t\tif (!repository) {\n\t\t\t\t\t\treturn Promise.resolve();\n\t\t\t\t\t}\n\n\t\t\t\t\treturn Promise.resolve(method.apply(this, [repository, ...args]));\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t/* __GDPR__\n\t\t\t\t\"git.command\" : {\n\t\t\t\t\t\"command\" : { \"classification\": \"SystemMetaData\", \"purpose\": \"FeatureInsight\" }\n\t\t\t\t}\n\t\t\t*/\n\t\t\tthis.telemetryReporter.sendTelemetryEvent('git.command', { command: id });\n\n\t\t\treturn result.catch(async err => {\n\t\t\t\tconst options: MessageOptions = {\n\t\t\t\t\tmodal: err.gitErrorCode === GitErrorCodes.DirtyWorkTree\n\t\t\t\t};\n\n\t\t\t\tlet message: string;\n\n\t\t\t\tswitch (err.gitErrorCode) {\n\t\t\t\t\tcase GitErrorCodes.DirtyWorkTree:\n\t\t\t\t\t\tmessage = localize('clean repo', \"Please clean your repository working tree before checkout.\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GitErrorCodes.PushRejected:\n\t\t\t\t\t\tmessage = localize('cant push', \"Can't push refs to remote. Try running 'Pull' first to integrate your changes.\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconst hint = (err.stderr || err.message || String(err))\n\t\t\t\t\t\t\t.replace(/^error: /mi, '')\n\t\t\t\t\t\t\t.replace(/^> husky.*$/mi, '')\n\t\t\t\t\t\t\t.split(/[\\r\\n]/)\n\t\t\t\t\t\t\t.filter((line: string) => !!line)\n\t\t\t\t\t\t[0];\n\n\t\t\t\t\t\tmessage = hint\n\t\t\t\t\t\t\t? localize('git error details', \"Git: {0}\", hint)\n\t\t\t\t\t\t\t: localize('git error', \"Git error\");\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (!message) {\n\t\t\t\t\tconsole.error(err);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\toptions.modal = true;\n\n\t\t\t\tconst outputChannel = this.outputChannel as OutputChannel;\n\t\t\t\tconst openOutputChannelChoice = localize('open git log', \"Open Git Log\");\n\t\t\t\tconst choice = await window.showErrorMessage(message, options, openOutputChannelChoice);\n\n\t\t\t\tif (choice === openOutputChannelChoice) {\n\t\t\t\t\toutputChannel.show();\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\n\t\t// patch this object, so people can call methods directly\n\t\t(this as any)[key] = result;\n\n\t\treturn result;\n\t}\n\n\tprivate getSCMResource(uri?: Uri): Resource | undefined {\n\t\turi = uri ? uri : window.activeTextEditor && window.activeTextEditor.document.uri;\n\n\t\tif (!uri) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (uri.scheme === 'git') {\n\t\t\tconst { path } = fromGitUri(uri);\n\t\t\turi = Uri.file(path);\n\t\t}\n\n\t\tif (uri.scheme === 'file') {\n\t\t\tconst uriString = uri.toString();\n\t\t\tconst repository = this.model.getRepository(uri);\n\n\t\t\tif (!repository) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\treturn repository.workingTreeGroup.resourceStates.filter(r => r.resourceUri.toString() === uriString)[0]\n\t\t\t\t|| repository.indexGroup.resourceStates.filter(r => r.resourceUri.toString() === uriString)[0];\n\t\t}\n\t}\n\n\tprivate runByRepository<T>(resource: Uri, fn: (repository: Repository, resource: Uri) => Promise<T>): Promise<T[]>;\n\tprivate runByRepository<T>(resources: Uri[], fn: (repository: Repository, resources: Uri[]) => Promise<T>): Promise<T[]>;\n\tprivate async runByRepository<T>(arg: Uri | Uri[], fn: (repository: Repository, resources: any) => Promise<T>): Promise<T[]> {\n\t\tconst resources = arg instanceof Uri ? [arg] : arg;\n\t\tconst isSingleResource = arg instanceof Uri;\n\n\t\tconst groups = resources.reduce((result, resource) => {\n\t\t\tlet repository = this.model.getRepository(resource);\n\n\t\t\tif (!repository) {\n\t\t\t\tconsole.warn('Could not find git repository for ', resource);\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\t// Could it be a submodule?\n\t\t\tif (resource.fsPath === repository.root) {\n\t\t\t\trepository = this.model.getRepositoryForSubmodule(resource) || repository;\n\t\t\t}\n\n\t\t\tconst tuple = result.filter(p => p.repository === repository)[0];\n\n\t\t\tif (tuple) {\n\t\t\t\ttuple.resources.push(resource);\n\t\t\t} else {\n\t\t\t\tresult.push({ repository, resources: [resource] });\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}, [] as { repository: Repository, resources: Uri[] }[]);\n\n\t\tconst promises = groups\n\t\t\t.map(({ repository, resources }) => fn(repository as Repository, isSingleResource ? resources[0] : resources));\n\n\t\treturn Promise.all(promises);\n\t}\n\n\tdispose(): void {\n\t\tthis.disposables.forEach(d => d.dispose());\n\t}\n}\n",
            "linguagem": "ts",
            "total_linhas": 1754
        },
        "solucao_humana": {
            "patch_diff": "@@ -1205,7 +1205,7 @@ export class CommandCenter {\n \n \t\t\tconst message = localize('confirm force delete branch', \"The branch '{0}' is not fully merged. Delete anyway?\", name);\n \t\t\tconst yes = localize('delete branch', \"Delete Branch\");\n-\t\t\tconst pick = await window.showWarningMessage(message, yes);\n+\t\t\tconst pick = await window.showWarningMessage(message, { modal: true }, yes);\n \n \t\t\tif (pick === yes) {\n \t\t\t\tawait run(true);",
            "apenas_linhas_adicionadas": [
                "\t\t\tconst pick = await window.showWarningMessage(message, { modal: true }, yes);"
            ]
        },
        "LLM": "CHAT GPT",
        "solucao_llm": "const pick = await window.showWarningMessage(message, { modal: true }, yes);

			if (pick === yes) {
				await run(true);
			}"
    },
{
        "id": 37017,
        "url": "https://github.com/microsoft/vscode/pull/37017",
        "arquivo_caminho": "src/vs/editor/editor.main.ts",
        "descricao_bug": "For some reason,  I have to compile the monaco-editor by myself.\r\nRecently I update the monaco and found that the editor crash while loading the monaco.\r\nIt seems that we need polyfill the `promise` after we set the `global`.\r\n\r\n<img width=\"540\" alt=\"2017-10-27 11 45 47\" src=\"https://user-images.githubusercontent.com/12891758/32087135-6fa9c114-ba9f-11e7-83ca-030e75b18772.png\">\r\n\r\n",
        "contexto": {
            "codigo_completo_bugado": "*/\n\n'use strict';\n\nimport 'vs/editor/editor.all';\nimport 'vs/editor/standalone/browser/accessibilityHelp/accessibilityHelp';\nimport 'vs/editor/standalone/browser/inspectTokens/inspectTokens';\nimport 'vs/editor/standalone/browser/iPadShowKeyboard/iPadShowKeyboard';\nimport 'vs/editor/standalone/browser/quickOpen/quickOutline';\nimport 'vs/editor/standalone/browser/quickOpen/gotoLine';\nimport 'vs/editor/standalone/browser/quickOpen/quickCommand';\nimport 'vs/editor/standalone/browser/toggleHighContrast/toggleHighContrast';\n\nimport { createMonacoBaseAPI } from 'vs/editor/common/standalone/standaloneBase';\nimport { createMonacoEditorAPI } from 'vs/editor/standalone/browser/standaloneEditor';\nimport { createMonacoLanguagesAPI } from 'vs/editor/standalone/browser/standaloneLanguages';\nimport { EDITOR_DEFAULTS, WrappingIndent } from 'vs/editor/common/config/editorOptions';\n\n// When missing, polyfill the native promise\n// with our winjs-based polyfill\nimport { PolyfillPromise } from 'vs/base/common/winjs.polyfill.promise';\nif (typeof global.Promise === 'undefined') {\n\tglobal.Promise = PolyfillPromise;\n}\n\n// Set defaults for standalone editor\n(<any>EDITOR_DEFAULTS).wrappingIndent = WrappingIndent.None;\n(<any>EDITOR_DEFAULTS.contribInfo).folding = false;\n(<any>EDITOR_DEFAULTS.viewInfo).glyphMargin = false;\n(<any>EDITOR_DEFAULTS).autoIndent = false;\n\nlet base = createMonacoBaseAPI();\nfor (let prop in base) {\n\tif (base.hasOwnProperty(prop)) {\n\t\texports[prop] = base[prop];\n\t}\n}\nexports.editor = createMonacoEditorAPI();\nexports.languages = createMonacoLanguagesAPI();\n\nvar global: any = self;\nglobal.monaco = exports;\n\nif (typeof global.require !== 'undefined' && typeof global.require.config === 'function') {\n\tglobal.require.config({\n\t\tignoreDuplicateModules: [\n\t\t\t'vscode-languageserver-types',\n\t\t\t'vscode-languageserver-types/main',\n\t\t\t'vscode-nls',\n\t\t\t'vscode-nls/vscode-nls',\n\t\t\t'jsonc-parser',\n\t\t\t'jsonc-parser/main',\n\t\t\t'vscode-uri',\n\t\t\t'vscode-uri/index'\n\t\t]\n\t});\n}\n",
            "linguagem": "ts",
            "total_linhas": 61
        },
        "solucao_humana": {
            "patch_diff": "@@ -19,6 +19,9 @@ import { createMonacoEditorAPI } from 'vs/editor/standalone/browser/standaloneEd\n import { createMonacoLanguagesAPI } from 'vs/editor/standalone/browser/standaloneLanguages';\n import { EDITOR_DEFAULTS, WrappingIndent } from 'vs/editor/common/config/editorOptions';\n \n+var global: any = self;\n+global.monaco = exports;\n+\n // When missing, polyfill the native promise\n // with our winjs-based polyfill\n import { PolyfillPromise } from 'vs/base/common/winjs.polyfill.promise';\n@@ -41,9 +44,6 @@ for (let prop in base) {\n exports.editor = createMonacoEditorAPI();\n exports.languages = createMonacoLanguagesAPI();\n \n-var global: any = self;\n-global.monaco = exports;\n-\n if (typeof global.require !== 'undefined' && typeof global.require.config === 'function') {\n \tglobal.require.config({\n \t\tignoreDuplicateModules: [",
            "apenas_linhas_adicionadas": [
                "var global: any = self;",
                "global.monaco = exports;",
                ""
            ]
        },
        "LLM": "CHAT GPT",
        "solucao_llm": "var global: any = self;
        global.monaco = exports;"
    }



